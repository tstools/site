{"statements":[{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.TreeProcessor","newFunction":"function() {\r\n    function TreeProcessor(attrs) {\r\n        var tree = attrs.tree,\r\n            runnableIds = attrs.runnableIds,\r\n            queueRunnerFactory = attrs.queueRunnerFactory,\r\n            nodeStart = attrs.nodeStart || function() {},\r\n            nodeComplete = attrs.nodeComplete || function() {},\r\n            orderChildren = attrs.orderChildren || function(node) { return node.children; },\r\n            stats = { valid: true },\r\n            processed = false,\r\n            defaultMin = Infinity,\r\n            defaultMax = 1 - Infinity;\r\n\r\n        this.processTree = function() {\r\n            processNode(tree, false);\r\n            processed = true;\r\n            return stats;\r\n        };\r\n\r\n        this.execute = function(done) {\r\n            if (!processed) {\r\n                this.processTree();\r\n            }\r\n\r\n            if (!stats.valid) {\r\n                throw 'invalid order';\r\n            }\r\n\r\n            var childFns = wrapChildren(tree, 0);\r\n\r\n            queueRunnerFactory({\r\n                queueableFns: childFns,\r\n                userContext: tree.sharedUserContext(),\r\n                onException: function() {\r\n                    tree.onException.apply(tree, arguments);\r\n                },\r\n                onComplete: done\r\n            });\r\n        };\r\n\r\n        function runnableIndex(id) {\r\n            for (var i = 0; i < runnableIds.length; i++) {\r\n                if (runnableIds[i] === id) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n\r\n        function processNode(node, parentEnabled) {\r\n            var executableIndex = runnableIndex(node.id);\r\n\r\n            if (executableIndex !== undefined) {\r\n                parentEnabled = true;\r\n            }\r\n\r\n            parentEnabled = parentEnabled && node.isExecutable();\r\n\r\n            if (!node.children) {\r\n                stats[node.id] = {\r\n                    executable: parentEnabled && node.isExecutable(),\r\n                    segments: [{\r\n                        index: 0,\r\n                        owner: node,\r\n                        nodes: [node],\r\n                        min: startingMin(executableIndex),\r\n                        max: startingMax(executableIndex)\r\n                    }]\r\n                };\r\n            } else {\r\n                var hasExecutableChild = false;\r\n\r\n                var orderedChildren = orderChildren(node);\r\n\r\n                for (var i = 0; i < orderedChildren.length; i++) {\r\n                    var child = orderedChildren[i];\r\n\r\n                    processNode(child, parentEnabled);\r\n\r\n                    if (!stats.valid) {\r\n                        return;\r\n                    }\r\n\r\n                    var childStats = stats[child.id];\r\n\r\n                    hasExecutableChild = hasExecutableChild || childStats.executable;\r\n                }\r\n\r\n                stats[node.id] = {\r\n                    executable: hasExecutableChild\r\n                };\r\n\r\n                segmentChildren(node, orderedChildren, stats[node.id], executableIndex);\r\n\r\n                if (!node.canBeReentered() && stats[node.id].segments.length > 1) {\r\n                    stats = { valid: false };\r\n                }\r\n            }\r\n        }\r\n\r\n        function startingMin(executableIndex) {\r\n            return executableIndex === undefined ? defaultMin : executableIndex;\r\n        }\r\n\r\n        function startingMax(executableIndex) {\r\n            return executableIndex === undefined ? defaultMax : executableIndex;\r\n        }\r\n\r\n        function segmentChildren(node, orderedChildren, nodeStats, executableIndex) {\r\n            var currentSegment = { index: 0, owner: node, nodes: [], min: startingMin(executableIndex), max: startingMax(executableIndex) },\r\n                result = [currentSegment],\r\n                lastMax = defaultMax,\r\n                orderedChildSegments = orderChildSegments(orderedChildren);\r\n\r\n            function isSegmentBoundary(minIndex) {\r\n                return lastMax !== defaultMax && minIndex !== defaultMin && lastMax < minIndex - 1;\r\n            }\r\n\r\n            for (var i = 0; i < orderedChildSegments.length; i++) {\r\n                var childSegment = orderedChildSegments[i],\r\n                    maxIndex = childSegment.max,\r\n                    minIndex = childSegment.min;\r\n\r\n                if (isSegmentBoundary(minIndex)) {\r\n                    currentSegment = {index: result.length, owner: node, nodes: [], min: defaultMin, max: defaultMax};\r\n                    result.push(currentSegment);\r\n                }\r\n\r\n                currentSegment.nodes.push(childSegment);\r\n                currentSegment.min = Math.min(currentSegment.min, minIndex);\r\n                currentSegment.max = Math.max(currentSegment.max, maxIndex);\r\n                lastMax = maxIndex;\r\n            }\r\n\r\n            nodeStats.segments = result;\r\n        }\r\n\r\n        function orderChildSegments(children) {\r\n            var specifiedOrder = [],\r\n                unspecifiedOrder = [];\r\n\r\n            for (var i = 0; i < children.length; i++) {\r\n                var child = children[i],\r\n                    segments = stats[child.id].segments;\r\n\r\n                for (var j = 0; j < segments.length; j++) {\r\n                    var seg = segments[j];\r\n\r\n                    if (seg.min === defaultMin) {\r\n                        unspecifiedOrder.push(seg);\r\n                    } else {\r\n                        specifiedOrder.push(seg);\r\n                    }\r\n                }\r\n            }\r\n\r\n            specifiedOrder.sort(function(a, b) {\r\n                return a.min - b.min;\r\n            });\r\n\r\n            return specifiedOrder.concat(unspecifiedOrder);\r\n        }\r\n\r\n        function executeNode(node, segmentNumber) {\r\n            if (node.children) {\r\n                return {\r\n                    fn: function(done) {\r\n                        nodeStart(node);\r\n\r\n                        queueRunnerFactory({\r\n                            onComplete: function() {\r\n                                nodeComplete(node, node.getResult());\r\n                                done();\r\n                            },\r\n                            queueableFns: wrapChildren(node, segmentNumber),\r\n                            userContext: node.sharedUserContext(),\r\n                            onException: function() {\r\n                                node.onException.apply(node, arguments);\r\n                            }\r\n                        });\r\n                    }\r\n                };\r\n            } else {\r\n                return {\r\n                    fn: function(done) { node.execute(done, stats[node.id].executable); }\r\n                };\r\n            }\r\n        }\r\n\r\n        function wrapChildren(node, segmentNumber) {\r\n            var result = [],\r\n                segmentChildren = stats[node.id].segments[segmentNumber].nodes;\r\n\r\n            for (var i = 0; i < segmentChildren.length; i++) {\r\n                result.push(executeNode(segmentChildren[i].owner, segmentChildren[i].index));\r\n            }\r\n\r\n            if (!stats[node.id].executable) {\r\n                return result;\r\n            }\r\n\r\n            return node.beforeAllFns.concat(result).concat(node.afterAllFns);\r\n        }\r\n    }\r\n\r\n    return TreeProcessor;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window","oldFunction":null,"oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire","key":"TreeProcessor","newType":"() => (attrs: interface_840) => void","isAny":false,"isClass":false,"containerType":"interface interface_873 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.toHaveBeenCalledTimes","newFunction":"function(j$) {\r\n\r\n    var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalledTimes>', 'expect(<spyObj>).toHaveBeenCalledTimes(<Number>)');\r\n\r\n    function toHaveBeenCalledTimes() {\r\n        return {\r\n            compare: function(actual, expected) {\r\n                if (!j$.isSpy(actual)) {\r\n                    throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));\r\n                }\r\n\r\n                var args = Array.prototype.slice.call(arguments, 0),\r\n                    result = { pass: false };\r\n\r\n                if (!j$.isNumber_(expected)){\r\n                    throw new Error(getErrorMsg('The expected times failed is a required argument and must be a number.'));\r\n                }\r\n\r\n                actual = args[0];\r\n                var calls = actual.calls.count();\r\n                var timesMessage = expected === 1 ? 'once' : expected + ' times';\r\n                result.pass = calls === expected;\r\n                result.message = result.pass ?\r\n                'Expected spy ' + actual.and.identity() + ' not to have been called ' + timesMessage + '. It was called ' +  calls + ' times.' :\r\n                'Expected spy ' + actual.and.identity() + ' to have been called ' + timesMessage + '. It was called ' +  calls + ' times.';\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n\r\n    return toHaveBeenCalledTimes;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window","oldFunction":null,"oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire","key":"toHaveBeenCalledTimes","newType":"(j$: interface_893) => () => interface_895","isAny":false,"isClass":false,"containerType":"interface interface_873 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.toBeGreaterThanOrEqual","newFunction":"function() {\r\n\r\n    function toBeGreaterThanOrEqual() {\r\n        return {\r\n            compare: function(actual, expected) {\r\n                return {\r\n                    pass: actual >= expected\r\n                };\r\n            }\r\n        };\r\n    }\r\n\r\n    return toBeGreaterThanOrEqual;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window","oldFunction":null,"oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire","key":"toBeGreaterThanOrEqual","newType":"() => () => interface_882","isAny":false,"isClass":false,"containerType":"interface interface_873 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.toBeLessThanOrEqual","newFunction":"function() {\r\n    function toBeLessThanOrEqual() {\r\n        return {\r\n\r\n            compare: function(actual, expected) {\r\n                return {\r\n                    pass: actual <= expected\r\n                };\r\n            }\r\n        };\r\n    }\r\n\r\n    return toBeLessThanOrEqual;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window","oldFunction":null,"oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire","key":"toBeLessThanOrEqual","newType":"() => () => interface_884","isAny":false,"isClass":false,"containerType":"interface interface_873 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.Order","newFunction":"function() {\r\n    function Order(options) {\r\n        this.random = 'random' in options ? options.random : true;\r\n        var seed = this.seed = options.seed || generateSeed();\r\n        this.sort = this.random ? randomOrder : naturalOrder;\r\n\r\n        function naturalOrder(items) {\r\n            return items;\r\n        }\r\n\r\n        function randomOrder(items) {\r\n            var copy = items.slice();\r\n            copy.sort(function(a, b) {\r\n                return jenkinsHash(seed + a.id) - jenkinsHash(seed + b.id);\r\n            });\r\n            return copy;\r\n        }\r\n\r\n        function generateSeed() {\r\n            return String(Math.random()).slice(-5);\r\n        }\r\n\r\n        // Bob Jenkins One-at-a-Time Hash algorithm is a non-cryptographic hash function\r\n        // used to get a different output when the key changes slighly.\r\n        // We use your return to sort the children randomly in a consistent way when\r\n        // used in conjunction with a seed\r\n\r\n        function jenkinsHash(key) {\r\n            var hash, i;\r\n            for(hash = i = 0; i < key.length; ++i) {\r\n                hash += key.charCodeAt(i);\r\n                hash += (hash << 10);\r\n                hash ^= (hash >> 6);\r\n            }\r\n            hash += (hash << 3);\r\n            hash ^= (hash >> 11);\r\n            hash += (hash << 15);\r\n            return hash;\r\n        }\r\n\r\n    }\r\n\r\n    return Order;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window","oldFunction":null,"oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire","key":"Order","newType":"() => (options: {random: boolean, seed: any}) => void","isAny":false,"isClass":false,"containerType":"interface interface_873 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.errors","newFunction":"function() {\r\n    function ExpectationFailed() {}\r\n\r\n    ExpectationFailed.prototype = new Error();\r\n    ExpectationFailed.prototype.constructor = ExpectationFailed;\r\n\r\n    return {\r\n        ExpectationFailed: ExpectationFailed\r\n    };\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window","oldFunction":null,"oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire","key":"errors","newType":"() => interface_870","isAny":false,"isClass":false,"containerType":"interface interface_873 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.formatErrorMsg","newFunction":"function() {\r\n    function generateErrorMsg(domain, usage) {\r\n        var usageDefinition = usage ? '\\nUsage: ' + usage : '';\r\n\r\n        return function errorMsg(msg) {\r\n            return domain + ' : ' + msg + usageDefinition;\r\n        };\r\n    }\r\n\r\n    return generateErrorMsg;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window","oldFunction":null,"oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire","key":"formatErrorMsg","newType":"() => (domain: string | number, usage: string | number) => (msg: string | number) => string","isAny":false,"isClass":false,"containerType":"interface interface_873 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":true,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.TreeProcessor","newFunction":"function TreeProcessor(attrs) {\r\n        var tree = attrs.tree,\r\n            runnableIds = attrs.runnableIds,\r\n            queueRunnerFactory = attrs.queueRunnerFactory,\r\n            nodeStart = attrs.nodeStart || function() {},\r\n            nodeComplete = attrs.nodeComplete || function() {},\r\n            orderChildren = attrs.orderChildren || function(node) { return node.children; },\r\n            stats = { valid: true },\r\n            processed = false,\r\n            defaultMin = Infinity,\r\n            defaultMax = 1 - Infinity;\r\n\r\n        this.processTree = function() {\r\n            processNode(tree, false);\r\n            processed = true;\r\n            return stats;\r\n        };\r\n\r\n        this.execute = function(done) {\r\n            if (!processed) {\r\n                this.processTree();\r\n            }\r\n\r\n            if (!stats.valid) {\r\n                throw 'invalid order';\r\n            }\r\n\r\n            var childFns = wrapChildren(tree, 0);\r\n\r\n            queueRunnerFactory({\r\n                queueableFns: childFns,\r\n                userContext: tree.sharedUserContext(),\r\n                onException: function() {\r\n                    tree.onException.apply(tree, arguments);\r\n                },\r\n                onComplete: done\r\n            });\r\n        };\r\n\r\n        function runnableIndex(id) {\r\n            for (var i = 0; i < runnableIds.length; i++) {\r\n                if (runnableIds[i] === id) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n\r\n        function processNode(node, parentEnabled) {\r\n            var executableIndex = runnableIndex(node.id);\r\n\r\n            if (executableIndex !== undefined) {\r\n                parentEnabled = true;\r\n            }\r\n\r\n            parentEnabled = parentEnabled && node.isExecutable();\r\n\r\n            if (!node.children) {\r\n                stats[node.id] = {\r\n                    executable: parentEnabled && node.isExecutable(),\r\n                    segments: [{\r\n                        index: 0,\r\n                        owner: node,\r\n                        nodes: [node],\r\n                        min: startingMin(executableIndex),\r\n                        max: startingMax(executableIndex)\r\n                    }]\r\n                };\r\n            } else {\r\n                var hasExecutableChild = false;\r\n\r\n                var orderedChildren = orderChildren(node);\r\n\r\n                for (var i = 0; i < orderedChildren.length; i++) {\r\n                    var child = orderedChildren[i];\r\n\r\n                    processNode(child, parentEnabled);\r\n\r\n                    if (!stats.valid) {\r\n                        return;\r\n                    }\r\n\r\n                    var childStats = stats[child.id];\r\n\r\n                    hasExecutableChild = hasExecutableChild || childStats.executable;\r\n                }\r\n\r\n                stats[node.id] = {\r\n                    executable: hasExecutableChild\r\n                };\r\n\r\n                segmentChildren(node, orderedChildren, stats[node.id], executableIndex);\r\n\r\n                if (!node.canBeReentered() && stats[node.id].segments.length > 1) {\r\n                    stats = { valid: false };\r\n                }\r\n            }\r\n        }\r\n\r\n        function startingMin(executableIndex) {\r\n            return executableIndex === undefined ? defaultMin : executableIndex;\r\n        }\r\n\r\n        function startingMax(executableIndex) {\r\n            return executableIndex === undefined ? defaultMax : executableIndex;\r\n        }\r\n\r\n        function segmentChildren(node, orderedChildren, nodeStats, executableIndex) {\r\n            var currentSegment = { index: 0, owner: node, nodes: [], min: startingMin(executableIndex), max: startingMax(executableIndex) },\r\n                result = [currentSegment],\r\n                lastMax = defaultMax,\r\n                orderedChildSegments = orderChildSegments(orderedChildren);\r\n\r\n            function isSegmentBoundary(minIndex) {\r\n                return lastMax !== defaultMax && minIndex !== defaultMin && lastMax < minIndex - 1;\r\n            }\r\n\r\n            for (var i = 0; i < orderedChildSegments.length; i++) {\r\n                var childSegment = orderedChildSegments[i],\r\n                    maxIndex = childSegment.max,\r\n                    minIndex = childSegment.min;\r\n\r\n                if (isSegmentBoundary(minIndex)) {\r\n                    currentSegment = {index: result.length, owner: node, nodes: [], min: defaultMin, max: defaultMax};\r\n                    result.push(currentSegment);\r\n                }\r\n\r\n                currentSegment.nodes.push(childSegment);\r\n                currentSegment.min = Math.min(currentSegment.min, minIndex);\r\n                currentSegment.max = Math.max(currentSegment.max, maxIndex);\r\n                lastMax = maxIndex;\r\n            }\r\n\r\n            nodeStats.segments = result;\r\n        }\r\n\r\n        function orderChildSegments(children) {\r\n            var specifiedOrder = [],\r\n                unspecifiedOrder = [];\r\n\r\n            for (var i = 0; i < children.length; i++) {\r\n                var child = children[i],\r\n                    segments = stats[child.id].segments;\r\n\r\n                for (var j = 0; j < segments.length; j++) {\r\n                    var seg = segments[j];\r\n\r\n                    if (seg.min === defaultMin) {\r\n                        unspecifiedOrder.push(seg);\r\n                    } else {\r\n                        specifiedOrder.push(seg);\r\n                    }\r\n                }\r\n            }\r\n\r\n            specifiedOrder.sort(function(a, b) {\r\n                return a.min - b.min;\r\n            });\r\n\r\n            return specifiedOrder.concat(unspecifiedOrder);\r\n        }\r\n\r\n        function executeNode(node, segmentNumber) {\r\n            if (node.children) {\r\n                return {\r\n                    fn: function(done) {\r\n                        nodeStart(node);\r\n\r\n                        queueRunnerFactory({\r\n                            onComplete: function() {\r\n                                nodeComplete(node, node.getResult());\r\n                                done();\r\n                            },\r\n                            queueableFns: wrapChildren(node, segmentNumber),\r\n                            userContext: node.sharedUserContext(),\r\n                            onException: function() {\r\n                                node.onException.apply(node, arguments);\r\n                            }\r\n                        });\r\n                    }\r\n                };\r\n            } else {\r\n                return {\r\n                    fn: function(done) { node.execute(done, stats[node.id].executable); }\r\n                };\r\n            }\r\n        }\r\n\r\n        function wrapChildren(node, segmentNumber) {\r\n            var result = [],\r\n                segmentChildren = stats[node.id].segments[segmentNumber].nodes;\r\n\r\n            for (var i = 0; i < segmentChildren.length; i++) {\r\n                result.push(executeNode(segmentChildren[i].owner, segmentChildren[i].index));\r\n            }\r\n\r\n            if (!stats[node.id].executable) {\r\n                return result;\r\n            }\r\n\r\n            return node.beforeAllFns.concat(result).concat(node.afterAllFns);\r\n        }\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window","oldFunction":null,"oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine","key":"TreeProcessor","newType":"class TreeProcessor1 {\n    constructor (attrs: interface_743);\n    execute: (done: any) => void;\n    processTree: () => interface_611;\n}\n","isAny":false,"isClass":false,"containerType":"declare module jasmine {\n    export class Any {\n        constructor (expectedObject: any);\n        asymmetricMatch: (other: any) => boolean;\n        expectedObject: any;\n        jasmineToString: () => string;\n    }\n    export class Anything {\n        constructor ();\n        asymmetricMatch: (other: any) => boolean;\n        jasmineToString: () => string;\n    }\n    export class ArrayContaining {\n        constructor (sample: any);\n        asymmetricMatch: (other: interface_619) => boolean;\n        jasmineToString: () => string;\n        sample: any;\n    }\n    export class CallTracker {\n        constructor ();\n        all: () => Array<interface_679>;\n        allArgs: () => Array<any>;\n        any: () => boolean;\n        argsFor: (index: number) => Array<any>;\n        count: () => number;\n        first: () => interface_679;\n        mostRecent: () => interface_679;\n        reset: () => void;\n        saveArgumentsByValue: () => void;\n        track: (context: {args: any[]}) => void;\n    }\n    export class Clock {\n        constructor (global: Window | interface_470, delayedFunctionSchedulerFactory: () => jasmine.DelayedFunctionScheduler, mockDate: jasmine.MockDate);\n        clearInterval: (id: Window) => any;\n        clearTimeout: (id: Window) => any;\n        install: () => jasmine.Clock;\n        mockDate: (initialDate: {getTime: () => void}) => void;\n        setInterval: (fn: any, delay: any, params: any) => any;\n        setTimeout: (fn: any, delay: any, params: any) => any;\n        tick: (millis: any) => void;\n        uninstall: () => void;\n        withMock: (closure: () => void) => void;\n    }\n    export var DEFAULT_TIMEOUT_INTERVAL: number;\n    export class DelayedFunctionScheduler {\n        constructor ();\n        removeFunctionWithId: (timeoutKey: any) => void;\n        scheduleFunction: (funcToCall: string | (() => any), millis: number, params: any, recurring: any, timeoutKey: number, newCurrentTime: string) => number;\n        tick: (millis: number, tickDate: (arg0: void) => void) => void;\n    }\n    export class Env {\n        constructor (options: {global: any});\n        addCustomEqualityTester: (tester: any) => void;\n        addMatchers: (matchersToAdd: any) => void;\n        addReporter: (reporterToAdd: any) => void;\n        afterAll: (afterAllFunction: any, timeout: any) => void;\n        afterEach: (afterEachFunction: any, timeout: any) => void;\n        allowRespy: (allow: any) => void;\n        beforeAll: (beforeAllFunction: any, timeout: any) => void;\n        beforeEach: (beforeEachFunction: any, timeout: any) => void;\n        catchExceptions: (value: any) => boolean;\n        catchingExceptions: () => boolean;\n        clock: jasmine.Clock;\n        describe: (description: any, specDefinitions: {call: (arg0: void) => void, length: number}) => jasmine.Suite;\n        execute: (runnablesToRun: string[]) => void;\n        expect: (actual: any) => any;\n        fail: (error: {message: any}) => void;\n        fdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite | {id: any, isFocused: boolean};\n        fit: (description: any, fn: any, timeout: any) => {disabled: boolean} | jasmine.Spec;\n        it: (description: string, fn: () => void, timeout: any) => {disabled: boolean} | jasmine.Spec;\n        pending: (message: string) => void;\n        provideFallbackReporter: (reporterToAdd: any) => void;\n        randomTests: () => boolean;\n        randomizeTests: (value: any) => void;\n        seed: (value: any) => any;\n        specFilter: (spec: jasmine.Spec) => boolean;\n        spyOn: () => interface_490;\n        throwOnExpectationFailure: (value: any) => void;\n        throwingExpectationFailures: () => boolean;\n        topSuite: () => jasmine.Suite;\n        xdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite;\n        xit: () => {pend: (arg0: void) => void};\n    }\n    export class ExceptionFormatter {\n        constructor ();\n        message: (error: interface_682) => string;\n        stack: (error: {stack: any}) => any;\n    }\n    export class Expectation {\n        constructor (options: interface_686);\n        static Factory: (options: interface_689) => jasmine.Expectation | {not: jasmine.Expectation};\n        static addCoreMatchers: (matchers: interface_691) => void;\n        actual: any;\n        addExpectationResult: () => void;\n        customEqualityTesters: Array<any>;\n        isNot: any;\n        toBe: () => void;\n        toBeCloseTo: () => void;\n        toBeDefined: () => void;\n        toBeFalsy: () => void;\n        toBeGreaterThan: () => void;\n        toBeGreaterThanOrEqual: () => void;\n        toBeLessThan: () => void;\n        toBeLessThanOrEqual: () => void;\n        toBeNaN: () => void;\n        toBeNull: () => void;\n        toBeTruthy: () => void;\n        toBeUndefined: () => void;\n        toContain: () => void;\n        toEqual: () => void;\n        toHaveBeenCalled: () => void;\n        toHaveBeenCalledTimes: () => void;\n        toHaveBeenCalledWith: () => void;\n        toMatch: () => void;\n        toThrow: () => void;\n        toThrowError: () => void;\n        util: {buildFailureMessage: () => void};\n        wrapCompare: (name: any, matcherFactory: (arg0: void, arg1: void) => void) => () => void;\n    }\n    export class HtmlReporter {\n        constructor (options: interface_694);\n        initialize: () => void;\n        jasmineDone: (doneResult: interface_696) => void;\n        jasmineStarted: (options: {totalSpecsDefined: number}) => void;\n        specDone: (result: interface_699) => void;\n        specStarted: (result: any) => void;\n        suiteDone: (result: {status: string}) => void;\n        suiteStarted: (result: any) => void;\n    }\n    export class HtmlSpecFilter {\n        constructor (options: {filterString: () => void});\n        matches: (specName: string) => boolean;\n    }\n    export class JsApiReporter {\n        constructor (options: {timer: any});\n        executionTime: () => number;\n        finished: boolean;\n        jasmineDone: (runDetails: interface_696) => void;\n        jasmineStarted: (arg0: {totalSpecsDefined: number}) => void;\n        runDetails: interface_701;\n        specDone: (result: any) => void;\n        specResults: (index: number, length: string | number) => Array<any>;\n        specs: () => Array<any>;\n        started: boolean;\n        status: () => string;\n        suiteDone: (result: {id: string | number}) => void;\n        suiteResults: (index: number, length: string | number) => Array<any>;\n        suiteStarted: (result: {id: string | number}) => void;\n        suites: () => any;\n    }\n    export var MAX_PRETTY_PRINT_ARRAY_LENGTH: number;\n    export var MAX_PRETTY_PRINT_DEPTH: number;\n    export class MockDate {\n        constructor (global: Window);\n        install: (mockDate: {getTime: () => void}) => void;\n        tick: (millis: number) => void;\n        uninstall: () => void;\n    }\n    export class ObjectContaining {\n        constructor (sample: any);\n        asymmetricMatch: (other: any) => boolean;\n        jasmineToString: () => string;\n        sample: any;\n    }\n    export class Order {\n        constructor (options: {random: boolean, seed: any});\n        random: boolean;\n        seed: string;\n        sort: (items: any) => any;\n    }\n    export class QueryString {\n        constructor (options: {getWindowLocation: () => void});\n        fullStringWithNewParam: (key: string, value: any) => string;\n        getParam: (key: string) => any;\n        navigateWithNewParam: (key: string, value: boolean) => void;\n    }\n    export class QueueRunner {\n        constructor (attrs: interface_704);\n        catchException: () => boolean;\n        clearStack: (fn: () => void) => void;\n        execute: () => void;\n        fail: () => void;\n        onComplete: () => void;\n        onException: () => void;\n        queueableFns: Array<any>;\n        run: (queueableFns: interface_633, recursiveIndex: number) => void;\n        timeout: interface_706;\n        userContext: any;\n    }\n    export class ReportDispatcher {\n        constructor (methods: string[]);\n        addReporter: (reporter: any) => void;\n        jasmineDone: () => void;\n        jasmineStarted: () => void;\n        provideFallbackReporter: (reporter: any) => void;\n        specDone: () => void;\n        specStarted: () => void;\n        suiteDone: () => void;\n        suiteStarted: () => void;\n    }\n    export class ResultsNode {\n        constructor (result: any, type: string, parent: any);\n        addChild: (result: any, type: string) => void;\n        children: Array<any>;\n        last: () => any;\n        parent: any;\n        result: any;\n        type: string;\n    }\n    export class Spec {\n        constructor (attrs: interface_715);\n        static isPendingSpecException: (e: {toString: () => void}) => boolean;\n        static pendingSpecExceptionMessage: string;\n        addExpectationResult: (passed: boolean, data: interface_716, isError: boolean) => void;\n        beforeAndAfterFns: () => {afters: Array<any>, befores: Array<any>};\n        catchingExceptions: () => boolean;\n        description: string;\n        disable: () => void;\n        execute: (onComplete: () => void, enabled: boolean) => void;\n        expect: (actual: any) => any;\n        expectationFactory: any;\n        expectationResultFactory: () => void;\n        getFullName: () => any;\n        getResult: () => {status: string};\n        getSpecName: () => string;\n        id: any;\n        isExecutable: () => boolean;\n        onException: (e: {toString: () => void}) => void;\n        onStart: () => void;\n        pend: (message: any) => void;\n        queueRunnerFactory: () => void;\n        queueableFn: {fn: any};\n        result: interface_718;\n        resultCallback: () => void;\n        status: (enabled: boolean) => string;\n        throwOnExpectationFailure: boolean;\n        userContext: () => any;\n    }\n    export class SpyRegistry {\n        constructor (options: {currentSpies: () => any});\n        allowRespy: (allow: any) => void;\n        clearSpies: () => void;\n        spyOn: (obj: interface_628, methodName: string) => interface_490;\n    }\n    export class SpyStrategy {\n        constructor (options: interface_720);\n        callFake: (originalFn: string | number | ((arg0: void, arg1: void, arg2: void, arg3: void, arg4: void) => any)) => any;\n        callThrough: () => any;\n        exec: () => any;\n        identity: () => string;\n        returnValue: (value: any) => any;\n        returnValues: () => any;\n        stub: (fn: any) => any;\n        throwError: (something: Error | string) => any;\n    }\n    export class StringMatching {\n        constructor (expected: string);\n        asymmetricMatch: (other: any) => any;\n        jasmineToString: () => string;\n        regexp: RegExp;\n    }\n    export class Suite {\n        constructor (attrs: interface_731);\n        addChild: (child: jasmine.Suite | jasmine.Spec | {id: void, isFocused: boolean}) => void;\n        addExpectationResult: () => void;\n        afterAll: (fn: {fn: any, timeout: () => number}) => void;\n        afterAllFns: Array<any>;\n        afterEach: (fn: {fn: any, timeout: () => number}) => void;\n        afterFns: Array<any>;\n        beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n        beforeAllFns: Array<any>;\n        beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n        beforeFns: Array<any>;\n        canBeReentered: () => boolean;\n        children: Array<any>;\n        clonedSharedUserContext: () => any;\n        description: string;\n        disable: () => void;\n        disabled: boolean;\n        env: jasmine.Env;\n        expect: (actual: any) => jasmine.Expectation | {not: jasmine.Expectation};\n        expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n        expectationResultFactory: (attrs: interface_722) => interface_724;\n        getFullName: () => string;\n        getResult: () => interface_733;\n        id: string;\n        isExecutable: () => boolean;\n        onException: () => void;\n        parentSuite: any;\n        pend: (message: any) => void;\n        result: interface_735;\n        sharedContext: any;\n        sharedUserContext: () => any;\n        status: () => string;\n        throwOnExpectationFailure: boolean;\n    }\n    export class Timer {\n        constructor (options: {now: any});\n        elapsed: () => number;\n        start: () => void;\n    }\n    export class TreeProcessor {\n        constructor (attrs: interface_743);\n        execute: (done: any) => void;\n        processTree: () => interface_611;\n    }\n    export function addCustomEqualityTester(tester: any): void;\n    export function addMatchers(matchers: any): any;\n    export function any(clazz: any): jasmine.Any;\n    export function anything(): jasmine.Anything;\n    export function arrayContaining(sample: any): jasmine.ArrayContaining;\n    export function buildExpectationResult(options: interface_745): interface_709;\n    export function clock(): jasmine.Clock;\n    export function createSpy(name: string | number, originalFn: any): interface_608;\n    export function createSpyObj(baseName: string | interface_640, methodNames: string | interface_640): interface_644;\n    export var currentEnv_: jasmine.Env;\n    export module errors {\n        export var ExpectationFailed: ExpectationFailedConstructor;\n    }\n    export function fnNameFor(func: {name: any, test: void, toString: () => void}): string;\n    export function formatErrorMsg(domain: string | number, usage: string | number): (msg: string | number) => string;\n    export function getEnv(options: {global: any}): jasmine.Env;\n    export function getGlobal(): Window;\n    export function isA_(typeName: string, value: interface_747 | string): boolean;\n    export function isArray_(value: interface_747 | string): boolean;\n    export function isDomNode(obj: interface_749): boolean;\n    export function isNumber_(value: any): boolean;\n    export function isSpy(putativeSpy: interface_751): boolean;\n    export function isString_(value: any): boolean;\n    export module matchers {\n        export function toBe(): interface_754;\n        export function toBeCloseTo(): interface_755;\n        export function toBeDefined(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeFalsy(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeGreaterThan(): interface_757;\n        export function toBeGreaterThanOrEqual(): interface_759;\n        export function toBeLessThan(): interface_761;\n        export function toBeLessThanOrEqual(): interface_762;\n        export function toBeNaN(): interface_764;\n        export function toBeNull(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeTruthy(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeUndefined(): {compare: (actual: any) => {pass: boolean}};\n        export function toContain(util: interface_766, customEqualityTesters: Array<any>): interface_768;\n        export function toEqual(util: interface_769, customEqualityTesters: Array<any>): interface_771;\n        export function toHaveBeenCalled(): interface_772;\n        export function toHaveBeenCalledTimes(): interface_774;\n        export function toHaveBeenCalledWith(util: interface_776, customEqualityTesters: any): interface_777;\n        export function toMatch(): interface_779;\n        export function toThrow(util: {equals: (arg0: void, arg1: void) => void}): interface_780;\n        export function toThrowError(): interface_782;\n    }\n    export module matchersUtil {\n        export function buildFailureMessage(): string;\n        export function contains(haystack: interface_398, needle: string | interface_413, customTesters: Array<function_784>): boolean;\n        export function equals(a: string | interface_413, b: string | interface_413, customTesters: Array<function_784>): boolean;\n    }\n    export function objectContaining(sample: any): jasmine.ObjectContaining;\n    export function pp(value: number | Window | interface_607): any;\n    export function stringMatching(expected: string): jasmine.StringMatching;\n    export function unimplementedMethod_(): void;\n    export module util {\n        export function argsToArray(args: any[]): Array<any>;\n        export function arrayContains(array: any[], search: interface_747): boolean;\n        export function clone(obj: {slice: () => void}): any;\n        export function htmlEscape(str: {replace: (arg0: void, arg1: void) => void}): {replace: (arg0: void, arg1: void) => void};\n        export function inherit(childClass: {prototype: any}, parentClass: {prototype: any}): void;\n        export function isUndefined(obj: string | interface_786): boolean;\n    }\n    export var version: string;\n}\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":true,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Order","newFunction":"function Order(options) {\r\n        this.random = 'random' in options ? options.random : true;\r\n        var seed = this.seed = options.seed || generateSeed();\r\n        this.sort = this.random ? randomOrder : naturalOrder;\r\n\r\n        function naturalOrder(items) {\r\n            return items;\r\n        }\r\n\r\n        function randomOrder(items) {\r\n            var copy = items.slice();\r\n            copy.sort(function(a, b) {\r\n                return jenkinsHash(seed + a.id) - jenkinsHash(seed + b.id);\r\n            });\r\n            return copy;\r\n        }\r\n\r\n        function generateSeed() {\r\n            return String(Math.random()).slice(-5);\r\n        }\r\n\r\n        // Bob Jenkins One-at-a-Time Hash algorithm is a non-cryptographic hash function\r\n        // used to get a different output when the key changes slighly.\r\n        // We use your return to sort the children randomly in a consistent way when\r\n        // used in conjunction with a seed\r\n\r\n        function jenkinsHash(key) {\r\n            var hash, i;\r\n            for(hash = i = 0; i < key.length; ++i) {\r\n                hash += key.charCodeAt(i);\r\n                hash += (hash << 10);\r\n                hash ^= (hash >> 6);\r\n            }\r\n            hash += (hash << 3);\r\n            hash ^= (hash >> 11);\r\n            hash += (hash << 15);\r\n            return hash;\r\n        }\r\n\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window","oldFunction":null,"oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine","key":"Order","newType":"class Order1 {\n    constructor (options: {random: boolean, seed: any});\n    random: boolean;\n    seed: string;\n    sort: (items: any) => any;\n}\n","isAny":false,"isClass":false,"containerType":"declare module jasmine {\n    export class Any {\n        constructor (expectedObject: any);\n        asymmetricMatch: (other: any) => boolean;\n        expectedObject: any;\n        jasmineToString: () => string;\n    }\n    export class Anything {\n        constructor ();\n        asymmetricMatch: (other: any) => boolean;\n        jasmineToString: () => string;\n    }\n    export class ArrayContaining {\n        constructor (sample: any);\n        asymmetricMatch: (other: interface_619) => boolean;\n        jasmineToString: () => string;\n        sample: any;\n    }\n    export class CallTracker {\n        constructor ();\n        all: () => Array<interface_679>;\n        allArgs: () => Array<any>;\n        any: () => boolean;\n        argsFor: (index: number) => Array<any>;\n        count: () => number;\n        first: () => interface_679;\n        mostRecent: () => interface_679;\n        reset: () => void;\n        saveArgumentsByValue: () => void;\n        track: (context: {args: any[]}) => void;\n    }\n    export class Clock {\n        constructor (global: Window | interface_470, delayedFunctionSchedulerFactory: () => jasmine.DelayedFunctionScheduler, mockDate: jasmine.MockDate);\n        clearInterval: (id: Window) => any;\n        clearTimeout: (id: Window) => any;\n        install: () => jasmine.Clock;\n        mockDate: (initialDate: {getTime: () => void}) => void;\n        setInterval: (fn: any, delay: any, params: any) => any;\n        setTimeout: (fn: any, delay: any, params: any) => any;\n        tick: (millis: any) => void;\n        uninstall: () => void;\n        withMock: (closure: () => void) => void;\n    }\n    export var DEFAULT_TIMEOUT_INTERVAL: number;\n    export class DelayedFunctionScheduler {\n        constructor ();\n        removeFunctionWithId: (timeoutKey: any) => void;\n        scheduleFunction: (funcToCall: string | (() => any), millis: number, params: any, recurring: any, timeoutKey: number, newCurrentTime: string) => number;\n        tick: (millis: number, tickDate: (arg0: void) => void) => void;\n    }\n    export class Env {\n        constructor (options: {global: any});\n        addCustomEqualityTester: (tester: any) => void;\n        addMatchers: (matchersToAdd: any) => void;\n        addReporter: (reporterToAdd: any) => void;\n        afterAll: (afterAllFunction: any, timeout: any) => void;\n        afterEach: (afterEachFunction: any, timeout: any) => void;\n        allowRespy: (allow: any) => void;\n        beforeAll: (beforeAllFunction: any, timeout: any) => void;\n        beforeEach: (beforeEachFunction: any, timeout: any) => void;\n        catchExceptions: (value: any) => boolean;\n        catchingExceptions: () => boolean;\n        clock: jasmine.Clock;\n        describe: (description: any, specDefinitions: {call: (arg0: void) => void, length: number}) => jasmine.Suite;\n        execute: (runnablesToRun: string[]) => void;\n        expect: (actual: any) => any;\n        fail: (error: {message: any}) => void;\n        fdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite | {id: any, isFocused: boolean};\n        fit: (description: any, fn: any, timeout: any) => {disabled: boolean} | jasmine.Spec;\n        it: (description: string, fn: () => void, timeout: any) => {disabled: boolean} | jasmine.Spec;\n        pending: (message: string) => void;\n        provideFallbackReporter: (reporterToAdd: any) => void;\n        randomTests: () => boolean;\n        randomizeTests: (value: any) => void;\n        seed: (value: any) => any;\n        specFilter: (spec: jasmine.Spec) => boolean;\n        spyOn: () => interface_490;\n        throwOnExpectationFailure: (value: any) => void;\n        throwingExpectationFailures: () => boolean;\n        topSuite: () => jasmine.Suite;\n        xdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite;\n        xit: () => {pend: (arg0: void) => void};\n    }\n    export class ExceptionFormatter {\n        constructor ();\n        message: (error: interface_682) => string;\n        stack: (error: {stack: any}) => any;\n    }\n    export class Expectation {\n        constructor (options: interface_686);\n        static Factory: (options: interface_689) => jasmine.Expectation | {not: jasmine.Expectation};\n        static addCoreMatchers: (matchers: interface_691) => void;\n        actual: any;\n        addExpectationResult: () => void;\n        customEqualityTesters: Array<any>;\n        isNot: any;\n        toBe: () => void;\n        toBeCloseTo: () => void;\n        toBeDefined: () => void;\n        toBeFalsy: () => void;\n        toBeGreaterThan: () => void;\n        toBeGreaterThanOrEqual: () => void;\n        toBeLessThan: () => void;\n        toBeLessThanOrEqual: () => void;\n        toBeNaN: () => void;\n        toBeNull: () => void;\n        toBeTruthy: () => void;\n        toBeUndefined: () => void;\n        toContain: () => void;\n        toEqual: () => void;\n        toHaveBeenCalled: () => void;\n        toHaveBeenCalledTimes: () => void;\n        toHaveBeenCalledWith: () => void;\n        toMatch: () => void;\n        toThrow: () => void;\n        toThrowError: () => void;\n        util: {buildFailureMessage: () => void};\n        wrapCompare: (name: any, matcherFactory: (arg0: void, arg1: void) => void) => () => void;\n    }\n    export class HtmlReporter {\n        constructor (options: interface_694);\n        initialize: () => void;\n        jasmineDone: (doneResult: interface_696) => void;\n        jasmineStarted: (options: {totalSpecsDefined: number}) => void;\n        specDone: (result: interface_699) => void;\n        specStarted: (result: any) => void;\n        suiteDone: (result: {status: string}) => void;\n        suiteStarted: (result: any) => void;\n    }\n    export class HtmlSpecFilter {\n        constructor (options: {filterString: () => void});\n        matches: (specName: string) => boolean;\n    }\n    export class JsApiReporter {\n        constructor (options: {timer: any});\n        executionTime: () => number;\n        finished: boolean;\n        jasmineDone: (runDetails: interface_696) => void;\n        jasmineStarted: (arg0: {totalSpecsDefined: number}) => void;\n        runDetails: interface_701;\n        specDone: (result: any) => void;\n        specResults: (index: number, length: string | number) => Array<any>;\n        specs: () => Array<any>;\n        started: boolean;\n        status: () => string;\n        suiteDone: (result: {id: string | number}) => void;\n        suiteResults: (index: number, length: string | number) => Array<any>;\n        suiteStarted: (result: {id: string | number}) => void;\n        suites: () => any;\n    }\n    export var MAX_PRETTY_PRINT_ARRAY_LENGTH: number;\n    export var MAX_PRETTY_PRINT_DEPTH: number;\n    export class MockDate {\n        constructor (global: Window);\n        install: (mockDate: {getTime: () => void}) => void;\n        tick: (millis: number) => void;\n        uninstall: () => void;\n    }\n    export class ObjectContaining {\n        constructor (sample: any);\n        asymmetricMatch: (other: any) => boolean;\n        jasmineToString: () => string;\n        sample: any;\n    }\n    export class Order {\n        constructor (options: {random: boolean, seed: any});\n        random: boolean;\n        seed: string;\n        sort: (items: any) => any;\n    }\n    export class QueryString {\n        constructor (options: {getWindowLocation: () => void});\n        fullStringWithNewParam: (key: string, value: any) => string;\n        getParam: (key: string) => any;\n        navigateWithNewParam: (key: string, value: boolean) => void;\n    }\n    export class QueueRunner {\n        constructor (attrs: interface_704);\n        catchException: () => boolean;\n        clearStack: (fn: () => void) => void;\n        execute: () => void;\n        fail: () => void;\n        onComplete: () => void;\n        onException: () => void;\n        queueableFns: Array<any>;\n        run: (queueableFns: interface_633, recursiveIndex: number) => void;\n        timeout: interface_706;\n        userContext: any;\n    }\n    export class ReportDispatcher {\n        constructor (methods: string[]);\n        addReporter: (reporter: any) => void;\n        jasmineDone: () => void;\n        jasmineStarted: () => void;\n        provideFallbackReporter: (reporter: any) => void;\n        specDone: () => void;\n        specStarted: () => void;\n        suiteDone: () => void;\n        suiteStarted: () => void;\n    }\n    export class ResultsNode {\n        constructor (result: any, type: string, parent: any);\n        addChild: (result: any, type: string) => void;\n        children: Array<any>;\n        last: () => any;\n        parent: any;\n        result: any;\n        type: string;\n    }\n    export class Spec {\n        constructor (attrs: interface_715);\n        static isPendingSpecException: (e: {toString: () => void}) => boolean;\n        static pendingSpecExceptionMessage: string;\n        addExpectationResult: (passed: boolean, data: interface_716, isError: boolean) => void;\n        beforeAndAfterFns: () => {afters: Array<any>, befores: Array<any>};\n        catchingExceptions: () => boolean;\n        description: string;\n        disable: () => void;\n        execute: (onComplete: () => void, enabled: boolean) => void;\n        expect: (actual: any) => any;\n        expectationFactory: any;\n        expectationResultFactory: () => void;\n        getFullName: () => any;\n        getResult: () => {status: string};\n        getSpecName: () => string;\n        id: any;\n        isExecutable: () => boolean;\n        onException: (e: {toString: () => void}) => void;\n        onStart: () => void;\n        pend: (message: any) => void;\n        queueRunnerFactory: () => void;\n        queueableFn: {fn: any};\n        result: interface_718;\n        resultCallback: () => void;\n        status: (enabled: boolean) => string;\n        throwOnExpectationFailure: boolean;\n        userContext: () => any;\n    }\n    export class SpyRegistry {\n        constructor (options: {currentSpies: () => any});\n        allowRespy: (allow: any) => void;\n        clearSpies: () => void;\n        spyOn: (obj: interface_628, methodName: string) => interface_490;\n    }\n    export class SpyStrategy {\n        constructor (options: interface_720);\n        callFake: (originalFn: string | number | ((arg0: void, arg1: void, arg2: void, arg3: void, arg4: void) => any)) => any;\n        callThrough: () => any;\n        exec: () => any;\n        identity: () => string;\n        returnValue: (value: any) => any;\n        returnValues: () => any;\n        stub: (fn: any) => any;\n        throwError: (something: Error | string) => any;\n    }\n    export class StringMatching {\n        constructor (expected: string);\n        asymmetricMatch: (other: any) => any;\n        jasmineToString: () => string;\n        regexp: RegExp;\n    }\n    export class Suite {\n        constructor (attrs: interface_731);\n        addChild: (child: jasmine.Suite | jasmine.Spec | {id: void, isFocused: boolean}) => void;\n        addExpectationResult: () => void;\n        afterAll: (fn: {fn: any, timeout: () => number}) => void;\n        afterAllFns: Array<any>;\n        afterEach: (fn: {fn: any, timeout: () => number}) => void;\n        afterFns: Array<any>;\n        beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n        beforeAllFns: Array<any>;\n        beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n        beforeFns: Array<any>;\n        canBeReentered: () => boolean;\n        children: Array<any>;\n        clonedSharedUserContext: () => any;\n        description: string;\n        disable: () => void;\n        disabled: boolean;\n        env: jasmine.Env;\n        expect: (actual: any) => jasmine.Expectation | {not: jasmine.Expectation};\n        expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n        expectationResultFactory: (attrs: interface_722) => interface_724;\n        getFullName: () => string;\n        getResult: () => interface_733;\n        id: string;\n        isExecutable: () => boolean;\n        onException: () => void;\n        parentSuite: any;\n        pend: (message: any) => void;\n        result: interface_735;\n        sharedContext: any;\n        sharedUserContext: () => any;\n        status: () => string;\n        throwOnExpectationFailure: boolean;\n    }\n    export class Timer {\n        constructor (options: {now: any});\n        elapsed: () => number;\n        start: () => void;\n    }\n    export class TreeProcessor {\n        constructor (attrs: interface_743);\n        execute: (done: any) => void;\n        processTree: () => interface_611;\n    }\n    export function addCustomEqualityTester(tester: any): void;\n    export function addMatchers(matchers: any): any;\n    export function any(clazz: any): jasmine.Any;\n    export function anything(): jasmine.Anything;\n    export function arrayContaining(sample: any): jasmine.ArrayContaining;\n    export function buildExpectationResult(options: interface_745): interface_709;\n    export function clock(): jasmine.Clock;\n    export function createSpy(name: string | number, originalFn: any): interface_608;\n    export function createSpyObj(baseName: string | interface_640, methodNames: string | interface_640): interface_644;\n    export var currentEnv_: jasmine.Env;\n    export module errors {\n        export var ExpectationFailed: ExpectationFailedConstructor;\n    }\n    export function fnNameFor(func: {name: any, test: void, toString: () => void}): string;\n    export function formatErrorMsg(domain: string | number, usage: string | number): (msg: string | number) => string;\n    export function getEnv(options: {global: any}): jasmine.Env;\n    export function getGlobal(): Window;\n    export function isA_(typeName: string, value: interface_747 | string): boolean;\n    export function isArray_(value: interface_747 | string): boolean;\n    export function isDomNode(obj: interface_749): boolean;\n    export function isNumber_(value: any): boolean;\n    export function isSpy(putativeSpy: interface_751): boolean;\n    export function isString_(value: any): boolean;\n    export module matchers {\n        export function toBe(): interface_754;\n        export function toBeCloseTo(): interface_755;\n        export function toBeDefined(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeFalsy(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeGreaterThan(): interface_757;\n        export function toBeGreaterThanOrEqual(): interface_759;\n        export function toBeLessThan(): interface_761;\n        export function toBeLessThanOrEqual(): interface_762;\n        export function toBeNaN(): interface_764;\n        export function toBeNull(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeTruthy(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeUndefined(): {compare: (actual: any) => {pass: boolean}};\n        export function toContain(util: interface_766, customEqualityTesters: Array<any>): interface_768;\n        export function toEqual(util: interface_769, customEqualityTesters: Array<any>): interface_771;\n        export function toHaveBeenCalled(): interface_772;\n        export function toHaveBeenCalledTimes(): interface_774;\n        export function toHaveBeenCalledWith(util: interface_776, customEqualityTesters: any): interface_777;\n        export function toMatch(): interface_779;\n        export function toThrow(util: {equals: (arg0: void, arg1: void) => void}): interface_780;\n        export function toThrowError(): interface_782;\n    }\n    export module matchersUtil {\n        export function buildFailureMessage(): string;\n        export function contains(haystack: interface_398, needle: string | interface_413, customTesters: Array<function_784>): boolean;\n        export function equals(a: string | interface_413, b: string | interface_413, customTesters: Array<function_784>): boolean;\n    }\n    export function objectContaining(sample: any): jasmine.ObjectContaining;\n    export function pp(value: number | Window | interface_607): any;\n    export function stringMatching(expected: string): jasmine.StringMatching;\n    export function unimplementedMethod_(): void;\n    export module util {\n        export function argsToArray(args: any[]): Array<any>;\n        export function arrayContains(array: any[], search: interface_747): boolean;\n        export function clone(obj: {slice: () => void}): any;\n        export function htmlEscape(str: {replace: (arg0: void, arg1: void) => void}): {replace: (arg0: void, arg1: void) => void};\n        export function inherit(childClass: {prototype: any}, parentClass: {prototype: any}): void;\n        export function isUndefined(obj: string | interface_786): boolean;\n    }\n    export var version: string;\n}\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":true,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window","newFunction":null,"newJSDoc":null,"oldInclosingFunctionPath":"window","oldFunction":null,"oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine","key":"errors","newType":"declare module errors {\n    export var ExpectationFailed: ExpectationFailedConstructor;\n}\n","isAny":false,"isClass":false,"containerType":"declare module jasmine {\n    export class Any {\n        constructor (expectedObject: any);\n        asymmetricMatch: (other: any) => boolean;\n        expectedObject: any;\n        jasmineToString: () => string;\n    }\n    export class Anything {\n        constructor ();\n        asymmetricMatch: (other: any) => boolean;\n        jasmineToString: () => string;\n    }\n    export class ArrayContaining {\n        constructor (sample: any);\n        asymmetricMatch: (other: interface_619) => boolean;\n        jasmineToString: () => string;\n        sample: any;\n    }\n    export class CallTracker {\n        constructor ();\n        all: () => Array<interface_679>;\n        allArgs: () => Array<any>;\n        any: () => boolean;\n        argsFor: (index: number) => Array<any>;\n        count: () => number;\n        first: () => interface_679;\n        mostRecent: () => interface_679;\n        reset: () => void;\n        saveArgumentsByValue: () => void;\n        track: (context: {args: any[]}) => void;\n    }\n    export class Clock {\n        constructor (global: Window | interface_470, delayedFunctionSchedulerFactory: () => jasmine.DelayedFunctionScheduler, mockDate: jasmine.MockDate);\n        clearInterval: (id: Window) => any;\n        clearTimeout: (id: Window) => any;\n        install: () => jasmine.Clock;\n        mockDate: (initialDate: {getTime: () => void}) => void;\n        setInterval: (fn: any, delay: any, params: any) => any;\n        setTimeout: (fn: any, delay: any, params: any) => any;\n        tick: (millis: any) => void;\n        uninstall: () => void;\n        withMock: (closure: () => void) => void;\n    }\n    export var DEFAULT_TIMEOUT_INTERVAL: number;\n    export class DelayedFunctionScheduler {\n        constructor ();\n        removeFunctionWithId: (timeoutKey: any) => void;\n        scheduleFunction: (funcToCall: string | (() => any), millis: number, params: any, recurring: any, timeoutKey: number, newCurrentTime: string) => number;\n        tick: (millis: number, tickDate: (arg0: void) => void) => void;\n    }\n    export class Env {\n        constructor (options: {global: any});\n        addCustomEqualityTester: (tester: any) => void;\n        addMatchers: (matchersToAdd: any) => void;\n        addReporter: (reporterToAdd: any) => void;\n        afterAll: (afterAllFunction: any, timeout: any) => void;\n        afterEach: (afterEachFunction: any, timeout: any) => void;\n        allowRespy: (allow: any) => void;\n        beforeAll: (beforeAllFunction: any, timeout: any) => void;\n        beforeEach: (beforeEachFunction: any, timeout: any) => void;\n        catchExceptions: (value: any) => boolean;\n        catchingExceptions: () => boolean;\n        clock: jasmine.Clock;\n        describe: (description: any, specDefinitions: {call: (arg0: void) => void, length: number}) => jasmine.Suite;\n        execute: (runnablesToRun: string[]) => void;\n        expect: (actual: any) => any;\n        fail: (error: {message: any}) => void;\n        fdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite | {id: any, isFocused: boolean};\n        fit: (description: any, fn: any, timeout: any) => {disabled: boolean} | jasmine.Spec;\n        it: (description: string, fn: () => void, timeout: any) => {disabled: boolean} | jasmine.Spec;\n        pending: (message: string) => void;\n        provideFallbackReporter: (reporterToAdd: any) => void;\n        randomTests: () => boolean;\n        randomizeTests: (value: any) => void;\n        seed: (value: any) => any;\n        specFilter: (spec: jasmine.Spec) => boolean;\n        spyOn: () => interface_490;\n        throwOnExpectationFailure: (value: any) => void;\n        throwingExpectationFailures: () => boolean;\n        topSuite: () => jasmine.Suite;\n        xdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite;\n        xit: () => {pend: (arg0: void) => void};\n    }\n    export class ExceptionFormatter {\n        constructor ();\n        message: (error: interface_682) => string;\n        stack: (error: {stack: any}) => any;\n    }\n    export class Expectation {\n        constructor (options: interface_686);\n        static Factory: (options: interface_689) => jasmine.Expectation | {not: jasmine.Expectation};\n        static addCoreMatchers: (matchers: interface_691) => void;\n        actual: any;\n        addExpectationResult: () => void;\n        customEqualityTesters: Array<any>;\n        isNot: any;\n        toBe: () => void;\n        toBeCloseTo: () => void;\n        toBeDefined: () => void;\n        toBeFalsy: () => void;\n        toBeGreaterThan: () => void;\n        toBeGreaterThanOrEqual: () => void;\n        toBeLessThan: () => void;\n        toBeLessThanOrEqual: () => void;\n        toBeNaN: () => void;\n        toBeNull: () => void;\n        toBeTruthy: () => void;\n        toBeUndefined: () => void;\n        toContain: () => void;\n        toEqual: () => void;\n        toHaveBeenCalled: () => void;\n        toHaveBeenCalledTimes: () => void;\n        toHaveBeenCalledWith: () => void;\n        toMatch: () => void;\n        toThrow: () => void;\n        toThrowError: () => void;\n        util: {buildFailureMessage: () => void};\n        wrapCompare: (name: any, matcherFactory: (arg0: void, arg1: void) => void) => () => void;\n    }\n    export class HtmlReporter {\n        constructor (options: interface_694);\n        initialize: () => void;\n        jasmineDone: (doneResult: interface_696) => void;\n        jasmineStarted: (options: {totalSpecsDefined: number}) => void;\n        specDone: (result: interface_699) => void;\n        specStarted: (result: any) => void;\n        suiteDone: (result: {status: string}) => void;\n        suiteStarted: (result: any) => void;\n    }\n    export class HtmlSpecFilter {\n        constructor (options: {filterString: () => void});\n        matches: (specName: string) => boolean;\n    }\n    export class JsApiReporter {\n        constructor (options: {timer: any});\n        executionTime: () => number;\n        finished: boolean;\n        jasmineDone: (runDetails: interface_696) => void;\n        jasmineStarted: (arg0: {totalSpecsDefined: number}) => void;\n        runDetails: interface_701;\n        specDone: (result: any) => void;\n        specResults: (index: number, length: string | number) => Array<any>;\n        specs: () => Array<any>;\n        started: boolean;\n        status: () => string;\n        suiteDone: (result: {id: string | number}) => void;\n        suiteResults: (index: number, length: string | number) => Array<any>;\n        suiteStarted: (result: {id: string | number}) => void;\n        suites: () => any;\n    }\n    export var MAX_PRETTY_PRINT_ARRAY_LENGTH: number;\n    export var MAX_PRETTY_PRINT_DEPTH: number;\n    export class MockDate {\n        constructor (global: Window);\n        install: (mockDate: {getTime: () => void}) => void;\n        tick: (millis: number) => void;\n        uninstall: () => void;\n    }\n    export class ObjectContaining {\n        constructor (sample: any);\n        asymmetricMatch: (other: any) => boolean;\n        jasmineToString: () => string;\n        sample: any;\n    }\n    export class Order {\n        constructor (options: {random: boolean, seed: any});\n        random: boolean;\n        seed: string;\n        sort: (items: any) => any;\n    }\n    export class QueryString {\n        constructor (options: {getWindowLocation: () => void});\n        fullStringWithNewParam: (key: string, value: any) => string;\n        getParam: (key: string) => any;\n        navigateWithNewParam: (key: string, value: boolean) => void;\n    }\n    export class QueueRunner {\n        constructor (attrs: interface_704);\n        catchException: () => boolean;\n        clearStack: (fn: () => void) => void;\n        execute: () => void;\n        fail: () => void;\n        onComplete: () => void;\n        onException: () => void;\n        queueableFns: Array<any>;\n        run: (queueableFns: interface_633, recursiveIndex: number) => void;\n        timeout: interface_706;\n        userContext: any;\n    }\n    export class ReportDispatcher {\n        constructor (methods: string[]);\n        addReporter: (reporter: any) => void;\n        jasmineDone: () => void;\n        jasmineStarted: () => void;\n        provideFallbackReporter: (reporter: any) => void;\n        specDone: () => void;\n        specStarted: () => void;\n        suiteDone: () => void;\n        suiteStarted: () => void;\n    }\n    export class ResultsNode {\n        constructor (result: any, type: string, parent: any);\n        addChild: (result: any, type: string) => void;\n        children: Array<any>;\n        last: () => any;\n        parent: any;\n        result: any;\n        type: string;\n    }\n    export class Spec {\n        constructor (attrs: interface_715);\n        static isPendingSpecException: (e: {toString: () => void}) => boolean;\n        static pendingSpecExceptionMessage: string;\n        addExpectationResult: (passed: boolean, data: interface_716, isError: boolean) => void;\n        beforeAndAfterFns: () => {afters: Array<any>, befores: Array<any>};\n        catchingExceptions: () => boolean;\n        description: string;\n        disable: () => void;\n        execute: (onComplete: () => void, enabled: boolean) => void;\n        expect: (actual: any) => any;\n        expectationFactory: any;\n        expectationResultFactory: () => void;\n        getFullName: () => any;\n        getResult: () => {status: string};\n        getSpecName: () => string;\n        id: any;\n        isExecutable: () => boolean;\n        onException: (e: {toString: () => void}) => void;\n        onStart: () => void;\n        pend: (message: any) => void;\n        queueRunnerFactory: () => void;\n        queueableFn: {fn: any};\n        result: interface_718;\n        resultCallback: () => void;\n        status: (enabled: boolean) => string;\n        throwOnExpectationFailure: boolean;\n        userContext: () => any;\n    }\n    export class SpyRegistry {\n        constructor (options: {currentSpies: () => any});\n        allowRespy: (allow: any) => void;\n        clearSpies: () => void;\n        spyOn: (obj: interface_628, methodName: string) => interface_490;\n    }\n    export class SpyStrategy {\n        constructor (options: interface_720);\n        callFake: (originalFn: string | number | ((arg0: void, arg1: void, arg2: void, arg3: void, arg4: void) => any)) => any;\n        callThrough: () => any;\n        exec: () => any;\n        identity: () => string;\n        returnValue: (value: any) => any;\n        returnValues: () => any;\n        stub: (fn: any) => any;\n        throwError: (something: Error | string) => any;\n    }\n    export class StringMatching {\n        constructor (expected: string);\n        asymmetricMatch: (other: any) => any;\n        jasmineToString: () => string;\n        regexp: RegExp;\n    }\n    export class Suite {\n        constructor (attrs: interface_731);\n        addChild: (child: jasmine.Suite | jasmine.Spec | {id: void, isFocused: boolean}) => void;\n        addExpectationResult: () => void;\n        afterAll: (fn: {fn: any, timeout: () => number}) => void;\n        afterAllFns: Array<any>;\n        afterEach: (fn: {fn: any, timeout: () => number}) => void;\n        afterFns: Array<any>;\n        beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n        beforeAllFns: Array<any>;\n        beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n        beforeFns: Array<any>;\n        canBeReentered: () => boolean;\n        children: Array<any>;\n        clonedSharedUserContext: () => any;\n        description: string;\n        disable: () => void;\n        disabled: boolean;\n        env: jasmine.Env;\n        expect: (actual: any) => jasmine.Expectation | {not: jasmine.Expectation};\n        expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n        expectationResultFactory: (attrs: interface_722) => interface_724;\n        getFullName: () => string;\n        getResult: () => interface_733;\n        id: string;\n        isExecutable: () => boolean;\n        onException: () => void;\n        parentSuite: any;\n        pend: (message: any) => void;\n        result: interface_735;\n        sharedContext: any;\n        sharedUserContext: () => any;\n        status: () => string;\n        throwOnExpectationFailure: boolean;\n    }\n    export class Timer {\n        constructor (options: {now: any});\n        elapsed: () => number;\n        start: () => void;\n    }\n    export class TreeProcessor {\n        constructor (attrs: interface_743);\n        execute: (done: any) => void;\n        processTree: () => interface_611;\n    }\n    export function addCustomEqualityTester(tester: any): void;\n    export function addMatchers(matchers: any): any;\n    export function any(clazz: any): jasmine.Any;\n    export function anything(): jasmine.Anything;\n    export function arrayContaining(sample: any): jasmine.ArrayContaining;\n    export function buildExpectationResult(options: interface_745): interface_709;\n    export function clock(): jasmine.Clock;\n    export function createSpy(name: string | number, originalFn: any): interface_608;\n    export function createSpyObj(baseName: string | interface_640, methodNames: string | interface_640): interface_644;\n    export var currentEnv_: jasmine.Env;\n    export module errors {\n        export var ExpectationFailed: ExpectationFailedConstructor;\n    }\n    export function fnNameFor(func: {name: any, test: void, toString: () => void}): string;\n    export function formatErrorMsg(domain: string | number, usage: string | number): (msg: string | number) => string;\n    export function getEnv(options: {global: any}): jasmine.Env;\n    export function getGlobal(): Window;\n    export function isA_(typeName: string, value: interface_747 | string): boolean;\n    export function isArray_(value: interface_747 | string): boolean;\n    export function isDomNode(obj: interface_749): boolean;\n    export function isNumber_(value: any): boolean;\n    export function isSpy(putativeSpy: interface_751): boolean;\n    export function isString_(value: any): boolean;\n    export module matchers {\n        export function toBe(): interface_754;\n        export function toBeCloseTo(): interface_755;\n        export function toBeDefined(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeFalsy(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeGreaterThan(): interface_757;\n        export function toBeGreaterThanOrEqual(): interface_759;\n        export function toBeLessThan(): interface_761;\n        export function toBeLessThanOrEqual(): interface_762;\n        export function toBeNaN(): interface_764;\n        export function toBeNull(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeTruthy(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeUndefined(): {compare: (actual: any) => {pass: boolean}};\n        export function toContain(util: interface_766, customEqualityTesters: Array<any>): interface_768;\n        export function toEqual(util: interface_769, customEqualityTesters: Array<any>): interface_771;\n        export function toHaveBeenCalled(): interface_772;\n        export function toHaveBeenCalledTimes(): interface_774;\n        export function toHaveBeenCalledWith(util: interface_776, customEqualityTesters: any): interface_777;\n        export function toMatch(): interface_779;\n        export function toThrow(util: {equals: (arg0: void, arg1: void) => void}): interface_780;\n        export function toThrowError(): interface_782;\n    }\n    export module matchersUtil {\n        export function buildFailureMessage(): string;\n        export function contains(haystack: interface_398, needle: string | interface_413, customTesters: Array<function_784>): boolean;\n        export function equals(a: string | interface_413, b: string | interface_413, customTesters: Array<function_784>): boolean;\n    }\n    export function objectContaining(sample: any): jasmine.ObjectContaining;\n    export function pp(value: number | Window | interface_607): any;\n    export function stringMatching(expected: string): jasmine.StringMatching;\n    export function unimplementedMethod_(): void;\n    export module util {\n        export function argsToArray(args: any[]): Array<any>;\n        export function arrayContains(array: any[], search: interface_747): boolean;\n        export function clone(obj: {slice: () => void}): any;\n        export function htmlEscape(str: {replace: (arg0: void, arg1: void) => void}): {replace: (arg0: void, arg1: void) => void};\n        export function inherit(childClass: {prototype: any}, parentClass: {prototype: any}): void;\n        export function isUndefined(obj: string | interface_786): boolean;\n    }\n    export var version: string;\n}\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":true,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.formatErrorMsg","newFunction":"function generateErrorMsg(domain, usage) {\r\n        var usageDefinition = usage ? '\\nUsage: ' + usage : '';\r\n\r\n        return function errorMsg(msg) {\r\n            return domain + ' : ' + msg + usageDefinition;\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window","oldFunction":null,"oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine","key":"formatErrorMsg","newType":"(domain: string | number, usage: string | number) => (msg: string | number) => string","isAny":false,"isClass":false,"containerType":"declare module jasmine {\n    export class Any {\n        constructor (expectedObject: any);\n        asymmetricMatch: (other: any) => boolean;\n        expectedObject: any;\n        jasmineToString: () => string;\n    }\n    export class Anything {\n        constructor ();\n        asymmetricMatch: (other: any) => boolean;\n        jasmineToString: () => string;\n    }\n    export class ArrayContaining {\n        constructor (sample: any);\n        asymmetricMatch: (other: interface_619) => boolean;\n        jasmineToString: () => string;\n        sample: any;\n    }\n    export class CallTracker {\n        constructor ();\n        all: () => Array<interface_679>;\n        allArgs: () => Array<any>;\n        any: () => boolean;\n        argsFor: (index: number) => Array<any>;\n        count: () => number;\n        first: () => interface_679;\n        mostRecent: () => interface_679;\n        reset: () => void;\n        saveArgumentsByValue: () => void;\n        track: (context: {args: any[]}) => void;\n    }\n    export class Clock {\n        constructor (global: Window | interface_470, delayedFunctionSchedulerFactory: () => jasmine.DelayedFunctionScheduler, mockDate: jasmine.MockDate);\n        clearInterval: (id: Window) => any;\n        clearTimeout: (id: Window) => any;\n        install: () => jasmine.Clock;\n        mockDate: (initialDate: {getTime: () => void}) => void;\n        setInterval: (fn: any, delay: any, params: any) => any;\n        setTimeout: (fn: any, delay: any, params: any) => any;\n        tick: (millis: any) => void;\n        uninstall: () => void;\n        withMock: (closure: () => void) => void;\n    }\n    export var DEFAULT_TIMEOUT_INTERVAL: number;\n    export class DelayedFunctionScheduler {\n        constructor ();\n        removeFunctionWithId: (timeoutKey: any) => void;\n        scheduleFunction: (funcToCall: string | (() => any), millis: number, params: any, recurring: any, timeoutKey: number, newCurrentTime: string) => number;\n        tick: (millis: number, tickDate: (arg0: void) => void) => void;\n    }\n    export class Env {\n        constructor (options: {global: any});\n        addCustomEqualityTester: (tester: any) => void;\n        addMatchers: (matchersToAdd: any) => void;\n        addReporter: (reporterToAdd: any) => void;\n        afterAll: (afterAllFunction: any, timeout: any) => void;\n        afterEach: (afterEachFunction: any, timeout: any) => void;\n        allowRespy: (allow: any) => void;\n        beforeAll: (beforeAllFunction: any, timeout: any) => void;\n        beforeEach: (beforeEachFunction: any, timeout: any) => void;\n        catchExceptions: (value: any) => boolean;\n        catchingExceptions: () => boolean;\n        clock: jasmine.Clock;\n        describe: (description: any, specDefinitions: {call: (arg0: void) => void, length: number}) => jasmine.Suite;\n        execute: (runnablesToRun: string[]) => void;\n        expect: (actual: any) => any;\n        fail: (error: {message: any}) => void;\n        fdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite | {id: any, isFocused: boolean};\n        fit: (description: any, fn: any, timeout: any) => {disabled: boolean} | jasmine.Spec;\n        it: (description: string, fn: () => void, timeout: any) => {disabled: boolean} | jasmine.Spec;\n        pending: (message: string) => void;\n        provideFallbackReporter: (reporterToAdd: any) => void;\n        randomTests: () => boolean;\n        randomizeTests: (value: any) => void;\n        seed: (value: any) => any;\n        specFilter: (spec: jasmine.Spec) => boolean;\n        spyOn: () => interface_490;\n        throwOnExpectationFailure: (value: any) => void;\n        throwingExpectationFailures: () => boolean;\n        topSuite: () => jasmine.Suite;\n        xdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite;\n        xit: () => {pend: (arg0: void) => void};\n    }\n    export class ExceptionFormatter {\n        constructor ();\n        message: (error: interface_682) => string;\n        stack: (error: {stack: any}) => any;\n    }\n    export class Expectation {\n        constructor (options: interface_686);\n        static Factory: (options: interface_689) => jasmine.Expectation | {not: jasmine.Expectation};\n        static addCoreMatchers: (matchers: interface_691) => void;\n        actual: any;\n        addExpectationResult: () => void;\n        customEqualityTesters: Array<any>;\n        isNot: any;\n        toBe: () => void;\n        toBeCloseTo: () => void;\n        toBeDefined: () => void;\n        toBeFalsy: () => void;\n        toBeGreaterThan: () => void;\n        toBeGreaterThanOrEqual: () => void;\n        toBeLessThan: () => void;\n        toBeLessThanOrEqual: () => void;\n        toBeNaN: () => void;\n        toBeNull: () => void;\n        toBeTruthy: () => void;\n        toBeUndefined: () => void;\n        toContain: () => void;\n        toEqual: () => void;\n        toHaveBeenCalled: () => void;\n        toHaveBeenCalledTimes: () => void;\n        toHaveBeenCalledWith: () => void;\n        toMatch: () => void;\n        toThrow: () => void;\n        toThrowError: () => void;\n        util: {buildFailureMessage: () => void};\n        wrapCompare: (name: any, matcherFactory: (arg0: void, arg1: void) => void) => () => void;\n    }\n    export class HtmlReporter {\n        constructor (options: interface_694);\n        initialize: () => void;\n        jasmineDone: (doneResult: interface_696) => void;\n        jasmineStarted: (options: {totalSpecsDefined: number}) => void;\n        specDone: (result: interface_699) => void;\n        specStarted: (result: any) => void;\n        suiteDone: (result: {status: string}) => void;\n        suiteStarted: (result: any) => void;\n    }\n    export class HtmlSpecFilter {\n        constructor (options: {filterString: () => void});\n        matches: (specName: string) => boolean;\n    }\n    export class JsApiReporter {\n        constructor (options: {timer: any});\n        executionTime: () => number;\n        finished: boolean;\n        jasmineDone: (runDetails: interface_696) => void;\n        jasmineStarted: (arg0: {totalSpecsDefined: number}) => void;\n        runDetails: interface_701;\n        specDone: (result: any) => void;\n        specResults: (index: number, length: string | number) => Array<any>;\n        specs: () => Array<any>;\n        started: boolean;\n        status: () => string;\n        suiteDone: (result: {id: string | number}) => void;\n        suiteResults: (index: number, length: string | number) => Array<any>;\n        suiteStarted: (result: {id: string | number}) => void;\n        suites: () => any;\n    }\n    export var MAX_PRETTY_PRINT_ARRAY_LENGTH: number;\n    export var MAX_PRETTY_PRINT_DEPTH: number;\n    export class MockDate {\n        constructor (global: Window);\n        install: (mockDate: {getTime: () => void}) => void;\n        tick: (millis: number) => void;\n        uninstall: () => void;\n    }\n    export class ObjectContaining {\n        constructor (sample: any);\n        asymmetricMatch: (other: any) => boolean;\n        jasmineToString: () => string;\n        sample: any;\n    }\n    export class Order {\n        constructor (options: {random: boolean, seed: any});\n        random: boolean;\n        seed: string;\n        sort: (items: any) => any;\n    }\n    export class QueryString {\n        constructor (options: {getWindowLocation: () => void});\n        fullStringWithNewParam: (key: string, value: any) => string;\n        getParam: (key: string) => any;\n        navigateWithNewParam: (key: string, value: boolean) => void;\n    }\n    export class QueueRunner {\n        constructor (attrs: interface_704);\n        catchException: () => boolean;\n        clearStack: (fn: () => void) => void;\n        execute: () => void;\n        fail: () => void;\n        onComplete: () => void;\n        onException: () => void;\n        queueableFns: Array<any>;\n        run: (queueableFns: interface_633, recursiveIndex: number) => void;\n        timeout: interface_706;\n        userContext: any;\n    }\n    export class ReportDispatcher {\n        constructor (methods: string[]);\n        addReporter: (reporter: any) => void;\n        jasmineDone: () => void;\n        jasmineStarted: () => void;\n        provideFallbackReporter: (reporter: any) => void;\n        specDone: () => void;\n        specStarted: () => void;\n        suiteDone: () => void;\n        suiteStarted: () => void;\n    }\n    export class ResultsNode {\n        constructor (result: any, type: string, parent: any);\n        addChild: (result: any, type: string) => void;\n        children: Array<any>;\n        last: () => any;\n        parent: any;\n        result: any;\n        type: string;\n    }\n    export class Spec {\n        constructor (attrs: interface_715);\n        static isPendingSpecException: (e: {toString: () => void}) => boolean;\n        static pendingSpecExceptionMessage: string;\n        addExpectationResult: (passed: boolean, data: interface_716, isError: boolean) => void;\n        beforeAndAfterFns: () => {afters: Array<any>, befores: Array<any>};\n        catchingExceptions: () => boolean;\n        description: string;\n        disable: () => void;\n        execute: (onComplete: () => void, enabled: boolean) => void;\n        expect: (actual: any) => any;\n        expectationFactory: any;\n        expectationResultFactory: () => void;\n        getFullName: () => any;\n        getResult: () => {status: string};\n        getSpecName: () => string;\n        id: any;\n        isExecutable: () => boolean;\n        onException: (e: {toString: () => void}) => void;\n        onStart: () => void;\n        pend: (message: any) => void;\n        queueRunnerFactory: () => void;\n        queueableFn: {fn: any};\n        result: interface_718;\n        resultCallback: () => void;\n        status: (enabled: boolean) => string;\n        throwOnExpectationFailure: boolean;\n        userContext: () => any;\n    }\n    export class SpyRegistry {\n        constructor (options: {currentSpies: () => any});\n        allowRespy: (allow: any) => void;\n        clearSpies: () => void;\n        spyOn: (obj: interface_628, methodName: string) => interface_490;\n    }\n    export class SpyStrategy {\n        constructor (options: interface_720);\n        callFake: (originalFn: string | number | ((arg0: void, arg1: void, arg2: void, arg3: void, arg4: void) => any)) => any;\n        callThrough: () => any;\n        exec: () => any;\n        identity: () => string;\n        returnValue: (value: any) => any;\n        returnValues: () => any;\n        stub: (fn: any) => any;\n        throwError: (something: Error | string) => any;\n    }\n    export class StringMatching {\n        constructor (expected: string);\n        asymmetricMatch: (other: any) => any;\n        jasmineToString: () => string;\n        regexp: RegExp;\n    }\n    export class Suite {\n        constructor (attrs: interface_731);\n        addChild: (child: jasmine.Suite | jasmine.Spec | {id: void, isFocused: boolean}) => void;\n        addExpectationResult: () => void;\n        afterAll: (fn: {fn: any, timeout: () => number}) => void;\n        afterAllFns: Array<any>;\n        afterEach: (fn: {fn: any, timeout: () => number}) => void;\n        afterFns: Array<any>;\n        beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n        beforeAllFns: Array<any>;\n        beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n        beforeFns: Array<any>;\n        canBeReentered: () => boolean;\n        children: Array<any>;\n        clonedSharedUserContext: () => any;\n        description: string;\n        disable: () => void;\n        disabled: boolean;\n        env: jasmine.Env;\n        expect: (actual: any) => jasmine.Expectation | {not: jasmine.Expectation};\n        expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n        expectationResultFactory: (attrs: interface_722) => interface_724;\n        getFullName: () => string;\n        getResult: () => interface_733;\n        id: string;\n        isExecutable: () => boolean;\n        onException: () => void;\n        parentSuite: any;\n        pend: (message: any) => void;\n        result: interface_735;\n        sharedContext: any;\n        sharedUserContext: () => any;\n        status: () => string;\n        throwOnExpectationFailure: boolean;\n    }\n    export class Timer {\n        constructor (options: {now: any});\n        elapsed: () => number;\n        start: () => void;\n    }\n    export class TreeProcessor {\n        constructor (attrs: interface_743);\n        execute: (done: any) => void;\n        processTree: () => interface_611;\n    }\n    export function addCustomEqualityTester(tester: any): void;\n    export function addMatchers(matchers: any): any;\n    export function any(clazz: any): jasmine.Any;\n    export function anything(): jasmine.Anything;\n    export function arrayContaining(sample: any): jasmine.ArrayContaining;\n    export function buildExpectationResult(options: interface_745): interface_709;\n    export function clock(): jasmine.Clock;\n    export function createSpy(name: string | number, originalFn: any): interface_608;\n    export function createSpyObj(baseName: string | interface_640, methodNames: string | interface_640): interface_644;\n    export var currentEnv_: jasmine.Env;\n    export module errors {\n        export var ExpectationFailed: ExpectationFailedConstructor;\n    }\n    export function fnNameFor(func: {name: any, test: void, toString: () => void}): string;\n    export function formatErrorMsg(domain: string | number, usage: string | number): (msg: string | number) => string;\n    export function getEnv(options: {global: any}): jasmine.Env;\n    export function getGlobal(): Window;\n    export function isA_(typeName: string, value: interface_747 | string): boolean;\n    export function isArray_(value: interface_747 | string): boolean;\n    export function isDomNode(obj: interface_749): boolean;\n    export function isNumber_(value: any): boolean;\n    export function isSpy(putativeSpy: interface_751): boolean;\n    export function isString_(value: any): boolean;\n    export module matchers {\n        export function toBe(): interface_754;\n        export function toBeCloseTo(): interface_755;\n        export function toBeDefined(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeFalsy(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeGreaterThan(): interface_757;\n        export function toBeGreaterThanOrEqual(): interface_759;\n        export function toBeLessThan(): interface_761;\n        export function toBeLessThanOrEqual(): interface_762;\n        export function toBeNaN(): interface_764;\n        export function toBeNull(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeTruthy(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeUndefined(): {compare: (actual: any) => {pass: boolean}};\n        export function toContain(util: interface_766, customEqualityTesters: Array<any>): interface_768;\n        export function toEqual(util: interface_769, customEqualityTesters: Array<any>): interface_771;\n        export function toHaveBeenCalled(): interface_772;\n        export function toHaveBeenCalledTimes(): interface_774;\n        export function toHaveBeenCalledWith(util: interface_776, customEqualityTesters: any): interface_777;\n        export function toMatch(): interface_779;\n        export function toThrow(util: {equals: (arg0: void, arg1: void) => void}): interface_780;\n        export function toThrowError(): interface_782;\n    }\n    export module matchersUtil {\n        export function buildFailureMessage(): string;\n        export function contains(haystack: interface_398, needle: string | interface_413, customTesters: Array<function_784>): boolean;\n        export function equals(a: string | interface_413, b: string | interface_413, customTesters: Array<function_784>): boolean;\n    }\n    export function objectContaining(sample: any): jasmine.ObjectContaining;\n    export function pp(value: number | Window | interface_607): any;\n    export function stringMatching(expected: string): jasmine.StringMatching;\n    export function unimplementedMethod_(): void;\n    export module util {\n        export function argsToArray(args: any[]): Array<any>;\n        export function arrayContains(array: any[], search: interface_747): boolean;\n        export function clone(obj: {slice: () => void}): any;\n        export function htmlEscape(str: {replace: (arg0: void, arg1: void) => void}): {replace: (arg0: void, arg1: void) => void};\n        export function inherit(childClass: {prototype: any}, parentClass: {prototype: any}): void;\n        export function isUndefined(obj: string | interface_786): boolean;\n    }\n    export var version: string;\n}\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.CallTracker","newFunction":"function(j$) {\r\n\r\n    function CallTracker() {\r\n        var calls = [];\r\n        var opts = {};\r\n\r\n        function argCloner(context) {\r\n            var clonedArgs = [];\r\n            var argsAsArray = j$.util.argsToArray(context.args);\r\n            for(var i = 0; i < argsAsArray.length; i++) {\r\n                if(Object.prototype.toString.apply(argsAsArray[i]).match(/^\\[object/)) {\r\n                    clonedArgs.push(j$.util.clone(argsAsArray[i]));\r\n                } else {\r\n                    clonedArgs.push(argsAsArray[i]);\r\n                }\r\n            }\r\n            context.args = clonedArgs;\r\n        }\r\n\r\n        this.track = function(context) {\r\n            if(opts.cloneArgs) {\r\n                argCloner(context);\r\n            }\r\n            calls.push(context);\r\n        };\r\n\r\n        this.any = function() {\r\n            return !!calls.length;\r\n        };\r\n\r\n        this.count = function() {\r\n            return calls.length;\r\n        };\r\n\r\n        this.argsFor = function(index) {\r\n            var call = calls[index];\r\n            return call ? call.args : [];\r\n        };\r\n\r\n        this.all = function() {\r\n            return calls;\r\n        };\r\n\r\n        this.allArgs = function() {\r\n            var callArgs = [];\r\n            for(var i = 0; i < calls.length; i++){\r\n                callArgs.push(calls[i].args);\r\n            }\r\n\r\n            return callArgs;\r\n        };\r\n\r\n        this.first = function() {\r\n            return calls[0];\r\n        };\r\n\r\n        this.mostRecent = function() {\r\n            return calls[calls.length - 1];\r\n        };\r\n\r\n        this.reset = function() {\r\n            calls = [];\r\n        };\r\n\r\n        this.saveArgumentsByValue = function() {\r\n            opts.cloneArgs = true;\r\n        };\r\n\r\n    }\r\n\r\n    return CallTracker;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.CallTracker","oldFunction":"function() {\r\n\r\n    function CallTracker() {\r\n        var calls = [];\r\n\r\n        this.track = function(context) {\r\n            calls.push(context);\r\n        };\r\n\r\n        this.any = function() {\r\n            return !!calls.length;\r\n        };\r\n\r\n        this.count = function() {\r\n            return calls.length;\r\n        };\r\n\r\n        this.argsFor = function(index) {\r\n            var call = calls[index];\r\n            return call ? call.args : [];\r\n        };\r\n\r\n        this.all = function() {\r\n            return calls;\r\n        };\r\n\r\n        this.allArgs = function() {\r\n            var callArgs = [];\r\n            for(var i = 0; i < calls.length; i++){\r\n                callArgs.push(calls[i].args);\r\n            }\r\n\r\n            return callArgs;\r\n        };\r\n\r\n        this.first = function() {\r\n            return calls[0];\r\n        };\r\n\r\n        this.mostRecent = function() {\r\n            return calls[calls.length - 1];\r\n        };\r\n\r\n        this.reset = function() {\r\n            calls = [];\r\n        };\r\n    }\r\n\r\n    return CallTracker;\r\n}","oldJSDoc":null,"type":"changedArgCount","typePath":"window.jasmineRequire.CallTracker","isClass":false,"newType":"(j$: {util: interface_790}) => () => void","newTypeDescription":"function","oldType":"() => () => void","oldArgCount":0,"newArgCount":1,"containerType":"interface interface_873 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.Any","newFunction":"function(j$) {\r\n\r\n    function Any(expectedObject) {\r\n        if (typeof expectedObject === 'undefined') {\r\n            throw new TypeError(\r\n                'jasmine.any() expects to be passed a constructor function. ' +\r\n                'Please pass one or use jasmine.anything() to match any object.'\r\n            );\r\n        }\r\n        this.expectedObject = expectedObject;\r\n    }\r\n\r\n    Any.prototype.asymmetricMatch = function(other) {\r\n        if (this.expectedObject == String) {\r\n            return typeof other == 'string' || other instanceof String;\r\n        }\r\n\r\n        if (this.expectedObject == Number) {\r\n            return typeof other == 'number' || other instanceof Number;\r\n        }\r\n\r\n        if (this.expectedObject == Function) {\r\n            return typeof other == 'function' || other instanceof Function;\r\n        }\r\n\r\n        if (this.expectedObject == Object) {\r\n            return typeof other == 'object';\r\n        }\r\n\r\n        if (this.expectedObject == Boolean) {\r\n            return typeof other == 'boolean';\r\n        }\r\n\r\n        return other instanceof this.expectedObject;\r\n    };\r\n\r\n    Any.prototype.jasmineToString = function() {\r\n        return '<jasmine.any(' + j$.fnNameFor(this.expectedObject) + ')>';\r\n    };\r\n\r\n    return Any;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.Any","oldFunction":"function() {\r\n\r\n    function Any(expectedObject) {\r\n        this.expectedObject = expectedObject;\r\n    }\r\n\r\n    Any.prototype.asymmetricMatch = function(other) {\r\n        if (this.expectedObject == String) {\r\n            return typeof other == 'string' || other instanceof String;\r\n        }\r\n\r\n        if (this.expectedObject == Number) {\r\n            return typeof other == 'number' || other instanceof Number;\r\n        }\r\n\r\n        if (this.expectedObject == Function) {\r\n            return typeof other == 'function' || other instanceof Function;\r\n        }\r\n\r\n        if (this.expectedObject == Object) {\r\n            return typeof other == 'object';\r\n        }\r\n\r\n        if (this.expectedObject == Boolean) {\r\n            return typeof other == 'boolean';\r\n        }\r\n\r\n        return other instanceof this.expectedObject;\r\n    };\r\n\r\n    Any.prototype.jasmineToString = function() {\r\n        return '<jasmine.any(' + this.expectedObject + ')>';\r\n    };\r\n\r\n    return Any;\r\n}","oldJSDoc":null,"type":"changedArgCount","typePath":"window.jasmineRequire.Any","isClass":false,"newType":"(j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void","newTypeDescription":"function","oldType":"() => (expectedObject: any) => void","oldArgCount":0,"newArgCount":1,"containerType":"interface interface_873 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.matchers.toHaveBeenCalledTimes","newFunction":"function toHaveBeenCalledTimes() {\r\n        return {\r\n            compare: function(actual, expected) {\r\n                if (!j$.isSpy(actual)) {\r\n                    throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));\r\n                }\r\n\r\n                var args = Array.prototype.slice.call(arguments, 0),\r\n                    result = { pass: false };\r\n\r\n                if (!j$.isNumber_(expected)){\r\n                    throw new Error(getErrorMsg('The expected times failed is a required argument and must be a number.'));\r\n                }\r\n\r\n                actual = args[0];\r\n                var calls = actual.calls.count();\r\n                var timesMessage = expected === 1 ? 'once' : expected + ' times';\r\n                result.pass = calls === expected;\r\n                result.message = result.pass ?\r\n                'Expected spy ' + actual.and.identity() + ' not to have been called ' + timesMessage + '. It was called ' +  calls + ' times.' :\r\n                'Expected spy ' + actual.and.identity() + ' to have been called ' + timesMessage + '. It was called ' +  calls + ' times.';\r\n                return result;\r\n            }\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window","oldFunction":null,"oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.matchers","key":"toHaveBeenCalledTimes","newType":"() => interface_774","isAny":false,"isClass":false,"containerType":"declare module matchers {\n    export function toBe(): interface_754;\n    export function toBeCloseTo(): interface_755;\n    export function toBeDefined(): {compare: (actual: any) => {pass: boolean}};\n    export function toBeFalsy(): {compare: (actual: any) => {pass: boolean}};\n    export function toBeGreaterThan(): interface_757;\n    export function toBeGreaterThanOrEqual(): interface_759;\n    export function toBeLessThan(): interface_761;\n    export function toBeLessThanOrEqual(): interface_762;\n    export function toBeNaN(): interface_764;\n    export function toBeNull(): {compare: (actual: any) => {pass: boolean}};\n    export function toBeTruthy(): {compare: (actual: any) => {pass: boolean}};\n    export function toBeUndefined(): {compare: (actual: any) => {pass: boolean}};\n    export function toContain(util: interface_766, customEqualityTesters: Array<any>): interface_768;\n    export function toEqual(util: interface_769, customEqualityTesters: Array<any>): interface_771;\n    export function toHaveBeenCalled(): interface_772;\n    export function toHaveBeenCalledTimes(): interface_774;\n    export function toHaveBeenCalledWith(util: interface_776, customEqualityTesters: any): interface_777;\n    export function toMatch(): interface_779;\n    export function toThrow(util: {equals: (arg0: void, arg1: void) => void}): interface_780;\n    export function toThrowError(): interface_782;\n}\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.matchers.toBeGreaterThanOrEqual","newFunction":"function toBeGreaterThanOrEqual() {\r\n        return {\r\n            compare: function(actual, expected) {\r\n                return {\r\n                    pass: actual >= expected\r\n                };\r\n            }\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window","oldFunction":null,"oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.matchers","key":"toBeGreaterThanOrEqual","newType":"() => interface_759","isAny":false,"isClass":false,"containerType":"declare module matchers {\n    export function toBe(): interface_754;\n    export function toBeCloseTo(): interface_755;\n    export function toBeDefined(): {compare: (actual: any) => {pass: boolean}};\n    export function toBeFalsy(): {compare: (actual: any) => {pass: boolean}};\n    export function toBeGreaterThan(): interface_757;\n    export function toBeGreaterThanOrEqual(): interface_759;\n    export function toBeLessThan(): interface_761;\n    export function toBeLessThanOrEqual(): interface_762;\n    export function toBeNaN(): interface_764;\n    export function toBeNull(): {compare: (actual: any) => {pass: boolean}};\n    export function toBeTruthy(): {compare: (actual: any) => {pass: boolean}};\n    export function toBeUndefined(): {compare: (actual: any) => {pass: boolean}};\n    export function toContain(util: interface_766, customEqualityTesters: Array<any>): interface_768;\n    export function toEqual(util: interface_769, customEqualityTesters: Array<any>): interface_771;\n    export function toHaveBeenCalled(): interface_772;\n    export function toHaveBeenCalledTimes(): interface_774;\n    export function toHaveBeenCalledWith(util: interface_776, customEqualityTesters: any): interface_777;\n    export function toMatch(): interface_779;\n    export function toThrow(util: {equals: (arg0: void, arg1: void) => void}): interface_780;\n    export function toThrowError(): interface_782;\n}\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.matchers.toBeLessThanOrEqual","newFunction":"function toBeLessThanOrEqual() {\r\n        return {\r\n\r\n            compare: function(actual, expected) {\r\n                return {\r\n                    pass: actual <= expected\r\n                };\r\n            }\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window","oldFunction":null,"oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.matchers","key":"toBeLessThanOrEqual","newType":"() => interface_762","isAny":false,"isClass":false,"containerType":"declare module matchers {\n    export function toBe(): interface_754;\n    export function toBeCloseTo(): interface_755;\n    export function toBeDefined(): {compare: (actual: any) => {pass: boolean}};\n    export function toBeFalsy(): {compare: (actual: any) => {pass: boolean}};\n    export function toBeGreaterThan(): interface_757;\n    export function toBeGreaterThanOrEqual(): interface_759;\n    export function toBeLessThan(): interface_761;\n    export function toBeLessThanOrEqual(): interface_762;\n    export function toBeNaN(): interface_764;\n    export function toBeNull(): {compare: (actual: any) => {pass: boolean}};\n    export function toBeTruthy(): {compare: (actual: any) => {pass: boolean}};\n    export function toBeUndefined(): {compare: (actual: any) => {pass: boolean}};\n    export function toContain(util: interface_766, customEqualityTesters: Array<any>): interface_768;\n    export function toEqual(util: interface_769, customEqualityTesters: Array<any>): interface_771;\n    export function toHaveBeenCalled(): interface_772;\n    export function toHaveBeenCalledTimes(): interface_774;\n    export function toHaveBeenCalledWith(util: interface_776, customEqualityTesters: any): interface_777;\n    export function toMatch(): interface_779;\n    export function toThrow(util: {equals: (arg0: void, arg1: void) => void}): interface_780;\n    export function toThrowError(): interface_782;\n}\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.Suite","newFunction":"function(j$) {\r\n    function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }\r\n\r\n    Suite.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Suite.prototype.getFullName = function() {\r\n        var fullName = [];\r\n        for (var parentSuite = this; parentSuite; parentSuite = parentSuite.parentSuite) {\r\n            if (parentSuite.parentSuite) {\r\n                fullName.unshift(parentSuite.description);\r\n            }\r\n        }\r\n        return fullName.join(' ');\r\n    };\r\n\r\n    Suite.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Suite.prototype.pend = function(message) {\r\n        this.markedPending = true;\r\n    };\r\n\r\n    Suite.prototype.beforeEach = function(fn) {\r\n        this.beforeFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.beforeAll = function(fn) {\r\n        this.beforeAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.afterEach = function(fn) {\r\n        this.afterFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.afterAll = function(fn) {\r\n        this.afterAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.addChild = function(child) {\r\n        this.children.push(child);\r\n    };\r\n\r\n    Suite.prototype.status = function() {\r\n        if (this.disabled) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.markedPending) {\r\n            return 'pending';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'finished';\r\n        }\r\n    };\r\n\r\n    Suite.prototype.isExecutable = function() {\r\n        return !this.disabled;\r\n    };\r\n\r\n    Suite.prototype.canBeReentered = function() {\r\n        return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;\r\n    };\r\n\r\n    Suite.prototype.getResult = function() {\r\n        this.result.status = this.status();\r\n        return this.result;\r\n    };\r\n\r\n    Suite.prototype.sharedUserContext = function() {\r\n        if (!this.sharedContext) {\r\n            this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\r\n        }\r\n\r\n        return this.sharedContext;\r\n    };\r\n\r\n    Suite.prototype.clonedSharedUserContext = function() {\r\n        return clone(this.sharedUserContext());\r\n    };\r\n\r\n    Suite.prototype.onException = function() {\r\n        if (arguments[0] instanceof j$.errors.ExpectationFailed) {\r\n            return;\r\n        }\r\n\r\n        if(isAfterAll(this.children)) {\r\n            var data = {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                error: arguments[0]\r\n            };\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.onException.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    Suite.prototype.addExpectationResult = function () {\r\n        if(isAfterAll(this.children) && isFailure(arguments)){\r\n            var data = arguments[1];\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n            if(this.throwOnExpectationFailure) {\r\n                throw new j$.errors.ExpectationFailed();\r\n            }\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                try {\r\n                    child.addExpectationResult.apply(child, arguments);\r\n                } catch(e) {\r\n                    // keep going\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    function isAfterAll(children) {\r\n        return children && children[0].result.status;\r\n    }\r\n\r\n    function isFailure(args) {\r\n        return !args[0];\r\n    }\r\n\r\n    function clone(obj) {\r\n        var clonedObj = {};\r\n        for (var prop in obj) {\r\n            if (obj.hasOwnProperty(prop)) {\r\n                clonedObj[prop] = obj[prop];\r\n            }\r\n        }\r\n\r\n        return clonedObj;\r\n    }\r\n\r\n    return Suite;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.Suite","oldFunction":"function() {\r\n    function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }\r\n\r\n    Suite.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Suite.prototype.getFullName = function() {\r\n        var fullName = this.description;\r\n        for (var parentSuite = this.parentSuite; parentSuite; parentSuite = parentSuite.parentSuite) {\r\n            if (parentSuite.parentSuite) {\r\n                fullName = parentSuite.description + ' ' + fullName;\r\n            }\r\n        }\r\n        return fullName;\r\n    };\r\n\r\n    Suite.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Suite.prototype.beforeEach = function(fn) {\r\n        this.beforeFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.beforeAll = function(fn) {\r\n        this.beforeAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.afterEach = function(fn) {\r\n        this.afterFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.afterAll = function(fn) {\r\n        this.afterAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.addChild = function(child) {\r\n        this.children.push(child);\r\n    };\r\n\r\n    Suite.prototype.status = function() {\r\n        if (this.disabled) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'finished';\r\n        }\r\n    };\r\n\r\n    Suite.prototype.execute = function(onComplete) {\r\n        var self = this;\r\n\r\n        this.onStart(this);\r\n\r\n        if (this.disabled) {\r\n            complete();\r\n            return;\r\n        }\r\n\r\n        var allFns = [];\r\n\r\n        for (var i = 0; i < this.children.length; i++) {\r\n            allFns.push(wrapChildAsAsync(this.children[i]));\r\n        }\r\n\r\n        if (this.isExecutable()) {\r\n            allFns = this.beforeAllFns.concat(allFns);\r\n            allFns = allFns.concat(this.afterAllFns);\r\n        }\r\n\r\n        this.queueRunner({\r\n            queueableFns: allFns,\r\n            onComplete: complete,\r\n            userContext: this.sharedUserContext(),\r\n            onException: function() { self.onException.apply(self, arguments); }\r\n        });\r\n\r\n        function complete() {\r\n            self.result.status = self.status();\r\n            self.resultCallback(self.result);\r\n\r\n            if (onComplete) {\r\n                onComplete();\r\n            }\r\n        }\r\n\r\n        function wrapChildAsAsync(child) {\r\n            return { fn: function(done) { child.execute(done); } };\r\n        }\r\n    };\r\n\r\n    Suite.prototype.isExecutable = function() {\r\n        var runnablesExplicitlySet = this.runnablesExplictlySetGetter();\r\n        return !runnablesExplicitlySet && hasExecutableChild(this.children);\r\n    };\r\n\r\n    Suite.prototype.sharedUserContext = function() {\r\n        if (!this.sharedContext) {\r\n            this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\r\n        }\r\n\r\n        return this.sharedContext;\r\n    };\r\n\r\n    Suite.prototype.clonedSharedUserContext = function() {\r\n        return clone(this.sharedUserContext());\r\n    };\r\n\r\n    Suite.prototype.onException = function() {\r\n        if(isAfterAll(this.children)) {\r\n            var data = {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                error: arguments[0]\r\n            };\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.onException.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    Suite.prototype.addExpectationResult = function () {\r\n        if(isAfterAll(this.children) && isFailure(arguments)){\r\n            var data = arguments[1];\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.addExpectationResult.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    function isAfterAll(children) {\r\n        return children && children[0].result.status;\r\n    }\r\n\r\n    function isFailure(args) {\r\n        return !args[0];\r\n    }\r\n\r\n    function hasExecutableChild(children) {\r\n        var foundActive = false;\r\n        for (var i = 0; i < children.length; i++) {\r\n            if (children[i].isExecutable()) {\r\n                foundActive = true;\r\n                break;\r\n            }\r\n        }\r\n        return foundActive;\r\n    }\r\n\r\n    function clone(obj) {\r\n        var clonedObj = {};\r\n        for (var prop in obj) {\r\n            if (obj.hasOwnProperty(prop)) {\r\n                clonedObj[prop] = obj[prop];\r\n            }\r\n        }\r\n\r\n        return clonedObj;\r\n    }\r\n\r\n    return Suite;\r\n}","oldJSDoc":null,"type":"changedArgCount","typePath":"window.jasmineRequire.Suite","isClass":false,"newType":"(j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void","newTypeDescription":"function","oldType":"() => (attrs: interface_806) => void","oldArgCount":0,"newArgCount":1,"containerType":"interface interface_873 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.matchers.toThrowError","newFunction":"function toThrowError () {\r\n        return {\r\n            compare: function(actual) {\r\n                var threw = false,\r\n                    pass = {pass: true},\r\n                    fail = {pass: false},\r\n                    thrown;\r\n\r\n                if (typeof actual != 'function') {\r\n                    throw new Error(getErrorMsg('Actual is not a Function'));\r\n                }\r\n\r\n                var errorMatcher = getMatcher.apply(null, arguments);\r\n\r\n                try {\r\n                    actual();\r\n                } catch (e) {\r\n                    threw = true;\r\n                    thrown = e;\r\n                }\r\n\r\n                if (!threw) {\r\n                    fail.message = 'Expected function to throw an Error.';\r\n                    return fail;\r\n                }\r\n\r\n                if (!(thrown instanceof Error)) {\r\n                    fail.message = function() { return 'Expected function to throw an Error, but it threw ' + j$.pp(thrown) + '.'; };\r\n                    return fail;\r\n                }\r\n\r\n                if (errorMatcher.hasNoSpecifics()) {\r\n                    pass.message = 'Expected function not to throw an Error, but it threw ' + j$.fnNameFor(thrown) + '.';\r\n                    return pass;\r\n                }\r\n\r\n                if (errorMatcher.matches(thrown)) {\r\n                    pass.message = function() {\r\n                        return 'Expected function not to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() + '.';\r\n                    };\r\n                    return pass;\r\n                } else {\r\n                    fail.message = function() {\r\n                        return 'Expected function to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() +\r\n                            ', but it threw ' + errorMatcher.thrownDescription(thrown) + '.';\r\n                    };\r\n                    return fail;\r\n                }\r\n            }\r\n        };\r\n\r\n        function getMatcher() {\r\n            var expected = null,\r\n                errorType = null;\r\n\r\n            if (arguments.length == 2) {\r\n                expected = arguments[1];\r\n                if (isAnErrorType(expected)) {\r\n                    errorType = expected;\r\n                    expected = null;\r\n                }\r\n            } else if (arguments.length > 2) {\r\n                errorType = arguments[1];\r\n                expected = arguments[2];\r\n                if (!isAnErrorType(errorType)) {\r\n                    throw new Error(getErrorMsg('Expected error type is not an Error.'));\r\n                }\r\n            }\r\n\r\n            if (expected && !isStringOrRegExp(expected)) {\r\n                if (errorType) {\r\n                    throw new Error(getErrorMsg('Expected error message is not a string or RegExp.'));\r\n                } else {\r\n                    throw new Error(getErrorMsg('Expected is not an Error, string, or RegExp.'));\r\n                }\r\n            }\r\n\r\n            function messageMatch(message) {\r\n                if (typeof expected == 'string') {\r\n                    return expected == message;\r\n                } else {\r\n                    return expected.test(message);\r\n                }\r\n            }\r\n\r\n            return {\r\n                errorTypeDescription: errorType ? j$.fnNameFor(errorType) : 'an exception',\r\n                thrownDescription: function(thrown) {\r\n                    var thrownName = errorType ? j$.fnNameFor(thrown.constructor) : 'an exception',\r\n                        thrownMessage = '';\r\n\r\n                    if (expected) {\r\n                        thrownMessage = ' with message ' + j$.pp(thrown.message);\r\n                    }\r\n\r\n                    return thrownName + thrownMessage;\r\n                },\r\n                messageDescription: function() {\r\n                    if (expected === null) {\r\n                        return '';\r\n                    } else if (expected instanceof RegExp) {\r\n                        return ' with a message matching ' + j$.pp(expected);\r\n                    } else {\r\n                        return ' with message ' + j$.pp(expected);\r\n                    }\r\n                },\r\n                hasNoSpecifics: function() {\r\n                    return expected === null && errorType === null;\r\n                },\r\n                matches: function(error) {\r\n                    return (errorType === null || error instanceof errorType) &&\r\n                        (expected === null || messageMatch(error.message));\r\n                }\r\n            };\r\n        }\r\n\r\n        function isStringOrRegExp(potential) {\r\n            return potential instanceof RegExp || (typeof potential == 'string');\r\n        }\r\n\r\n        function isAnErrorType(type) {\r\n            if (typeof type !== 'function') {\r\n                return false;\r\n            }\r\n\r\n            var Surrogate = function() {};\r\n            Surrogate.prototype = type.prototype;\r\n            return (new Surrogate()) instanceof Error;\r\n        }\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.matchers.toThrowError","oldFunction":"function toThrowError (util) {\r\n        return {\r\n            compare: function(actual) {\r\n                var threw = false,\r\n                    pass = {pass: true},\r\n                    fail = {pass: false},\r\n                    thrown;\r\n\r\n                if (typeof actual != 'function') {\r\n                    throw new Error('Actual is not a Function');\r\n                }\r\n\r\n                var errorMatcher = getMatcher.apply(null, arguments);\r\n\r\n                try {\r\n                    actual();\r\n                } catch (e) {\r\n                    threw = true;\r\n                    thrown = e;\r\n                }\r\n\r\n                if (!threw) {\r\n                    fail.message = 'Expected function to throw an Error.';\r\n                    return fail;\r\n                }\r\n\r\n                if (!(thrown instanceof Error)) {\r\n                    fail.message = function() { return 'Expected function to throw an Error, but it threw ' + j$.pp(thrown) + '.'; };\r\n                    return fail;\r\n                }\r\n\r\n                if (errorMatcher.hasNoSpecifics()) {\r\n                    pass.message = 'Expected function not to throw an Error, but it threw ' + j$.fnNameFor(thrown) + '.';\r\n                    return pass;\r\n                }\r\n\r\n                if (errorMatcher.matches(thrown)) {\r\n                    pass.message = function() {\r\n                        return 'Expected function not to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() + '.';\r\n                    };\r\n                    return pass;\r\n                } else {\r\n                    fail.message = function() {\r\n                        return 'Expected function to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() +\r\n                            ', but it threw ' + errorMatcher.thrownDescription(thrown) + '.';\r\n                    };\r\n                    return fail;\r\n                }\r\n            }\r\n        };\r\n\r\n        function getMatcher() {\r\n            var expected = null,\r\n                errorType = null;\r\n\r\n            if (arguments.length == 2) {\r\n                expected = arguments[1];\r\n                if (isAnErrorType(expected)) {\r\n                    errorType = expected;\r\n                    expected = null;\r\n                }\r\n            } else if (arguments.length > 2) {\r\n                errorType = arguments[1];\r\n                expected = arguments[2];\r\n                if (!isAnErrorType(errorType)) {\r\n                    throw new Error('Expected error type is not an Error.');\r\n                }\r\n            }\r\n\r\n            if (expected && !isStringOrRegExp(expected)) {\r\n                if (errorType) {\r\n                    throw new Error('Expected error message is not a string or RegExp.');\r\n                } else {\r\n                    throw new Error('Expected is not an Error, string, or RegExp.');\r\n                }\r\n            }\r\n\r\n            function messageMatch(message) {\r\n                if (typeof expected == 'string') {\r\n                    return expected == message;\r\n                } else {\r\n                    return expected.test(message);\r\n                }\r\n            }\r\n\r\n            return {\r\n                errorTypeDescription: errorType ? j$.fnNameFor(errorType) : 'an exception',\r\n                thrownDescription: function(thrown) {\r\n                    var thrownName = errorType ? j$.fnNameFor(thrown.constructor) : 'an exception',\r\n                        thrownMessage = '';\r\n\r\n                    if (expected) {\r\n                        thrownMessage = ' with message ' + j$.pp(thrown.message);\r\n                    }\r\n\r\n                    return thrownName + thrownMessage;\r\n                },\r\n                messageDescription: function() {\r\n                    if (expected === null) {\r\n                        return '';\r\n                    } else if (expected instanceof RegExp) {\r\n                        return ' with a message matching ' + j$.pp(expected);\r\n                    } else {\r\n                        return ' with message ' + j$.pp(expected);\r\n                    }\r\n                },\r\n                hasNoSpecifics: function() {\r\n                    return expected === null && errorType === null;\r\n                },\r\n                matches: function(error) {\r\n                    return (errorType === null || error.constructor === errorType) &&\r\n                        (expected === null || messageMatch(error.message));\r\n                }\r\n            };\r\n        }\r\n\r\n        function isStringOrRegExp(potential) {\r\n            return potential instanceof RegExp || (typeof potential == 'string');\r\n        }\r\n\r\n        function isAnErrorType(type) {\r\n            if (typeof type !== 'function') {\r\n                return false;\r\n            }\r\n\r\n            var Surrogate = function() {};\r\n            Surrogate.prototype = type.prototype;\r\n            return (new Surrogate()) instanceof Error;\r\n        }\r\n    }","oldJSDoc":null,"type":"changedArgCount","typePath":"window.jasmine.matchers.toThrowError","isClass":false,"newType":"() => interface_782","newTypeDescription":"function","oldType":"(util: any) => interface_758","oldArgCount":1,"newArgCount":0,"containerType":"declare module matchers {\n    export function toBe(): interface_754;\n    export function toBeCloseTo(): interface_755;\n    export function toBeDefined(): {compare: (actual: any) => {pass: boolean}};\n    export function toBeFalsy(): {compare: (actual: any) => {pass: boolean}};\n    export function toBeGreaterThan(): interface_757;\n    export function toBeGreaterThanOrEqual(): interface_759;\n    export function toBeLessThan(): interface_761;\n    export function toBeLessThanOrEqual(): interface_762;\n    export function toBeNaN(): interface_764;\n    export function toBeNull(): {compare: (actual: any) => {pass: boolean}};\n    export function toBeTruthy(): {compare: (actual: any) => {pass: boolean}};\n    export function toBeUndefined(): {compare: (actual: any) => {pass: boolean}};\n    export function toContain(util: interface_766, customEqualityTesters: Array<any>): interface_768;\n    export function toEqual(util: interface_769, customEqualityTesters: Array<any>): interface_771;\n    export function toHaveBeenCalled(): interface_772;\n    export function toHaveBeenCalledTimes(): interface_774;\n    export function toHaveBeenCalledWith(util: interface_776, customEqualityTesters: any): interface_777;\n    export function toMatch(): interface_779;\n    export function toThrow(util: {equals: (arg0: void, arg1: void) => void}): interface_780;\n    export function toThrowError(): interface_782;\n}\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.SpyRegistry.[constructor].[return].allowRespy","newFunction":"function(allow){\r\n            this.respy = allow;\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.SpyRegistry.[constructor]","oldFunction":"function SpyRegistry(options) {\r\n        options = options || {};\r\n        var currentSpies = options.currentSpies || function() { return []; };\r\n\r\n        this.spyOn = function(obj, methodName) {\r\n            if (j$.util.isUndefined(obj)) {\r\n                throw new Error('spyOn could not find an object to spy upon for ' + methodName + '()');\r\n            }\r\n\r\n            if (j$.util.isUndefined(methodName)) {\r\n                throw new Error('No method name supplied');\r\n            }\r\n\r\n            if (j$.util.isUndefined(obj[methodName])) {\r\n                throw new Error(methodName + '() method does not exist');\r\n            }\r\n\r\n            if (obj[methodName] && j$.isSpy(obj[methodName])) {\r\n                //TODO?: should this return the current spy? Downside: may cause user confusion about spy state\r\n                throw new Error(methodName + ' has already been spied upon');\r\n            }\r\n\r\n            var spy = j$.createSpy(methodName, obj[methodName]);\r\n\r\n            currentSpies().push({\r\n                spy: spy,\r\n                baseObj: obj,\r\n                methodName: methodName,\r\n                originalValue: obj[methodName]\r\n            });\r\n\r\n            obj[methodName] = spy;\r\n\r\n            return spy;\r\n        };\r\n\r\n        this.clearSpies = function() {\r\n            var spies = currentSpies();\r\n            for (var i = 0; i < spies.length; i++) {\r\n                var spyEntry = spies[i];\r\n                spyEntry.baseObj[spyEntry.methodName] = spyEntry.originalValue;\r\n            }\r\n        };\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.SpyRegistry.[constructor].[return]","key":"allowRespy","newType":"(allow: any) => void","isAny":false,"isClass":false,"containerType":"class SpyRegistry1 {\n    constructor (options: {currentSpies: () => any});\n    allowRespy: (allow: any) => void;\n    clearSpies: () => void;\n    spyOn: (obj: interface_628, methodName: string) => interface_490;\n}\n","containerDescription":"class jasmine.SpyRegistry"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.JsApiReporter.[constructor]","newFunction":"function JsApiReporter(options) {\r\n        var timer = options.timer || noopTimer,\r\n            status = 'loaded';\r\n\r\n        this.started = false;\r\n        this.finished = false;\r\n        this.runDetails = {};\r\n\r\n        this.jasmineStarted = function() {\r\n            this.started = true;\r\n            status = 'started';\r\n            timer.start();\r\n        };\r\n\r\n        var executionTime;\r\n\r\n        this.jasmineDone = function(runDetails) {\r\n            this.finished = true;\r\n            this.runDetails = runDetails;\r\n            executionTime = timer.elapsed();\r\n            status = 'done';\r\n        };\r\n\r\n        this.status = function() {\r\n            return status;\r\n        };\r\n\r\n        var suites = [],\r\n            suites_hash = {};\r\n\r\n        this.suiteStarted = function(result) {\r\n            suites_hash[result.id] = result;\r\n        };\r\n\r\n        this.suiteDone = function(result) {\r\n            storeSuite(result);\r\n        };\r\n\r\n        this.suiteResults = function(index, length) {\r\n            return suites.slice(index, index + length);\r\n        };\r\n\r\n        function storeSuite(result) {\r\n            suites.push(result);\r\n            suites_hash[result.id] = result;\r\n        }\r\n\r\n        this.suites = function() {\r\n            return suites_hash;\r\n        };\r\n\r\n        var specs = [];\r\n\r\n        this.specDone = function(result) {\r\n            specs.push(result);\r\n        };\r\n\r\n        this.specResults = function(index, length) {\r\n            return specs.slice(index, index + length);\r\n        };\r\n\r\n        this.specs = function() {\r\n            return specs;\r\n        };\r\n\r\n        this.executionTime = function() {\r\n            return executionTime;\r\n        };\r\n\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.JsApiReporter.[constructor]","oldFunction":"function JsApiReporter(options) {\r\n        var timer = options.timer || noopTimer,\r\n            status = 'loaded';\r\n\r\n        this.started = false;\r\n        this.finished = false;\r\n\r\n        this.jasmineStarted = function() {\r\n            this.started = true;\r\n            status = 'started';\r\n            timer.start();\r\n        };\r\n\r\n        var executionTime;\r\n\r\n        this.jasmineDone = function() {\r\n            this.finished = true;\r\n            executionTime = timer.elapsed();\r\n            status = 'done';\r\n        };\r\n\r\n        this.status = function() {\r\n            return status;\r\n        };\r\n\r\n        var suites = [],\r\n            suites_hash = {};\r\n\r\n        this.suiteStarted = function(result) {\r\n            suites_hash[result.id] = result;\r\n        };\r\n\r\n        this.suiteDone = function(result) {\r\n            storeSuite(result);\r\n        };\r\n\r\n        this.suiteResults = function(index, length) {\r\n            return suites.slice(index, index + length);\r\n        };\r\n\r\n        function storeSuite(result) {\r\n            suites.push(result);\r\n            suites_hash[result.id] = result;\r\n        }\r\n\r\n        this.suites = function() {\r\n            return suites_hash;\r\n        };\r\n\r\n        var specs = [];\r\n\r\n        this.specDone = function(result) {\r\n            specs.push(result);\r\n        };\r\n\r\n        this.specResults = function(index, length) {\r\n            return specs.slice(index, index + length);\r\n        };\r\n\r\n        this.specs = function() {\r\n            return specs;\r\n        };\r\n\r\n        this.executionTime = function() {\r\n            return executionTime;\r\n        };\r\n\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.JsApiReporter.[constructor].[return]","key":"runDetails","newType":"interface interface_701 {\n    failedExpectations: Array<any>;\n    order: jasmine.Order;\n}\n\n","isAny":false,"isClass":false,"containerType":"class JsApiReporter1 {\n    constructor (options: {timer: any});\n    executionTime: () => number;\n    finished: boolean;\n    jasmineDone: (runDetails: interface_696) => void;\n    jasmineStarted: (arg0: {totalSpecsDefined: number}) => void;\n    runDetails: interface_701;\n    specDone: (result: any) => void;\n    specResults: (index: number, length: string | number) => Array<any>;\n    specs: () => Array<any>;\n    started: boolean;\n    status: () => string;\n    suiteDone: (result: {id: string | number}) => void;\n    suiteResults: (index: number, length: string | number) => Array<any>;\n    suiteStarted: (result: {id: string | number}) => void;\n    suites: () => any;\n}\n","containerDescription":"class jasmine.JsApiReporter"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.DelayedFunctionScheduler.[constructor]","newFunction":"function DelayedFunctionScheduler() {\r\n        var self = this;\r\n        var scheduledLookup = [];\r\n        var scheduledFunctions = {};\r\n        var currentTime = 0;\r\n        var delayedFnCount = 0;\r\n\r\n        self.tick = function(millis, tickDate) {\r\n            millis = millis || 0;\r\n            var endTime = currentTime + millis;\r\n\r\n            runScheduledFunctions(endTime, tickDate);\r\n            currentTime = endTime;\r\n        };\r\n\r\n        self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {\r\n            var f;\r\n            if (typeof(funcToCall) === 'string') {\r\n                /* jshint evil: true */\r\n                f = function() { return eval(funcToCall); };\r\n                /* jshint evil: false */\r\n            } else {\r\n                f = funcToCall;\r\n            }\r\n\r\n            millis = millis || 0;\r\n            timeoutKey = timeoutKey || ++delayedFnCount;\r\n            runAtMillis = runAtMillis || (currentTime + millis);\r\n\r\n            var funcToSchedule = {\r\n                runAtMillis: runAtMillis,\r\n                funcToCall: f,\r\n                recurring: recurring,\r\n                params: params,\r\n                timeoutKey: timeoutKey,\r\n                millis: millis\r\n            };\r\n\r\n            if (runAtMillis in scheduledFunctions) {\r\n                scheduledFunctions[runAtMillis].push(funcToSchedule);\r\n            } else {\r\n                scheduledFunctions[runAtMillis] = [funcToSchedule];\r\n                scheduledLookup.push(runAtMillis);\r\n                scheduledLookup.sort(function (a, b) {\r\n                    return a - b;\r\n                });\r\n            }\r\n\r\n            return timeoutKey;\r\n        };\r\n\r\n        self.removeFunctionWithId = function(timeoutKey) {\r\n            for (var runAtMillis in scheduledFunctions) {\r\n                var funcs = scheduledFunctions[runAtMillis];\r\n                var i = indexOfFirstToPass(funcs, function (func) {\r\n                    return func.timeoutKey === timeoutKey;\r\n                });\r\n\r\n                if (i > -1) {\r\n                    if (funcs.length === 1) {\r\n                        delete scheduledFunctions[runAtMillis];\r\n                        deleteFromLookup(runAtMillis);\r\n                    } else {\r\n                        funcs.splice(i, 1);\r\n                    }\r\n\r\n                    // intervals get rescheduled when executed, so there's never more\r\n                    // than a single scheduled function with a given timeoutKey\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n\r\n        return self;\r\n\r\n        function indexOfFirstToPass(array, testFn) {\r\n            var index = -1;\r\n\r\n            for (var i = 0; i < array.length; ++i) {\r\n                if (testFn(array[i])) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return index;\r\n        }\r\n\r\n        function deleteFromLookup(key) {\r\n            var value = Number(key);\r\n            var i = indexOfFirstToPass(scheduledLookup, function (millis) {\r\n                return millis === value;\r\n            });\r\n\r\n            if (i > -1) {\r\n                scheduledLookup.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        function reschedule(scheduledFn) {\r\n            self.scheduleFunction(scheduledFn.funcToCall,\r\n                scheduledFn.millis,\r\n                scheduledFn.params,\r\n                true,\r\n                scheduledFn.timeoutKey,\r\n                scheduledFn.runAtMillis + scheduledFn.millis);\r\n        }\r\n\r\n        function forEachFunction(funcsToRun, callback) {\r\n            for (var i = 0; i < funcsToRun.length; ++i) {\r\n                callback(funcsToRun[i]);\r\n            }\r\n        }\r\n\r\n        function runScheduledFunctions(endTime, tickDate) {\r\n            tickDate = tickDate || function() {};\r\n            if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {\r\n                tickDate(endTime);\r\n                return;\r\n            }\r\n\r\n            do {\r\n                var newCurrentTime = scheduledLookup.shift();\r\n                tickDate(newCurrentTime - currentTime);\r\n\r\n                currentTime = newCurrentTime;\r\n\r\n                var funcsToRun = scheduledFunctions[currentTime];\r\n                delete scheduledFunctions[currentTime];\r\n\r\n                forEachFunction(funcsToRun, function(funcToRun) {\r\n                    if (funcToRun.recurring) {\r\n                        reschedule(funcToRun);\r\n                    }\r\n                });\r\n\r\n                forEachFunction(funcsToRun, function(funcToRun) {\r\n                    funcToRun.funcToCall.apply(null, funcToRun.params || []);\r\n                });\r\n            } while (scheduledLookup.length > 0 &&\r\n            // checking first if we're out of time prevents setTimeout(0)\r\n            // scheduled in a funcToRun from forcing an extra iteration\r\n            currentTime !== endTime  &&\r\n            scheduledLookup[0] <= endTime);\r\n        }\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.DelayedFunctionScheduler.[constructor].[return].reset","oldFunction":"function() {\r\n            currentTime = 0;\r\n            scheduledLookup = [];\r\n            scheduledFunctions = {};\r\n            delayedFnCount = 0;\r\n        }","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.DelayedFunctionScheduler.[constructor].[return]","key":"reset","isClass":false,"containerType":"class DelayedFunctionScheduler1 {\n    constructor ();\n    removeFunctionWithId: (timeoutKey: any) => void;\n    scheduleFunction: (funcToCall: string | (() => any), millis: number, params: any, recurring: any, timeoutKey: number, newCurrentTime: string) => number;\n    tick: (millis: number, tickDate: (arg0: void) => void) => void;\n}\n","containerDescription":"class jasmine.DelayedFunctionScheduler"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Clock.[constructor].[return].withMock","newFunction":"function(closure) {\r\n            this.install();\r\n            try {\r\n                closure();\r\n            } finally {\r\n                this.uninstall();\r\n            }\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Clock.[constructor]","oldFunction":"function Clock(global, delayedFunctionScheduler, mockDate) {\r\n        var self = this,\r\n            realTimingFunctions = {\r\n                setTimeout: global.setTimeout,\r\n                clearTimeout: global.clearTimeout,\r\n                setInterval: global.setInterval,\r\n                clearInterval: global.clearInterval\r\n            },\r\n            fakeTimingFunctions = {\r\n                setTimeout: setTimeout,\r\n                clearTimeout: clearTimeout,\r\n                setInterval: setInterval,\r\n                clearInterval: clearInterval\r\n            },\r\n            installed = false,\r\n            timer;\r\n\r\n\r\n        self.install = function() {\r\n            replace(global, fakeTimingFunctions);\r\n            timer = fakeTimingFunctions;\r\n            installed = true;\r\n\r\n            return self;\r\n        };\r\n\r\n        self.uninstall = function() {\r\n            delayedFunctionScheduler.reset();\r\n            mockDate.uninstall();\r\n            replace(global, realTimingFunctions);\r\n\r\n            timer = realTimingFunctions;\r\n            installed = false;\r\n        };\r\n\r\n        self.mockDate = function(initialDate) {\r\n            mockDate.install(initialDate);\r\n        };\r\n\r\n        self.setTimeout = function(fn, delay, params) {\r\n            if (legacyIE()) {\r\n                if (arguments.length > 2) {\r\n                    throw new Error('IE < 9 cannot support extra params to setTimeout without a polyfill');\r\n                }\r\n                return timer.setTimeout(fn, delay);\r\n            }\r\n            return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);\r\n        };\r\n\r\n        self.setInterval = function(fn, delay, params) {\r\n            if (legacyIE()) {\r\n                if (arguments.length > 2) {\r\n                    throw new Error('IE < 9 cannot support extra params to setInterval without a polyfill');\r\n                }\r\n                return timer.setInterval(fn, delay);\r\n            }\r\n            return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);\r\n        };\r\n\r\n        self.clearTimeout = function(id) {\r\n            return Function.prototype.call.apply(timer.clearTimeout, [global, id]);\r\n        };\r\n\r\n        self.clearInterval = function(id) {\r\n            return Function.prototype.call.apply(timer.clearInterval, [global, id]);\r\n        };\r\n\r\n        self.tick = function(millis) {\r\n            if (installed) {\r\n                mockDate.tick(millis);\r\n                delayedFunctionScheduler.tick(millis);\r\n            } else {\r\n                throw new Error('Mock clock is not installed, use jasmine.clock().install()');\r\n            }\r\n        };\r\n\r\n        return self;\r\n\r\n        function legacyIE() {\r\n            //if these methods are polyfilled, apply will be present\r\n            return !(realTimingFunctions.setTimeout || realTimingFunctions.setInterval).apply;\r\n        }\r\n\r\n        function replace(dest, source) {\r\n            for (var prop in source) {\r\n                dest[prop] = source[prop];\r\n            }\r\n        }\r\n\r\n        function setTimeout(fn, delay) {\r\n            return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));\r\n        }\r\n\r\n        function clearTimeout(id) {\r\n            return delayedFunctionScheduler.removeFunctionWithId(id);\r\n        }\r\n\r\n        function setInterval(fn, interval) {\r\n            return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);\r\n        }\r\n\r\n        function clearInterval(id) {\r\n            return delayedFunctionScheduler.removeFunctionWithId(id);\r\n        }\r\n\r\n        function argSlice(argsObj, n) {\r\n            return Array.prototype.slice.call(argsObj, n);\r\n        }\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Clock.[constructor].[return]","key":"withMock","newType":"(closure: () => void) => void","isAny":false,"isClass":false,"containerType":"class Clock1 {\n    constructor (global: Window | interface_470, delayedFunctionSchedulerFactory: () => jasmine.DelayedFunctionScheduler, mockDate: jasmine.MockDate);\n    clearInterval: (id: Window) => any;\n    clearTimeout: (id: Window) => any;\n    install: () => jasmine.Clock;\n    mockDate: (initialDate: {getTime: () => void}) => void;\n    setInterval: (fn: any, delay: any, params: any) => any;\n    setTimeout: (fn: any, delay: any, params: any) => any;\n    tick: (millis: any) => void;\n    uninstall: () => void;\n    withMock: (closure: () => void) => void;\n}\n","containerDescription":"class jasmine.Clock"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Spec.[constructor]","newFunction":"function Spec(attrs) {\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.id = attrs.id;\r\n        this.description = attrs.description || '';\r\n        this.queueableFn = attrs.queueableFn;\r\n        this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n        this.userContext = attrs.userContext || function() { return {}; };\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n        this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n        this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n        this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        if (!this.queueableFn.fn) {\r\n            this.pend();\r\n        }\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: [],\r\n            passedExpectations: [],\r\n            pendingReason: ''\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Spec.[constructor]","oldFunction":"function Spec(attrs) {\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.id = attrs.id;\r\n        this.description = attrs.description || '';\r\n        this.queueableFn = attrs.queueableFn;\r\n        this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n        this.userContext = attrs.userContext || function() { return {}; };\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n        this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n        this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n        this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n\r\n        if (!this.queueableFn.fn) {\r\n            this.pend();\r\n        }\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: [],\r\n            passedExpectations: [],\r\n            pendingReason: ''\r\n        };\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Spec.[constructor].[return]","key":"throwOnExpectationFailure","newType":"boolean","isAny":false,"isClass":false,"containerType":"class Spec1 {\n    constructor (attrs: interface_715);\n    static isPendingSpecException: (e: {toString: () => void}) => boolean;\n    static pendingSpecExceptionMessage: string;\n    addExpectationResult: (passed: boolean, data: interface_716, isError: boolean) => void;\n    beforeAndAfterFns: () => {afters: Array<any>, befores: Array<any>};\n    catchingExceptions: () => boolean;\n    description: string;\n    disable: () => void;\n    execute: (onComplete: () => void, enabled: boolean) => void;\n    expect: (actual: any) => any;\n    expectationFactory: any;\n    expectationResultFactory: () => void;\n    getFullName: () => any;\n    getResult: () => {status: string};\n    getSpecName: () => string;\n    id: any;\n    isExecutable: () => boolean;\n    onException: (e: {toString: () => void}) => void;\n    onStart: () => void;\n    pend: (message: any) => void;\n    queueRunnerFactory: () => void;\n    queueableFn: {fn: any};\n    result: interface_718;\n    resultCallback: () => void;\n    status: (enabled: boolean) => string;\n    throwOnExpectationFailure: boolean;\n    userContext: () => any;\n}\n","containerDescription":"class jasmine.Spec"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Spec.[constructor].[return].getResult","newFunction":"function() {\r\n        this.result.status = this.status();\r\n        return this.result;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Spec.[constructor]","oldFunction":"function Spec(attrs) {\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.id = attrs.id;\r\n        this.description = attrs.description || '';\r\n        this.queueableFn = attrs.queueableFn;\r\n        this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n        this.userContext = attrs.userContext || function() { return {}; };\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n        this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n        this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n        this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n\r\n        if (!this.queueableFn.fn) {\r\n            this.pend();\r\n        }\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: [],\r\n            passedExpectations: [],\r\n            pendingReason: ''\r\n        };\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Spec.[constructor].[return]","key":"getResult","newType":"() => {status: string}","isAny":false,"isClass":false,"containerType":"class Spec1 {\n    constructor (attrs: interface_715);\n    static isPendingSpecException: (e: {toString: () => void}) => boolean;\n    static pendingSpecExceptionMessage: string;\n    addExpectationResult: (passed: boolean, data: interface_716, isError: boolean) => void;\n    beforeAndAfterFns: () => {afters: Array<any>, befores: Array<any>};\n    catchingExceptions: () => boolean;\n    description: string;\n    disable: () => void;\n    execute: (onComplete: () => void, enabled: boolean) => void;\n    expect: (actual: any) => any;\n    expectationFactory: any;\n    expectationResultFactory: () => void;\n    getFullName: () => any;\n    getResult: () => {status: string};\n    getSpecName: () => string;\n    id: any;\n    isExecutable: () => boolean;\n    onException: (e: {toString: () => void}) => void;\n    onStart: () => void;\n    pend: (message: any) => void;\n    queueRunnerFactory: () => void;\n    queueableFn: {fn: any};\n    result: interface_718;\n    resultCallback: () => void;\n    status: (enabled: boolean) => string;\n    throwOnExpectationFailure: boolean;\n    userContext: () => any;\n}\n","containerDescription":"class jasmine.Spec"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.CallTracker.[constructor]","newFunction":"function CallTracker() {\r\n        var calls = [];\r\n        var opts = {};\r\n\r\n        function argCloner(context) {\r\n            var clonedArgs = [];\r\n            var argsAsArray = j$.util.argsToArray(context.args);\r\n            for(var i = 0; i < argsAsArray.length; i++) {\r\n                if(Object.prototype.toString.apply(argsAsArray[i]).match(/^\\[object/)) {\r\n                    clonedArgs.push(j$.util.clone(argsAsArray[i]));\r\n                } else {\r\n                    clonedArgs.push(argsAsArray[i]);\r\n                }\r\n            }\r\n            context.args = clonedArgs;\r\n        }\r\n\r\n        this.track = function(context) {\r\n            if(opts.cloneArgs) {\r\n                argCloner(context);\r\n            }\r\n            calls.push(context);\r\n        };\r\n\r\n        this.any = function() {\r\n            return !!calls.length;\r\n        };\r\n\r\n        this.count = function() {\r\n            return calls.length;\r\n        };\r\n\r\n        this.argsFor = function(index) {\r\n            var call = calls[index];\r\n            return call ? call.args : [];\r\n        };\r\n\r\n        this.all = function() {\r\n            return calls;\r\n        };\r\n\r\n        this.allArgs = function() {\r\n            var callArgs = [];\r\n            for(var i = 0; i < calls.length; i++){\r\n                callArgs.push(calls[i].args);\r\n            }\r\n\r\n            return callArgs;\r\n        };\r\n\r\n        this.first = function() {\r\n            return calls[0];\r\n        };\r\n\r\n        this.mostRecent = function() {\r\n            return calls[calls.length - 1];\r\n        };\r\n\r\n        this.reset = function() {\r\n            calls = [];\r\n        };\r\n\r\n        this.saveArgumentsByValue = function() {\r\n            opts.cloneArgs = true;\r\n        };\r\n\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.CallTracker.[constructor]","oldFunction":"function CallTracker() {\r\n        var calls = [];\r\n\r\n        this.track = function(context) {\r\n            calls.push(context);\r\n        };\r\n\r\n        this.any = function() {\r\n            return !!calls.length;\r\n        };\r\n\r\n        this.count = function() {\r\n            return calls.length;\r\n        };\r\n\r\n        this.argsFor = function(index) {\r\n            var call = calls[index];\r\n            return call ? call.args : [];\r\n        };\r\n\r\n        this.all = function() {\r\n            return calls;\r\n        };\r\n\r\n        this.allArgs = function() {\r\n            var callArgs = [];\r\n            for(var i = 0; i < calls.length; i++){\r\n                callArgs.push(calls[i].args);\r\n            }\r\n\r\n            return callArgs;\r\n        };\r\n\r\n        this.first = function() {\r\n            return calls[0];\r\n        };\r\n\r\n        this.mostRecent = function() {\r\n            return calls[calls.length - 1];\r\n        };\r\n\r\n        this.reset = function() {\r\n            calls = [];\r\n        };\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.CallTracker.[constructor].[return]","key":"saveArgumentsByValue","newType":"() => void","isAny":false,"isClass":false,"containerType":"class CallTracker1 {\n    constructor ();\n    all: () => Array<interface_679>;\n    allArgs: () => Array<any>;\n    any: () => boolean;\n    argsFor: (index: number) => Array<any>;\n    count: () => number;\n    first: () => interface_679;\n    mostRecent: () => interface_679;\n    reset: () => void;\n    saveArgumentsByValue: () => void;\n    track: (context: {args: any[]}) => void;\n}\n","containerDescription":"class jasmine.CallTracker"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.QueueRunner.[constructor]","newFunction":"function QueueRunner(attrs) {\r\n        this.queueableFns = attrs.queueableFns || [];\r\n        this.onComplete = attrs.onComplete || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.onException = attrs.onException || function() {};\r\n        this.catchException = attrs.catchException || function() { return true; };\r\n        this.userContext = attrs.userContext || {};\r\n        this.timeout = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};\r\n        this.fail = attrs.fail || function() {};\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.QueueRunner.[constructor]","oldFunction":"function QueueRunner(attrs) {\r\n        this.queueableFns = attrs.queueableFns || [];\r\n        this.onComplete = attrs.onComplete || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.onException = attrs.onException || function() {};\r\n        this.catchException = attrs.catchException || function() { return true; };\r\n        this.userContext = attrs.userContext || {};\r\n        this.timer = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};\r\n        this.fail = attrs.fail || function() {};\r\n    }","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.QueueRunner.[constructor].[return]","key":"timer","isClass":false,"containerType":"class QueueRunner1 {\n    constructor (attrs: interface_704);\n    catchException: () => boolean;\n    clearStack: (fn: () => void) => void;\n    execute: () => void;\n    fail: () => void;\n    onComplete: () => void;\n    onException: () => void;\n    queueableFns: Array<any>;\n    run: (queueableFns: interface_633, recursiveIndex: number) => void;\n    timeout: interface_706;\n    userContext: any;\n}\n","containerDescription":"class jasmine.QueueRunner"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.QueueRunner.[constructor]","newFunction":"function QueueRunner(attrs) {\r\n        this.queueableFns = attrs.queueableFns || [];\r\n        this.onComplete = attrs.onComplete || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.onException = attrs.onException || function() {};\r\n        this.catchException = attrs.catchException || function() { return true; };\r\n        this.userContext = attrs.userContext || {};\r\n        this.timeout = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};\r\n        this.fail = attrs.fail || function() {};\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.QueueRunner.[constructor]","oldFunction":"function QueueRunner(attrs) {\r\n        this.queueableFns = attrs.queueableFns || [];\r\n        this.onComplete = attrs.onComplete || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.onException = attrs.onException || function() {};\r\n        this.catchException = attrs.catchException || function() { return true; };\r\n        this.userContext = attrs.userContext || {};\r\n        this.timer = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};\r\n        this.fail = attrs.fail || function() {};\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.QueueRunner.[constructor].[return]","key":"timeout","newType":"interface interface_706 {\n    clearTimeout: (handle: number) => void;\n    setTimeout: (handler: any, timeout: any, args: any) => number;\n}\n\n","isAny":false,"isClass":false,"containerType":"class QueueRunner1 {\n    constructor (attrs: interface_704);\n    catchException: () => boolean;\n    clearStack: (fn: () => void) => void;\n    execute: () => void;\n    fail: () => void;\n    onComplete: () => void;\n    onException: () => void;\n    queueableFns: Array<any>;\n    run: (queueableFns: interface_633, recursiveIndex: number) => void;\n    timeout: interface_706;\n    userContext: any;\n}\n","containerDescription":"class jasmine.QueueRunner"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Env.[constructor].[return].seed","newFunction":"function(value) {\r\n            if (value) {\r\n                seed = value;\r\n            }\r\n            return seed;\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Env.[constructor]","oldFunction":"function Env(options) {\r\n        options = options || {};\r\n\r\n        var self = this;\r\n        var global = options.global || j$.getGlobal();\r\n\r\n        var totalSpecsDefined = 0;\r\n\r\n        var catchExceptions = true;\r\n\r\n        var realSetTimeout = j$.getGlobal().setTimeout;\r\n        var realClearTimeout = j$.getGlobal().clearTimeout;\r\n        this.clock = new j$.Clock(global, new j$.DelayedFunctionScheduler(), new j$.MockDate(global));\r\n\r\n        var runnableLookupTable = {};\r\n        var runnableResources = {};\r\n\r\n        var currentSpec = null;\r\n        var currentlyExecutingSuites = [];\r\n        var currentDeclarationSuite = null;\r\n\r\n        var currentSuite = function() {\r\n            return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\r\n        };\r\n\r\n        var currentRunnable = function() {\r\n            return currentSpec || currentSuite();\r\n        };\r\n\r\n        var reporter = new j$.ReportDispatcher([\r\n            'jasmineStarted',\r\n            'jasmineDone',\r\n            'suiteStarted',\r\n            'suiteDone',\r\n            'specStarted',\r\n            'specDone'\r\n        ]);\r\n\r\n        this.specFilter = function() {\r\n            return true;\r\n        };\r\n\r\n        this.addCustomEqualityTester = function(tester) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Custom Equalities must be added in a before function or a spec');\r\n            }\r\n            runnableResources[currentRunnable().id].customEqualityTesters.push(tester);\r\n        };\r\n\r\n        this.addMatchers = function(matchersToAdd) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Matchers must be added in a before function or a spec');\r\n            }\r\n            var customMatchers = runnableResources[currentRunnable().id].customMatchers;\r\n            for (var matcherName in matchersToAdd) {\r\n                customMatchers[matcherName] = matchersToAdd[matcherName];\r\n            }\r\n        };\r\n\r\n        j$.Expectation.addCoreMatchers(j$.matchers);\r\n\r\n        var nextSpecId = 0;\r\n        var getNextSpecId = function() {\r\n            return 'spec' + nextSpecId++;\r\n        };\r\n\r\n        var nextSuiteId = 0;\r\n        var getNextSuiteId = function() {\r\n            return 'suite' + nextSuiteId++;\r\n        };\r\n\r\n        var expectationFactory = function(actual, spec) {\r\n            return j$.Expectation.Factory({\r\n                util: j$.matchersUtil,\r\n                customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\r\n                customMatchers: runnableResources[spec.id].customMatchers,\r\n                actual: actual,\r\n                addExpectationResult: addExpectationResult\r\n            });\r\n\r\n            function addExpectationResult(passed, result) {\r\n                return spec.addExpectationResult(passed, result);\r\n            }\r\n        };\r\n\r\n        var defaultResourcesForRunnable = function(id, parentRunnableId) {\r\n            var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};\r\n\r\n            if(runnableResources[parentRunnableId]){\r\n                resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);\r\n                resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);\r\n            }\r\n\r\n            runnableResources[id] = resources;\r\n        };\r\n\r\n        var clearResourcesForRunnable = function(id) {\r\n            spyRegistry.clearSpies();\r\n            delete runnableResources[id];\r\n        };\r\n\r\n        var beforeAndAfterFns = function(suite, runnablesExplictlySet) {\r\n            return function() {\r\n                var befores = [],\r\n                    afters = [],\r\n                    beforeAlls = [],\r\n                    afterAlls = [];\r\n\r\n                while(suite) {\r\n                    befores = befores.concat(suite.beforeFns);\r\n                    afters = afters.concat(suite.afterFns);\r\n\r\n                    if (runnablesExplictlySet()) {\r\n                        beforeAlls = beforeAlls.concat(suite.beforeAllFns);\r\n                        afterAlls = afterAlls.concat(suite.afterAllFns);\r\n                    }\r\n\r\n                    suite = suite.parentSuite;\r\n                }\r\n                return {\r\n                    befores: beforeAlls.reverse().concat(befores.reverse()),\r\n                    afters: afters.concat(afterAlls)\r\n                };\r\n            };\r\n        };\r\n\r\n        var getSpecName = function(spec, suite) {\r\n            return suite.getFullName() + ' ' + spec.description;\r\n        };\r\n\r\n        // TODO: we may just be able to pass in the fn instead of wrapping here\r\n        var buildExpectationResult = j$.buildExpectationResult,\r\n            exceptionFormatter = new j$.ExceptionFormatter(),\r\n            expectationResultFactory = function(attrs) {\r\n                attrs.messageFormatter = exceptionFormatter.message;\r\n                attrs.stackFormatter = exceptionFormatter.stack;\r\n\r\n                return buildExpectationResult(attrs);\r\n            };\r\n\r\n        // TODO: fix this naming, and here's where the value comes in\r\n        this.catchExceptions = function(value) {\r\n            catchExceptions = !!value;\r\n            return catchExceptions;\r\n        };\r\n\r\n        this.catchingExceptions = function() {\r\n            return catchExceptions;\r\n        };\r\n\r\n        var maximumSpecCallbackDepth = 20;\r\n        var currentSpecCallbackDepth = 0;\r\n\r\n        function clearStack(fn) {\r\n            currentSpecCallbackDepth++;\r\n            if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {\r\n                currentSpecCallbackDepth = 0;\r\n                realSetTimeout(fn, 0);\r\n            } else {\r\n                fn();\r\n            }\r\n        }\r\n\r\n        var catchException = function(e) {\r\n            return j$.Spec.isPendingSpecException(e) || catchExceptions;\r\n        };\r\n\r\n        var queueRunnerFactory = function(options) {\r\n            options.catchException = catchException;\r\n            options.clearStack = options.clearStack || clearStack;\r\n            options.timer = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\r\n            options.fail = self.fail;\r\n\r\n            new j$.QueueRunner(options).execute();\r\n        };\r\n\r\n        var topSuite = new j$.Suite({\r\n            env: this,\r\n            id: getNextSuiteId(),\r\n            description: 'Jasmine__TopLevel__Suite',\r\n            queueRunner: queueRunnerFactory\r\n        });\r\n        runnableLookupTable[topSuite.id] = topSuite;\r\n        defaultResourcesForRunnable(topSuite.id);\r\n        currentDeclarationSuite = topSuite;\r\n\r\n        this.topSuite = function() {\r\n            return topSuite;\r\n        };\r\n\r\n        this.execute = function(runnablesToRun) {\r\n            if(runnablesToRun) {\r\n                runnablesExplictlySet = true;\r\n            } else if (focusedRunnables.length) {\r\n                runnablesExplictlySet = true;\r\n                runnablesToRun = focusedRunnables;\r\n            } else {\r\n                runnablesToRun = [topSuite.id];\r\n            }\r\n\r\n            var allFns = [];\r\n            for(var i = 0; i < runnablesToRun.length; i++) {\r\n                var runnable = runnableLookupTable[runnablesToRun[i]];\r\n                allFns.push((function(runnable) { return { fn: function(done) { runnable.execute(done); } }; })(runnable));\r\n            }\r\n\r\n            reporter.jasmineStarted({\r\n                totalSpecsDefined: totalSpecsDefined\r\n            });\r\n\r\n            queueRunnerFactory({queueableFns: allFns, onComplete: reporter.jasmineDone});\r\n        };\r\n\r\n        this.addReporter = function(reporterToAdd) {\r\n            reporter.addReporter(reporterToAdd);\r\n        };\r\n\r\n        var spyRegistry = new j$.SpyRegistry({currentSpies: function() {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Spies must be created in a before function or a spec');\r\n            }\r\n            return runnableResources[currentRunnable().id].spies;\r\n        }});\r\n\r\n        this.spyOn = function() {\r\n            return spyRegistry.spyOn.apply(spyRegistry, arguments);\r\n        };\r\n\r\n        var suiteFactory = function(description) {\r\n            var suite = new j$.Suite({\r\n                env: self,\r\n                id: getNextSuiteId(),\r\n                description: description,\r\n                parentSuite: currentDeclarationSuite,\r\n                queueRunner: queueRunnerFactory,\r\n                onStart: suiteStarted,\r\n                expectationFactory: expectationFactory,\r\n                expectationResultFactory: expectationResultFactory,\r\n                runnablesExplictlySetGetter: runnablesExplictlySetGetter,\r\n                resultCallback: function(attrs) {\r\n                    if (!suite.disabled) {\r\n                        clearResourcesForRunnable(suite.id);\r\n                    }\r\n                    currentlyExecutingSuites.pop();\r\n                    reporter.suiteDone(attrs);\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[suite.id] = suite;\r\n            return suite;\r\n\r\n            function suiteStarted(suite) {\r\n                currentlyExecutingSuites.push(suite);\r\n                defaultResourcesForRunnable(suite.id, suite.parentSuite.id);\r\n                reporter.suiteStarted(suite.result);\r\n            }\r\n        };\r\n\r\n        this.describe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            addSpecsToSuite(suite, specDefinitions);\r\n            return suite;\r\n        };\r\n\r\n        this.xdescribe = function(description, specDefinitions) {\r\n            var suite = this.describe(description, specDefinitions);\r\n            suite.disable();\r\n            return suite;\r\n        };\r\n\r\n        var focusedRunnables = [];\r\n\r\n        this.fdescribe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            suite.isFocused = true;\r\n\r\n            focusedRunnables.push(suite.id);\r\n            unfocusAncestor();\r\n            addSpecsToSuite(suite, specDefinitions);\r\n\r\n            return suite;\r\n        };\r\n\r\n        function addSpecsToSuite(suite, specDefinitions) {\r\n            var parentSuite = currentDeclarationSuite;\r\n            parentSuite.addChild(suite);\r\n            currentDeclarationSuite = suite;\r\n\r\n            var declarationError = null;\r\n            try {\r\n                specDefinitions.call(suite);\r\n            } catch (e) {\r\n                declarationError = e;\r\n            }\r\n\r\n            if (declarationError) {\r\n                self.it('encountered a declaration exception', function() {\r\n                    throw declarationError;\r\n                });\r\n            }\r\n\r\n            currentDeclarationSuite = parentSuite;\r\n        }\r\n\r\n        function findFocusedAncestor(suite) {\r\n            while (suite) {\r\n                if (suite.isFocused) {\r\n                    return suite.id;\r\n                }\r\n                suite = suite.parentSuite;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        function unfocusAncestor() {\r\n            var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\r\n            if (focusedAncestor) {\r\n                for (var i = 0; i < focusedRunnables.length; i++) {\r\n                    if (focusedRunnables[i] === focusedAncestor) {\r\n                        focusedRunnables.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var runnablesExplictlySet = false;\r\n\r\n        var runnablesExplictlySetGetter = function(){\r\n            return runnablesExplictlySet;\r\n        };\r\n\r\n        var specFactory = function(description, fn, suite, timeout) {\r\n            totalSpecsDefined++;\r\n            var spec = new j$.Spec({\r\n                id: getNextSpecId(),\r\n                beforeAndAfterFns: beforeAndAfterFns(suite, runnablesExplictlySetGetter),\r\n                expectationFactory: expectationFactory,\r\n                resultCallback: specResultCallback,\r\n                getSpecName: function(spec) {\r\n                    return getSpecName(spec, suite);\r\n                },\r\n                onStart: specStarted,\r\n                description: description,\r\n                expectationResultFactory: expectationResultFactory,\r\n                queueRunnerFactory: queueRunnerFactory,\r\n                userContext: function() { return suite.clonedSharedUserContext(); },\r\n                queueableFn: {\r\n                    fn: fn,\r\n                    timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[spec.id] = spec;\r\n\r\n            if (!self.specFilter(spec)) {\r\n                spec.disable();\r\n            }\r\n\r\n            return spec;\r\n\r\n            function specResultCallback(result) {\r\n                clearResourcesForRunnable(spec.id);\r\n                currentSpec = null;\r\n                reporter.specDone(result);\r\n            }\r\n\r\n            function specStarted(spec) {\r\n                currentSpec = spec;\r\n                defaultResourcesForRunnable(spec.id, suite.id);\r\n                reporter.specStarted(spec.result);\r\n            }\r\n        };\r\n\r\n        this.it = function(description, fn, timeout) {\r\n            var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\r\n            currentDeclarationSuite.addChild(spec);\r\n            return spec;\r\n        };\r\n\r\n        this.xit = function() {\r\n            var spec = this.it.apply(this, arguments);\r\n            spec.pend();\r\n            return spec;\r\n        };\r\n\r\n        this.fit = function(){\r\n            var spec = this.it.apply(this, arguments);\r\n\r\n            focusedRunnables.push(spec.id);\r\n            unfocusAncestor();\r\n            return spec;\r\n        };\r\n\r\n        this.expect = function(actual) {\r\n            if (!currentRunnable()) {\r\n                throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\r\n            }\r\n\r\n            return currentRunnable().expect(actual);\r\n        };\r\n\r\n        this.beforeEach = function(beforeEachFunction, timeout) {\r\n            currentDeclarationSuite.beforeEach({\r\n                fn: beforeEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.beforeAll = function(beforeAllFunction, timeout) {\r\n            currentDeclarationSuite.beforeAll({\r\n                fn: beforeAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterEach = function(afterEachFunction, timeout) {\r\n            currentDeclarationSuite.afterEach({\r\n                fn: afterEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterAll = function(afterAllFunction, timeout) {\r\n            currentDeclarationSuite.afterAll({\r\n                fn: afterAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.pending = function(message) {\r\n            var fullMessage = j$.Spec.pendingSpecExceptionMessage;\r\n            if(message) {\r\n                fullMessage += message;\r\n            }\r\n            throw fullMessage;\r\n        };\r\n\r\n        this.fail = function(error) {\r\n            var message = 'Failed';\r\n            if (error) {\r\n                message += ': ';\r\n                message += error.message || error;\r\n            }\r\n\r\n            currentRunnable().addExpectationResult(false, {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                message: message,\r\n                error: error && error.message ? error : null\r\n            });\r\n        };\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Env.[constructor].[return]","key":"seed","newType":"(value: any) => any","isAny":false,"isClass":false,"containerType":"class Env1 {\n    constructor (options: {global: any});\n    addCustomEqualityTester: (tester: any) => void;\n    addMatchers: (matchersToAdd: any) => void;\n    addReporter: (reporterToAdd: any) => void;\n    afterAll: (afterAllFunction: any, timeout: any) => void;\n    afterEach: (afterEachFunction: any, timeout: any) => void;\n    allowRespy: (allow: any) => void;\n    beforeAll: (beforeAllFunction: any, timeout: any) => void;\n    beforeEach: (beforeEachFunction: any, timeout: any) => void;\n    catchExceptions: (value: any) => boolean;\n    catchingExceptions: () => boolean;\n    clock: jasmine.Clock;\n    describe: (description: any, specDefinitions: {call: (arg0: void) => void, length: number}) => jasmine.Suite;\n    execute: (runnablesToRun: string[]) => void;\n    expect: (actual: any) => any;\n    fail: (error: {message: any}) => void;\n    fdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite | {id: any, isFocused: boolean};\n    fit: (description: any, fn: any, timeout: any) => {disabled: boolean} | jasmine.Spec;\n    it: (description: string, fn: () => void, timeout: any) => {disabled: boolean} | jasmine.Spec;\n    pending: (message: string) => void;\n    provideFallbackReporter: (reporterToAdd: any) => void;\n    randomTests: () => boolean;\n    randomizeTests: (value: any) => void;\n    seed: (value: any) => any;\n    specFilter: (spec: jasmine.Spec) => boolean;\n    spyOn: () => interface_490;\n    throwOnExpectationFailure: (value: any) => void;\n    throwingExpectationFailures: () => boolean;\n    topSuite: () => jasmine.Suite;\n    xdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite;\n    xit: () => {pend: (arg0: void) => void};\n}\n","containerDescription":"class jasmine.Env"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Env.[constructor].[return].provideFallbackReporter","newFunction":"function(reporterToAdd) {\r\n            reporter.provideFallbackReporter(reporterToAdd);\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Env.[constructor]","oldFunction":"function Env(options) {\r\n        options = options || {};\r\n\r\n        var self = this;\r\n        var global = options.global || j$.getGlobal();\r\n\r\n        var totalSpecsDefined = 0;\r\n\r\n        var catchExceptions = true;\r\n\r\n        var realSetTimeout = j$.getGlobal().setTimeout;\r\n        var realClearTimeout = j$.getGlobal().clearTimeout;\r\n        this.clock = new j$.Clock(global, new j$.DelayedFunctionScheduler(), new j$.MockDate(global));\r\n\r\n        var runnableLookupTable = {};\r\n        var runnableResources = {};\r\n\r\n        var currentSpec = null;\r\n        var currentlyExecutingSuites = [];\r\n        var currentDeclarationSuite = null;\r\n\r\n        var currentSuite = function() {\r\n            return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\r\n        };\r\n\r\n        var currentRunnable = function() {\r\n            return currentSpec || currentSuite();\r\n        };\r\n\r\n        var reporter = new j$.ReportDispatcher([\r\n            'jasmineStarted',\r\n            'jasmineDone',\r\n            'suiteStarted',\r\n            'suiteDone',\r\n            'specStarted',\r\n            'specDone'\r\n        ]);\r\n\r\n        this.specFilter = function() {\r\n            return true;\r\n        };\r\n\r\n        this.addCustomEqualityTester = function(tester) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Custom Equalities must be added in a before function or a spec');\r\n            }\r\n            runnableResources[currentRunnable().id].customEqualityTesters.push(tester);\r\n        };\r\n\r\n        this.addMatchers = function(matchersToAdd) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Matchers must be added in a before function or a spec');\r\n            }\r\n            var customMatchers = runnableResources[currentRunnable().id].customMatchers;\r\n            for (var matcherName in matchersToAdd) {\r\n                customMatchers[matcherName] = matchersToAdd[matcherName];\r\n            }\r\n        };\r\n\r\n        j$.Expectation.addCoreMatchers(j$.matchers);\r\n\r\n        var nextSpecId = 0;\r\n        var getNextSpecId = function() {\r\n            return 'spec' + nextSpecId++;\r\n        };\r\n\r\n        var nextSuiteId = 0;\r\n        var getNextSuiteId = function() {\r\n            return 'suite' + nextSuiteId++;\r\n        };\r\n\r\n        var expectationFactory = function(actual, spec) {\r\n            return j$.Expectation.Factory({\r\n                util: j$.matchersUtil,\r\n                customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\r\n                customMatchers: runnableResources[spec.id].customMatchers,\r\n                actual: actual,\r\n                addExpectationResult: addExpectationResult\r\n            });\r\n\r\n            function addExpectationResult(passed, result) {\r\n                return spec.addExpectationResult(passed, result);\r\n            }\r\n        };\r\n\r\n        var defaultResourcesForRunnable = function(id, parentRunnableId) {\r\n            var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};\r\n\r\n            if(runnableResources[parentRunnableId]){\r\n                resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);\r\n                resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);\r\n            }\r\n\r\n            runnableResources[id] = resources;\r\n        };\r\n\r\n        var clearResourcesForRunnable = function(id) {\r\n            spyRegistry.clearSpies();\r\n            delete runnableResources[id];\r\n        };\r\n\r\n        var beforeAndAfterFns = function(suite, runnablesExplictlySet) {\r\n            return function() {\r\n                var befores = [],\r\n                    afters = [],\r\n                    beforeAlls = [],\r\n                    afterAlls = [];\r\n\r\n                while(suite) {\r\n                    befores = befores.concat(suite.beforeFns);\r\n                    afters = afters.concat(suite.afterFns);\r\n\r\n                    if (runnablesExplictlySet()) {\r\n                        beforeAlls = beforeAlls.concat(suite.beforeAllFns);\r\n                        afterAlls = afterAlls.concat(suite.afterAllFns);\r\n                    }\r\n\r\n                    suite = suite.parentSuite;\r\n                }\r\n                return {\r\n                    befores: beforeAlls.reverse().concat(befores.reverse()),\r\n                    afters: afters.concat(afterAlls)\r\n                };\r\n            };\r\n        };\r\n\r\n        var getSpecName = function(spec, suite) {\r\n            return suite.getFullName() + ' ' + spec.description;\r\n        };\r\n\r\n        // TODO: we may just be able to pass in the fn instead of wrapping here\r\n        var buildExpectationResult = j$.buildExpectationResult,\r\n            exceptionFormatter = new j$.ExceptionFormatter(),\r\n            expectationResultFactory = function(attrs) {\r\n                attrs.messageFormatter = exceptionFormatter.message;\r\n                attrs.stackFormatter = exceptionFormatter.stack;\r\n\r\n                return buildExpectationResult(attrs);\r\n            };\r\n\r\n        // TODO: fix this naming, and here's where the value comes in\r\n        this.catchExceptions = function(value) {\r\n            catchExceptions = !!value;\r\n            return catchExceptions;\r\n        };\r\n\r\n        this.catchingExceptions = function() {\r\n            return catchExceptions;\r\n        };\r\n\r\n        var maximumSpecCallbackDepth = 20;\r\n        var currentSpecCallbackDepth = 0;\r\n\r\n        function clearStack(fn) {\r\n            currentSpecCallbackDepth++;\r\n            if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {\r\n                currentSpecCallbackDepth = 0;\r\n                realSetTimeout(fn, 0);\r\n            } else {\r\n                fn();\r\n            }\r\n        }\r\n\r\n        var catchException = function(e) {\r\n            return j$.Spec.isPendingSpecException(e) || catchExceptions;\r\n        };\r\n\r\n        var queueRunnerFactory = function(options) {\r\n            options.catchException = catchException;\r\n            options.clearStack = options.clearStack || clearStack;\r\n            options.timer = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\r\n            options.fail = self.fail;\r\n\r\n            new j$.QueueRunner(options).execute();\r\n        };\r\n\r\n        var topSuite = new j$.Suite({\r\n            env: this,\r\n            id: getNextSuiteId(),\r\n            description: 'Jasmine__TopLevel__Suite',\r\n            queueRunner: queueRunnerFactory\r\n        });\r\n        runnableLookupTable[topSuite.id] = topSuite;\r\n        defaultResourcesForRunnable(topSuite.id);\r\n        currentDeclarationSuite = topSuite;\r\n\r\n        this.topSuite = function() {\r\n            return topSuite;\r\n        };\r\n\r\n        this.execute = function(runnablesToRun) {\r\n            if(runnablesToRun) {\r\n                runnablesExplictlySet = true;\r\n            } else if (focusedRunnables.length) {\r\n                runnablesExplictlySet = true;\r\n                runnablesToRun = focusedRunnables;\r\n            } else {\r\n                runnablesToRun = [topSuite.id];\r\n            }\r\n\r\n            var allFns = [];\r\n            for(var i = 0; i < runnablesToRun.length; i++) {\r\n                var runnable = runnableLookupTable[runnablesToRun[i]];\r\n                allFns.push((function(runnable) { return { fn: function(done) { runnable.execute(done); } }; })(runnable));\r\n            }\r\n\r\n            reporter.jasmineStarted({\r\n                totalSpecsDefined: totalSpecsDefined\r\n            });\r\n\r\n            queueRunnerFactory({queueableFns: allFns, onComplete: reporter.jasmineDone});\r\n        };\r\n\r\n        this.addReporter = function(reporterToAdd) {\r\n            reporter.addReporter(reporterToAdd);\r\n        };\r\n\r\n        var spyRegistry = new j$.SpyRegistry({currentSpies: function() {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Spies must be created in a before function or a spec');\r\n            }\r\n            return runnableResources[currentRunnable().id].spies;\r\n        }});\r\n\r\n        this.spyOn = function() {\r\n            return spyRegistry.spyOn.apply(spyRegistry, arguments);\r\n        };\r\n\r\n        var suiteFactory = function(description) {\r\n            var suite = new j$.Suite({\r\n                env: self,\r\n                id: getNextSuiteId(),\r\n                description: description,\r\n                parentSuite: currentDeclarationSuite,\r\n                queueRunner: queueRunnerFactory,\r\n                onStart: suiteStarted,\r\n                expectationFactory: expectationFactory,\r\n                expectationResultFactory: expectationResultFactory,\r\n                runnablesExplictlySetGetter: runnablesExplictlySetGetter,\r\n                resultCallback: function(attrs) {\r\n                    if (!suite.disabled) {\r\n                        clearResourcesForRunnable(suite.id);\r\n                    }\r\n                    currentlyExecutingSuites.pop();\r\n                    reporter.suiteDone(attrs);\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[suite.id] = suite;\r\n            return suite;\r\n\r\n            function suiteStarted(suite) {\r\n                currentlyExecutingSuites.push(suite);\r\n                defaultResourcesForRunnable(suite.id, suite.parentSuite.id);\r\n                reporter.suiteStarted(suite.result);\r\n            }\r\n        };\r\n\r\n        this.describe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            addSpecsToSuite(suite, specDefinitions);\r\n            return suite;\r\n        };\r\n\r\n        this.xdescribe = function(description, specDefinitions) {\r\n            var suite = this.describe(description, specDefinitions);\r\n            suite.disable();\r\n            return suite;\r\n        };\r\n\r\n        var focusedRunnables = [];\r\n\r\n        this.fdescribe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            suite.isFocused = true;\r\n\r\n            focusedRunnables.push(suite.id);\r\n            unfocusAncestor();\r\n            addSpecsToSuite(suite, specDefinitions);\r\n\r\n            return suite;\r\n        };\r\n\r\n        function addSpecsToSuite(suite, specDefinitions) {\r\n            var parentSuite = currentDeclarationSuite;\r\n            parentSuite.addChild(suite);\r\n            currentDeclarationSuite = suite;\r\n\r\n            var declarationError = null;\r\n            try {\r\n                specDefinitions.call(suite);\r\n            } catch (e) {\r\n                declarationError = e;\r\n            }\r\n\r\n            if (declarationError) {\r\n                self.it('encountered a declaration exception', function() {\r\n                    throw declarationError;\r\n                });\r\n            }\r\n\r\n            currentDeclarationSuite = parentSuite;\r\n        }\r\n\r\n        function findFocusedAncestor(suite) {\r\n            while (suite) {\r\n                if (suite.isFocused) {\r\n                    return suite.id;\r\n                }\r\n                suite = suite.parentSuite;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        function unfocusAncestor() {\r\n            var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\r\n            if (focusedAncestor) {\r\n                for (var i = 0; i < focusedRunnables.length; i++) {\r\n                    if (focusedRunnables[i] === focusedAncestor) {\r\n                        focusedRunnables.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var runnablesExplictlySet = false;\r\n\r\n        var runnablesExplictlySetGetter = function(){\r\n            return runnablesExplictlySet;\r\n        };\r\n\r\n        var specFactory = function(description, fn, suite, timeout) {\r\n            totalSpecsDefined++;\r\n            var spec = new j$.Spec({\r\n                id: getNextSpecId(),\r\n                beforeAndAfterFns: beforeAndAfterFns(suite, runnablesExplictlySetGetter),\r\n                expectationFactory: expectationFactory,\r\n                resultCallback: specResultCallback,\r\n                getSpecName: function(spec) {\r\n                    return getSpecName(spec, suite);\r\n                },\r\n                onStart: specStarted,\r\n                description: description,\r\n                expectationResultFactory: expectationResultFactory,\r\n                queueRunnerFactory: queueRunnerFactory,\r\n                userContext: function() { return suite.clonedSharedUserContext(); },\r\n                queueableFn: {\r\n                    fn: fn,\r\n                    timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[spec.id] = spec;\r\n\r\n            if (!self.specFilter(spec)) {\r\n                spec.disable();\r\n            }\r\n\r\n            return spec;\r\n\r\n            function specResultCallback(result) {\r\n                clearResourcesForRunnable(spec.id);\r\n                currentSpec = null;\r\n                reporter.specDone(result);\r\n            }\r\n\r\n            function specStarted(spec) {\r\n                currentSpec = spec;\r\n                defaultResourcesForRunnable(spec.id, suite.id);\r\n                reporter.specStarted(spec.result);\r\n            }\r\n        };\r\n\r\n        this.it = function(description, fn, timeout) {\r\n            var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\r\n            currentDeclarationSuite.addChild(spec);\r\n            return spec;\r\n        };\r\n\r\n        this.xit = function() {\r\n            var spec = this.it.apply(this, arguments);\r\n            spec.pend();\r\n            return spec;\r\n        };\r\n\r\n        this.fit = function(){\r\n            var spec = this.it.apply(this, arguments);\r\n\r\n            focusedRunnables.push(spec.id);\r\n            unfocusAncestor();\r\n            return spec;\r\n        };\r\n\r\n        this.expect = function(actual) {\r\n            if (!currentRunnable()) {\r\n                throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\r\n            }\r\n\r\n            return currentRunnable().expect(actual);\r\n        };\r\n\r\n        this.beforeEach = function(beforeEachFunction, timeout) {\r\n            currentDeclarationSuite.beforeEach({\r\n                fn: beforeEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.beforeAll = function(beforeAllFunction, timeout) {\r\n            currentDeclarationSuite.beforeAll({\r\n                fn: beforeAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterEach = function(afterEachFunction, timeout) {\r\n            currentDeclarationSuite.afterEach({\r\n                fn: afterEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterAll = function(afterAllFunction, timeout) {\r\n            currentDeclarationSuite.afterAll({\r\n                fn: afterAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.pending = function(message) {\r\n            var fullMessage = j$.Spec.pendingSpecExceptionMessage;\r\n            if(message) {\r\n                fullMessage += message;\r\n            }\r\n            throw fullMessage;\r\n        };\r\n\r\n        this.fail = function(error) {\r\n            var message = 'Failed';\r\n            if (error) {\r\n                message += ': ';\r\n                message += error.message || error;\r\n            }\r\n\r\n            currentRunnable().addExpectationResult(false, {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                message: message,\r\n                error: error && error.message ? error : null\r\n            });\r\n        };\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Env.[constructor].[return]","key":"provideFallbackReporter","newType":"(reporterToAdd: any) => void","isAny":false,"isClass":false,"containerType":"class Env1 {\n    constructor (options: {global: any});\n    addCustomEqualityTester: (tester: any) => void;\n    addMatchers: (matchersToAdd: any) => void;\n    addReporter: (reporterToAdd: any) => void;\n    afterAll: (afterAllFunction: any, timeout: any) => void;\n    afterEach: (afterEachFunction: any, timeout: any) => void;\n    allowRespy: (allow: any) => void;\n    beforeAll: (beforeAllFunction: any, timeout: any) => void;\n    beforeEach: (beforeEachFunction: any, timeout: any) => void;\n    catchExceptions: (value: any) => boolean;\n    catchingExceptions: () => boolean;\n    clock: jasmine.Clock;\n    describe: (description: any, specDefinitions: {call: (arg0: void) => void, length: number}) => jasmine.Suite;\n    execute: (runnablesToRun: string[]) => void;\n    expect: (actual: any) => any;\n    fail: (error: {message: any}) => void;\n    fdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite | {id: any, isFocused: boolean};\n    fit: (description: any, fn: any, timeout: any) => {disabled: boolean} | jasmine.Spec;\n    it: (description: string, fn: () => void, timeout: any) => {disabled: boolean} | jasmine.Spec;\n    pending: (message: string) => void;\n    provideFallbackReporter: (reporterToAdd: any) => void;\n    randomTests: () => boolean;\n    randomizeTests: (value: any) => void;\n    seed: (value: any) => any;\n    specFilter: (spec: jasmine.Spec) => boolean;\n    spyOn: () => interface_490;\n    throwOnExpectationFailure: (value: any) => void;\n    throwingExpectationFailures: () => boolean;\n    topSuite: () => jasmine.Suite;\n    xdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite;\n    xit: () => {pend: (arg0: void) => void};\n}\n","containerDescription":"class jasmine.Env"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Env.[constructor].[return].throwingExpectationFailures","newFunction":"function() {\r\n            return throwOnExpectationFailure;\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Env.[constructor]","oldFunction":"function Env(options) {\r\n        options = options || {};\r\n\r\n        var self = this;\r\n        var global = options.global || j$.getGlobal();\r\n\r\n        var totalSpecsDefined = 0;\r\n\r\n        var catchExceptions = true;\r\n\r\n        var realSetTimeout = j$.getGlobal().setTimeout;\r\n        var realClearTimeout = j$.getGlobal().clearTimeout;\r\n        this.clock = new j$.Clock(global, new j$.DelayedFunctionScheduler(), new j$.MockDate(global));\r\n\r\n        var runnableLookupTable = {};\r\n        var runnableResources = {};\r\n\r\n        var currentSpec = null;\r\n        var currentlyExecutingSuites = [];\r\n        var currentDeclarationSuite = null;\r\n\r\n        var currentSuite = function() {\r\n            return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\r\n        };\r\n\r\n        var currentRunnable = function() {\r\n            return currentSpec || currentSuite();\r\n        };\r\n\r\n        var reporter = new j$.ReportDispatcher([\r\n            'jasmineStarted',\r\n            'jasmineDone',\r\n            'suiteStarted',\r\n            'suiteDone',\r\n            'specStarted',\r\n            'specDone'\r\n        ]);\r\n\r\n        this.specFilter = function() {\r\n            return true;\r\n        };\r\n\r\n        this.addCustomEqualityTester = function(tester) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Custom Equalities must be added in a before function or a spec');\r\n            }\r\n            runnableResources[currentRunnable().id].customEqualityTesters.push(tester);\r\n        };\r\n\r\n        this.addMatchers = function(matchersToAdd) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Matchers must be added in a before function or a spec');\r\n            }\r\n            var customMatchers = runnableResources[currentRunnable().id].customMatchers;\r\n            for (var matcherName in matchersToAdd) {\r\n                customMatchers[matcherName] = matchersToAdd[matcherName];\r\n            }\r\n        };\r\n\r\n        j$.Expectation.addCoreMatchers(j$.matchers);\r\n\r\n        var nextSpecId = 0;\r\n        var getNextSpecId = function() {\r\n            return 'spec' + nextSpecId++;\r\n        };\r\n\r\n        var nextSuiteId = 0;\r\n        var getNextSuiteId = function() {\r\n            return 'suite' + nextSuiteId++;\r\n        };\r\n\r\n        var expectationFactory = function(actual, spec) {\r\n            return j$.Expectation.Factory({\r\n                util: j$.matchersUtil,\r\n                customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\r\n                customMatchers: runnableResources[spec.id].customMatchers,\r\n                actual: actual,\r\n                addExpectationResult: addExpectationResult\r\n            });\r\n\r\n            function addExpectationResult(passed, result) {\r\n                return spec.addExpectationResult(passed, result);\r\n            }\r\n        };\r\n\r\n        var defaultResourcesForRunnable = function(id, parentRunnableId) {\r\n            var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};\r\n\r\n            if(runnableResources[parentRunnableId]){\r\n                resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);\r\n                resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);\r\n            }\r\n\r\n            runnableResources[id] = resources;\r\n        };\r\n\r\n        var clearResourcesForRunnable = function(id) {\r\n            spyRegistry.clearSpies();\r\n            delete runnableResources[id];\r\n        };\r\n\r\n        var beforeAndAfterFns = function(suite, runnablesExplictlySet) {\r\n            return function() {\r\n                var befores = [],\r\n                    afters = [],\r\n                    beforeAlls = [],\r\n                    afterAlls = [];\r\n\r\n                while(suite) {\r\n                    befores = befores.concat(suite.beforeFns);\r\n                    afters = afters.concat(suite.afterFns);\r\n\r\n                    if (runnablesExplictlySet()) {\r\n                        beforeAlls = beforeAlls.concat(suite.beforeAllFns);\r\n                        afterAlls = afterAlls.concat(suite.afterAllFns);\r\n                    }\r\n\r\n                    suite = suite.parentSuite;\r\n                }\r\n                return {\r\n                    befores: beforeAlls.reverse().concat(befores.reverse()),\r\n                    afters: afters.concat(afterAlls)\r\n                };\r\n            };\r\n        };\r\n\r\n        var getSpecName = function(spec, suite) {\r\n            return suite.getFullName() + ' ' + spec.description;\r\n        };\r\n\r\n        // TODO: we may just be able to pass in the fn instead of wrapping here\r\n        var buildExpectationResult = j$.buildExpectationResult,\r\n            exceptionFormatter = new j$.ExceptionFormatter(),\r\n            expectationResultFactory = function(attrs) {\r\n                attrs.messageFormatter = exceptionFormatter.message;\r\n                attrs.stackFormatter = exceptionFormatter.stack;\r\n\r\n                return buildExpectationResult(attrs);\r\n            };\r\n\r\n        // TODO: fix this naming, and here's where the value comes in\r\n        this.catchExceptions = function(value) {\r\n            catchExceptions = !!value;\r\n            return catchExceptions;\r\n        };\r\n\r\n        this.catchingExceptions = function() {\r\n            return catchExceptions;\r\n        };\r\n\r\n        var maximumSpecCallbackDepth = 20;\r\n        var currentSpecCallbackDepth = 0;\r\n\r\n        function clearStack(fn) {\r\n            currentSpecCallbackDepth++;\r\n            if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {\r\n                currentSpecCallbackDepth = 0;\r\n                realSetTimeout(fn, 0);\r\n            } else {\r\n                fn();\r\n            }\r\n        }\r\n\r\n        var catchException = function(e) {\r\n            return j$.Spec.isPendingSpecException(e) || catchExceptions;\r\n        };\r\n\r\n        var queueRunnerFactory = function(options) {\r\n            options.catchException = catchException;\r\n            options.clearStack = options.clearStack || clearStack;\r\n            options.timer = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\r\n            options.fail = self.fail;\r\n\r\n            new j$.QueueRunner(options).execute();\r\n        };\r\n\r\n        var topSuite = new j$.Suite({\r\n            env: this,\r\n            id: getNextSuiteId(),\r\n            description: 'Jasmine__TopLevel__Suite',\r\n            queueRunner: queueRunnerFactory\r\n        });\r\n        runnableLookupTable[topSuite.id] = topSuite;\r\n        defaultResourcesForRunnable(topSuite.id);\r\n        currentDeclarationSuite = topSuite;\r\n\r\n        this.topSuite = function() {\r\n            return topSuite;\r\n        };\r\n\r\n        this.execute = function(runnablesToRun) {\r\n            if(runnablesToRun) {\r\n                runnablesExplictlySet = true;\r\n            } else if (focusedRunnables.length) {\r\n                runnablesExplictlySet = true;\r\n                runnablesToRun = focusedRunnables;\r\n            } else {\r\n                runnablesToRun = [topSuite.id];\r\n            }\r\n\r\n            var allFns = [];\r\n            for(var i = 0; i < runnablesToRun.length; i++) {\r\n                var runnable = runnableLookupTable[runnablesToRun[i]];\r\n                allFns.push((function(runnable) { return { fn: function(done) { runnable.execute(done); } }; })(runnable));\r\n            }\r\n\r\n            reporter.jasmineStarted({\r\n                totalSpecsDefined: totalSpecsDefined\r\n            });\r\n\r\n            queueRunnerFactory({queueableFns: allFns, onComplete: reporter.jasmineDone});\r\n        };\r\n\r\n        this.addReporter = function(reporterToAdd) {\r\n            reporter.addReporter(reporterToAdd);\r\n        };\r\n\r\n        var spyRegistry = new j$.SpyRegistry({currentSpies: function() {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Spies must be created in a before function or a spec');\r\n            }\r\n            return runnableResources[currentRunnable().id].spies;\r\n        }});\r\n\r\n        this.spyOn = function() {\r\n            return spyRegistry.spyOn.apply(spyRegistry, arguments);\r\n        };\r\n\r\n        var suiteFactory = function(description) {\r\n            var suite = new j$.Suite({\r\n                env: self,\r\n                id: getNextSuiteId(),\r\n                description: description,\r\n                parentSuite: currentDeclarationSuite,\r\n                queueRunner: queueRunnerFactory,\r\n                onStart: suiteStarted,\r\n                expectationFactory: expectationFactory,\r\n                expectationResultFactory: expectationResultFactory,\r\n                runnablesExplictlySetGetter: runnablesExplictlySetGetter,\r\n                resultCallback: function(attrs) {\r\n                    if (!suite.disabled) {\r\n                        clearResourcesForRunnable(suite.id);\r\n                    }\r\n                    currentlyExecutingSuites.pop();\r\n                    reporter.suiteDone(attrs);\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[suite.id] = suite;\r\n            return suite;\r\n\r\n            function suiteStarted(suite) {\r\n                currentlyExecutingSuites.push(suite);\r\n                defaultResourcesForRunnable(suite.id, suite.parentSuite.id);\r\n                reporter.suiteStarted(suite.result);\r\n            }\r\n        };\r\n\r\n        this.describe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            addSpecsToSuite(suite, specDefinitions);\r\n            return suite;\r\n        };\r\n\r\n        this.xdescribe = function(description, specDefinitions) {\r\n            var suite = this.describe(description, specDefinitions);\r\n            suite.disable();\r\n            return suite;\r\n        };\r\n\r\n        var focusedRunnables = [];\r\n\r\n        this.fdescribe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            suite.isFocused = true;\r\n\r\n            focusedRunnables.push(suite.id);\r\n            unfocusAncestor();\r\n            addSpecsToSuite(suite, specDefinitions);\r\n\r\n            return suite;\r\n        };\r\n\r\n        function addSpecsToSuite(suite, specDefinitions) {\r\n            var parentSuite = currentDeclarationSuite;\r\n            parentSuite.addChild(suite);\r\n            currentDeclarationSuite = suite;\r\n\r\n            var declarationError = null;\r\n            try {\r\n                specDefinitions.call(suite);\r\n            } catch (e) {\r\n                declarationError = e;\r\n            }\r\n\r\n            if (declarationError) {\r\n                self.it('encountered a declaration exception', function() {\r\n                    throw declarationError;\r\n                });\r\n            }\r\n\r\n            currentDeclarationSuite = parentSuite;\r\n        }\r\n\r\n        function findFocusedAncestor(suite) {\r\n            while (suite) {\r\n                if (suite.isFocused) {\r\n                    return suite.id;\r\n                }\r\n                suite = suite.parentSuite;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        function unfocusAncestor() {\r\n            var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\r\n            if (focusedAncestor) {\r\n                for (var i = 0; i < focusedRunnables.length; i++) {\r\n                    if (focusedRunnables[i] === focusedAncestor) {\r\n                        focusedRunnables.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var runnablesExplictlySet = false;\r\n\r\n        var runnablesExplictlySetGetter = function(){\r\n            return runnablesExplictlySet;\r\n        };\r\n\r\n        var specFactory = function(description, fn, suite, timeout) {\r\n            totalSpecsDefined++;\r\n            var spec = new j$.Spec({\r\n                id: getNextSpecId(),\r\n                beforeAndAfterFns: beforeAndAfterFns(suite, runnablesExplictlySetGetter),\r\n                expectationFactory: expectationFactory,\r\n                resultCallback: specResultCallback,\r\n                getSpecName: function(spec) {\r\n                    return getSpecName(spec, suite);\r\n                },\r\n                onStart: specStarted,\r\n                description: description,\r\n                expectationResultFactory: expectationResultFactory,\r\n                queueRunnerFactory: queueRunnerFactory,\r\n                userContext: function() { return suite.clonedSharedUserContext(); },\r\n                queueableFn: {\r\n                    fn: fn,\r\n                    timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[spec.id] = spec;\r\n\r\n            if (!self.specFilter(spec)) {\r\n                spec.disable();\r\n            }\r\n\r\n            return spec;\r\n\r\n            function specResultCallback(result) {\r\n                clearResourcesForRunnable(spec.id);\r\n                currentSpec = null;\r\n                reporter.specDone(result);\r\n            }\r\n\r\n            function specStarted(spec) {\r\n                currentSpec = spec;\r\n                defaultResourcesForRunnable(spec.id, suite.id);\r\n                reporter.specStarted(spec.result);\r\n            }\r\n        };\r\n\r\n        this.it = function(description, fn, timeout) {\r\n            var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\r\n            currentDeclarationSuite.addChild(spec);\r\n            return spec;\r\n        };\r\n\r\n        this.xit = function() {\r\n            var spec = this.it.apply(this, arguments);\r\n            spec.pend();\r\n            return spec;\r\n        };\r\n\r\n        this.fit = function(){\r\n            var spec = this.it.apply(this, arguments);\r\n\r\n            focusedRunnables.push(spec.id);\r\n            unfocusAncestor();\r\n            return spec;\r\n        };\r\n\r\n        this.expect = function(actual) {\r\n            if (!currentRunnable()) {\r\n                throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\r\n            }\r\n\r\n            return currentRunnable().expect(actual);\r\n        };\r\n\r\n        this.beforeEach = function(beforeEachFunction, timeout) {\r\n            currentDeclarationSuite.beforeEach({\r\n                fn: beforeEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.beforeAll = function(beforeAllFunction, timeout) {\r\n            currentDeclarationSuite.beforeAll({\r\n                fn: beforeAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterEach = function(afterEachFunction, timeout) {\r\n            currentDeclarationSuite.afterEach({\r\n                fn: afterEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterAll = function(afterAllFunction, timeout) {\r\n            currentDeclarationSuite.afterAll({\r\n                fn: afterAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.pending = function(message) {\r\n            var fullMessage = j$.Spec.pendingSpecExceptionMessage;\r\n            if(message) {\r\n                fullMessage += message;\r\n            }\r\n            throw fullMessage;\r\n        };\r\n\r\n        this.fail = function(error) {\r\n            var message = 'Failed';\r\n            if (error) {\r\n                message += ': ';\r\n                message += error.message || error;\r\n            }\r\n\r\n            currentRunnable().addExpectationResult(false, {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                message: message,\r\n                error: error && error.message ? error : null\r\n            });\r\n        };\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Env.[constructor].[return]","key":"throwingExpectationFailures","newType":"() => boolean","isAny":false,"isClass":false,"containerType":"class Env1 {\n    constructor (options: {global: any});\n    addCustomEqualityTester: (tester: any) => void;\n    addMatchers: (matchersToAdd: any) => void;\n    addReporter: (reporterToAdd: any) => void;\n    afterAll: (afterAllFunction: any, timeout: any) => void;\n    afterEach: (afterEachFunction: any, timeout: any) => void;\n    allowRespy: (allow: any) => void;\n    beforeAll: (beforeAllFunction: any, timeout: any) => void;\n    beforeEach: (beforeEachFunction: any, timeout: any) => void;\n    catchExceptions: (value: any) => boolean;\n    catchingExceptions: () => boolean;\n    clock: jasmine.Clock;\n    describe: (description: any, specDefinitions: {call: (arg0: void) => void, length: number}) => jasmine.Suite;\n    execute: (runnablesToRun: string[]) => void;\n    expect: (actual: any) => any;\n    fail: (error: {message: any}) => void;\n    fdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite | {id: any, isFocused: boolean};\n    fit: (description: any, fn: any, timeout: any) => {disabled: boolean} | jasmine.Spec;\n    it: (description: string, fn: () => void, timeout: any) => {disabled: boolean} | jasmine.Spec;\n    pending: (message: string) => void;\n    provideFallbackReporter: (reporterToAdd: any) => void;\n    randomTests: () => boolean;\n    randomizeTests: (value: any) => void;\n    seed: (value: any) => any;\n    specFilter: (spec: jasmine.Spec) => boolean;\n    spyOn: () => interface_490;\n    throwOnExpectationFailure: (value: any) => void;\n    throwingExpectationFailures: () => boolean;\n    topSuite: () => jasmine.Suite;\n    xdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite;\n    xit: () => {pend: (arg0: void) => void};\n}\n","containerDescription":"class jasmine.Env"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Env.[constructor].[return].allowRespy","newFunction":"function(allow){\r\n            spyRegistry.allowRespy(allow);\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Env.[constructor]","oldFunction":"function Env(options) {\r\n        options = options || {};\r\n\r\n        var self = this;\r\n        var global = options.global || j$.getGlobal();\r\n\r\n        var totalSpecsDefined = 0;\r\n\r\n        var catchExceptions = true;\r\n\r\n        var realSetTimeout = j$.getGlobal().setTimeout;\r\n        var realClearTimeout = j$.getGlobal().clearTimeout;\r\n        this.clock = new j$.Clock(global, new j$.DelayedFunctionScheduler(), new j$.MockDate(global));\r\n\r\n        var runnableLookupTable = {};\r\n        var runnableResources = {};\r\n\r\n        var currentSpec = null;\r\n        var currentlyExecutingSuites = [];\r\n        var currentDeclarationSuite = null;\r\n\r\n        var currentSuite = function() {\r\n            return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\r\n        };\r\n\r\n        var currentRunnable = function() {\r\n            return currentSpec || currentSuite();\r\n        };\r\n\r\n        var reporter = new j$.ReportDispatcher([\r\n            'jasmineStarted',\r\n            'jasmineDone',\r\n            'suiteStarted',\r\n            'suiteDone',\r\n            'specStarted',\r\n            'specDone'\r\n        ]);\r\n\r\n        this.specFilter = function() {\r\n            return true;\r\n        };\r\n\r\n        this.addCustomEqualityTester = function(tester) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Custom Equalities must be added in a before function or a spec');\r\n            }\r\n            runnableResources[currentRunnable().id].customEqualityTesters.push(tester);\r\n        };\r\n\r\n        this.addMatchers = function(matchersToAdd) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Matchers must be added in a before function or a spec');\r\n            }\r\n            var customMatchers = runnableResources[currentRunnable().id].customMatchers;\r\n            for (var matcherName in matchersToAdd) {\r\n                customMatchers[matcherName] = matchersToAdd[matcherName];\r\n            }\r\n        };\r\n\r\n        j$.Expectation.addCoreMatchers(j$.matchers);\r\n\r\n        var nextSpecId = 0;\r\n        var getNextSpecId = function() {\r\n            return 'spec' + nextSpecId++;\r\n        };\r\n\r\n        var nextSuiteId = 0;\r\n        var getNextSuiteId = function() {\r\n            return 'suite' + nextSuiteId++;\r\n        };\r\n\r\n        var expectationFactory = function(actual, spec) {\r\n            return j$.Expectation.Factory({\r\n                util: j$.matchersUtil,\r\n                customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\r\n                customMatchers: runnableResources[spec.id].customMatchers,\r\n                actual: actual,\r\n                addExpectationResult: addExpectationResult\r\n            });\r\n\r\n            function addExpectationResult(passed, result) {\r\n                return spec.addExpectationResult(passed, result);\r\n            }\r\n        };\r\n\r\n        var defaultResourcesForRunnable = function(id, parentRunnableId) {\r\n            var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};\r\n\r\n            if(runnableResources[parentRunnableId]){\r\n                resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);\r\n                resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);\r\n            }\r\n\r\n            runnableResources[id] = resources;\r\n        };\r\n\r\n        var clearResourcesForRunnable = function(id) {\r\n            spyRegistry.clearSpies();\r\n            delete runnableResources[id];\r\n        };\r\n\r\n        var beforeAndAfterFns = function(suite, runnablesExplictlySet) {\r\n            return function() {\r\n                var befores = [],\r\n                    afters = [],\r\n                    beforeAlls = [],\r\n                    afterAlls = [];\r\n\r\n                while(suite) {\r\n                    befores = befores.concat(suite.beforeFns);\r\n                    afters = afters.concat(suite.afterFns);\r\n\r\n                    if (runnablesExplictlySet()) {\r\n                        beforeAlls = beforeAlls.concat(suite.beforeAllFns);\r\n                        afterAlls = afterAlls.concat(suite.afterAllFns);\r\n                    }\r\n\r\n                    suite = suite.parentSuite;\r\n                }\r\n                return {\r\n                    befores: beforeAlls.reverse().concat(befores.reverse()),\r\n                    afters: afters.concat(afterAlls)\r\n                };\r\n            };\r\n        };\r\n\r\n        var getSpecName = function(spec, suite) {\r\n            return suite.getFullName() + ' ' + spec.description;\r\n        };\r\n\r\n        // TODO: we may just be able to pass in the fn instead of wrapping here\r\n        var buildExpectationResult = j$.buildExpectationResult,\r\n            exceptionFormatter = new j$.ExceptionFormatter(),\r\n            expectationResultFactory = function(attrs) {\r\n                attrs.messageFormatter = exceptionFormatter.message;\r\n                attrs.stackFormatter = exceptionFormatter.stack;\r\n\r\n                return buildExpectationResult(attrs);\r\n            };\r\n\r\n        // TODO: fix this naming, and here's where the value comes in\r\n        this.catchExceptions = function(value) {\r\n            catchExceptions = !!value;\r\n            return catchExceptions;\r\n        };\r\n\r\n        this.catchingExceptions = function() {\r\n            return catchExceptions;\r\n        };\r\n\r\n        var maximumSpecCallbackDepth = 20;\r\n        var currentSpecCallbackDepth = 0;\r\n\r\n        function clearStack(fn) {\r\n            currentSpecCallbackDepth++;\r\n            if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {\r\n                currentSpecCallbackDepth = 0;\r\n                realSetTimeout(fn, 0);\r\n            } else {\r\n                fn();\r\n            }\r\n        }\r\n\r\n        var catchException = function(e) {\r\n            return j$.Spec.isPendingSpecException(e) || catchExceptions;\r\n        };\r\n\r\n        var queueRunnerFactory = function(options) {\r\n            options.catchException = catchException;\r\n            options.clearStack = options.clearStack || clearStack;\r\n            options.timer = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\r\n            options.fail = self.fail;\r\n\r\n            new j$.QueueRunner(options).execute();\r\n        };\r\n\r\n        var topSuite = new j$.Suite({\r\n            env: this,\r\n            id: getNextSuiteId(),\r\n            description: 'Jasmine__TopLevel__Suite',\r\n            queueRunner: queueRunnerFactory\r\n        });\r\n        runnableLookupTable[topSuite.id] = topSuite;\r\n        defaultResourcesForRunnable(topSuite.id);\r\n        currentDeclarationSuite = topSuite;\r\n\r\n        this.topSuite = function() {\r\n            return topSuite;\r\n        };\r\n\r\n        this.execute = function(runnablesToRun) {\r\n            if(runnablesToRun) {\r\n                runnablesExplictlySet = true;\r\n            } else if (focusedRunnables.length) {\r\n                runnablesExplictlySet = true;\r\n                runnablesToRun = focusedRunnables;\r\n            } else {\r\n                runnablesToRun = [topSuite.id];\r\n            }\r\n\r\n            var allFns = [];\r\n            for(var i = 0; i < runnablesToRun.length; i++) {\r\n                var runnable = runnableLookupTable[runnablesToRun[i]];\r\n                allFns.push((function(runnable) { return { fn: function(done) { runnable.execute(done); } }; })(runnable));\r\n            }\r\n\r\n            reporter.jasmineStarted({\r\n                totalSpecsDefined: totalSpecsDefined\r\n            });\r\n\r\n            queueRunnerFactory({queueableFns: allFns, onComplete: reporter.jasmineDone});\r\n        };\r\n\r\n        this.addReporter = function(reporterToAdd) {\r\n            reporter.addReporter(reporterToAdd);\r\n        };\r\n\r\n        var spyRegistry = new j$.SpyRegistry({currentSpies: function() {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Spies must be created in a before function or a spec');\r\n            }\r\n            return runnableResources[currentRunnable().id].spies;\r\n        }});\r\n\r\n        this.spyOn = function() {\r\n            return spyRegistry.spyOn.apply(spyRegistry, arguments);\r\n        };\r\n\r\n        var suiteFactory = function(description) {\r\n            var suite = new j$.Suite({\r\n                env: self,\r\n                id: getNextSuiteId(),\r\n                description: description,\r\n                parentSuite: currentDeclarationSuite,\r\n                queueRunner: queueRunnerFactory,\r\n                onStart: suiteStarted,\r\n                expectationFactory: expectationFactory,\r\n                expectationResultFactory: expectationResultFactory,\r\n                runnablesExplictlySetGetter: runnablesExplictlySetGetter,\r\n                resultCallback: function(attrs) {\r\n                    if (!suite.disabled) {\r\n                        clearResourcesForRunnable(suite.id);\r\n                    }\r\n                    currentlyExecutingSuites.pop();\r\n                    reporter.suiteDone(attrs);\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[suite.id] = suite;\r\n            return suite;\r\n\r\n            function suiteStarted(suite) {\r\n                currentlyExecutingSuites.push(suite);\r\n                defaultResourcesForRunnable(suite.id, suite.parentSuite.id);\r\n                reporter.suiteStarted(suite.result);\r\n            }\r\n        };\r\n\r\n        this.describe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            addSpecsToSuite(suite, specDefinitions);\r\n            return suite;\r\n        };\r\n\r\n        this.xdescribe = function(description, specDefinitions) {\r\n            var suite = this.describe(description, specDefinitions);\r\n            suite.disable();\r\n            return suite;\r\n        };\r\n\r\n        var focusedRunnables = [];\r\n\r\n        this.fdescribe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            suite.isFocused = true;\r\n\r\n            focusedRunnables.push(suite.id);\r\n            unfocusAncestor();\r\n            addSpecsToSuite(suite, specDefinitions);\r\n\r\n            return suite;\r\n        };\r\n\r\n        function addSpecsToSuite(suite, specDefinitions) {\r\n            var parentSuite = currentDeclarationSuite;\r\n            parentSuite.addChild(suite);\r\n            currentDeclarationSuite = suite;\r\n\r\n            var declarationError = null;\r\n            try {\r\n                specDefinitions.call(suite);\r\n            } catch (e) {\r\n                declarationError = e;\r\n            }\r\n\r\n            if (declarationError) {\r\n                self.it('encountered a declaration exception', function() {\r\n                    throw declarationError;\r\n                });\r\n            }\r\n\r\n            currentDeclarationSuite = parentSuite;\r\n        }\r\n\r\n        function findFocusedAncestor(suite) {\r\n            while (suite) {\r\n                if (suite.isFocused) {\r\n                    return suite.id;\r\n                }\r\n                suite = suite.parentSuite;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        function unfocusAncestor() {\r\n            var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\r\n            if (focusedAncestor) {\r\n                for (var i = 0; i < focusedRunnables.length; i++) {\r\n                    if (focusedRunnables[i] === focusedAncestor) {\r\n                        focusedRunnables.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var runnablesExplictlySet = false;\r\n\r\n        var runnablesExplictlySetGetter = function(){\r\n            return runnablesExplictlySet;\r\n        };\r\n\r\n        var specFactory = function(description, fn, suite, timeout) {\r\n            totalSpecsDefined++;\r\n            var spec = new j$.Spec({\r\n                id: getNextSpecId(),\r\n                beforeAndAfterFns: beforeAndAfterFns(suite, runnablesExplictlySetGetter),\r\n                expectationFactory: expectationFactory,\r\n                resultCallback: specResultCallback,\r\n                getSpecName: function(spec) {\r\n                    return getSpecName(spec, suite);\r\n                },\r\n                onStart: specStarted,\r\n                description: description,\r\n                expectationResultFactory: expectationResultFactory,\r\n                queueRunnerFactory: queueRunnerFactory,\r\n                userContext: function() { return suite.clonedSharedUserContext(); },\r\n                queueableFn: {\r\n                    fn: fn,\r\n                    timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[spec.id] = spec;\r\n\r\n            if (!self.specFilter(spec)) {\r\n                spec.disable();\r\n            }\r\n\r\n            return spec;\r\n\r\n            function specResultCallback(result) {\r\n                clearResourcesForRunnable(spec.id);\r\n                currentSpec = null;\r\n                reporter.specDone(result);\r\n            }\r\n\r\n            function specStarted(spec) {\r\n                currentSpec = spec;\r\n                defaultResourcesForRunnable(spec.id, suite.id);\r\n                reporter.specStarted(spec.result);\r\n            }\r\n        };\r\n\r\n        this.it = function(description, fn, timeout) {\r\n            var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\r\n            currentDeclarationSuite.addChild(spec);\r\n            return spec;\r\n        };\r\n\r\n        this.xit = function() {\r\n            var spec = this.it.apply(this, arguments);\r\n            spec.pend();\r\n            return spec;\r\n        };\r\n\r\n        this.fit = function(){\r\n            var spec = this.it.apply(this, arguments);\r\n\r\n            focusedRunnables.push(spec.id);\r\n            unfocusAncestor();\r\n            return spec;\r\n        };\r\n\r\n        this.expect = function(actual) {\r\n            if (!currentRunnable()) {\r\n                throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\r\n            }\r\n\r\n            return currentRunnable().expect(actual);\r\n        };\r\n\r\n        this.beforeEach = function(beforeEachFunction, timeout) {\r\n            currentDeclarationSuite.beforeEach({\r\n                fn: beforeEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.beforeAll = function(beforeAllFunction, timeout) {\r\n            currentDeclarationSuite.beforeAll({\r\n                fn: beforeAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterEach = function(afterEachFunction, timeout) {\r\n            currentDeclarationSuite.afterEach({\r\n                fn: afterEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterAll = function(afterAllFunction, timeout) {\r\n            currentDeclarationSuite.afterAll({\r\n                fn: afterAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.pending = function(message) {\r\n            var fullMessage = j$.Spec.pendingSpecExceptionMessage;\r\n            if(message) {\r\n                fullMessage += message;\r\n            }\r\n            throw fullMessage;\r\n        };\r\n\r\n        this.fail = function(error) {\r\n            var message = 'Failed';\r\n            if (error) {\r\n                message += ': ';\r\n                message += error.message || error;\r\n            }\r\n\r\n            currentRunnable().addExpectationResult(false, {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                message: message,\r\n                error: error && error.message ? error : null\r\n            });\r\n        };\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Env.[constructor].[return]","key":"allowRespy","newType":"(allow: any) => void","isAny":false,"isClass":false,"containerType":"class Env1 {\n    constructor (options: {global: any});\n    addCustomEqualityTester: (tester: any) => void;\n    addMatchers: (matchersToAdd: any) => void;\n    addReporter: (reporterToAdd: any) => void;\n    afterAll: (afterAllFunction: any, timeout: any) => void;\n    afterEach: (afterEachFunction: any, timeout: any) => void;\n    allowRespy: (allow: any) => void;\n    beforeAll: (beforeAllFunction: any, timeout: any) => void;\n    beforeEach: (beforeEachFunction: any, timeout: any) => void;\n    catchExceptions: (value: any) => boolean;\n    catchingExceptions: () => boolean;\n    clock: jasmine.Clock;\n    describe: (description: any, specDefinitions: {call: (arg0: void) => void, length: number}) => jasmine.Suite;\n    execute: (runnablesToRun: string[]) => void;\n    expect: (actual: any) => any;\n    fail: (error: {message: any}) => void;\n    fdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite | {id: any, isFocused: boolean};\n    fit: (description: any, fn: any, timeout: any) => {disabled: boolean} | jasmine.Spec;\n    it: (description: string, fn: () => void, timeout: any) => {disabled: boolean} | jasmine.Spec;\n    pending: (message: string) => void;\n    provideFallbackReporter: (reporterToAdd: any) => void;\n    randomTests: () => boolean;\n    randomizeTests: (value: any) => void;\n    seed: (value: any) => any;\n    specFilter: (spec: jasmine.Spec) => boolean;\n    spyOn: () => interface_490;\n    throwOnExpectationFailure: (value: any) => void;\n    throwingExpectationFailures: () => boolean;\n    topSuite: () => jasmine.Suite;\n    xdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite;\n    xit: () => {pend: (arg0: void) => void};\n}\n","containerDescription":"class jasmine.Env"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Env.[constructor].[return].throwOnExpectationFailure","newFunction":"function(value) {\r\n            throwOnExpectationFailure = !!value;\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Env.[constructor]","oldFunction":"function Env(options) {\r\n        options = options || {};\r\n\r\n        var self = this;\r\n        var global = options.global || j$.getGlobal();\r\n\r\n        var totalSpecsDefined = 0;\r\n\r\n        var catchExceptions = true;\r\n\r\n        var realSetTimeout = j$.getGlobal().setTimeout;\r\n        var realClearTimeout = j$.getGlobal().clearTimeout;\r\n        this.clock = new j$.Clock(global, new j$.DelayedFunctionScheduler(), new j$.MockDate(global));\r\n\r\n        var runnableLookupTable = {};\r\n        var runnableResources = {};\r\n\r\n        var currentSpec = null;\r\n        var currentlyExecutingSuites = [];\r\n        var currentDeclarationSuite = null;\r\n\r\n        var currentSuite = function() {\r\n            return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\r\n        };\r\n\r\n        var currentRunnable = function() {\r\n            return currentSpec || currentSuite();\r\n        };\r\n\r\n        var reporter = new j$.ReportDispatcher([\r\n            'jasmineStarted',\r\n            'jasmineDone',\r\n            'suiteStarted',\r\n            'suiteDone',\r\n            'specStarted',\r\n            'specDone'\r\n        ]);\r\n\r\n        this.specFilter = function() {\r\n            return true;\r\n        };\r\n\r\n        this.addCustomEqualityTester = function(tester) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Custom Equalities must be added in a before function or a spec');\r\n            }\r\n            runnableResources[currentRunnable().id].customEqualityTesters.push(tester);\r\n        };\r\n\r\n        this.addMatchers = function(matchersToAdd) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Matchers must be added in a before function or a spec');\r\n            }\r\n            var customMatchers = runnableResources[currentRunnable().id].customMatchers;\r\n            for (var matcherName in matchersToAdd) {\r\n                customMatchers[matcherName] = matchersToAdd[matcherName];\r\n            }\r\n        };\r\n\r\n        j$.Expectation.addCoreMatchers(j$.matchers);\r\n\r\n        var nextSpecId = 0;\r\n        var getNextSpecId = function() {\r\n            return 'spec' + nextSpecId++;\r\n        };\r\n\r\n        var nextSuiteId = 0;\r\n        var getNextSuiteId = function() {\r\n            return 'suite' + nextSuiteId++;\r\n        };\r\n\r\n        var expectationFactory = function(actual, spec) {\r\n            return j$.Expectation.Factory({\r\n                util: j$.matchersUtil,\r\n                customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\r\n                customMatchers: runnableResources[spec.id].customMatchers,\r\n                actual: actual,\r\n                addExpectationResult: addExpectationResult\r\n            });\r\n\r\n            function addExpectationResult(passed, result) {\r\n                return spec.addExpectationResult(passed, result);\r\n            }\r\n        };\r\n\r\n        var defaultResourcesForRunnable = function(id, parentRunnableId) {\r\n            var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};\r\n\r\n            if(runnableResources[parentRunnableId]){\r\n                resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);\r\n                resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);\r\n            }\r\n\r\n            runnableResources[id] = resources;\r\n        };\r\n\r\n        var clearResourcesForRunnable = function(id) {\r\n            spyRegistry.clearSpies();\r\n            delete runnableResources[id];\r\n        };\r\n\r\n        var beforeAndAfterFns = function(suite, runnablesExplictlySet) {\r\n            return function() {\r\n                var befores = [],\r\n                    afters = [],\r\n                    beforeAlls = [],\r\n                    afterAlls = [];\r\n\r\n                while(suite) {\r\n                    befores = befores.concat(suite.beforeFns);\r\n                    afters = afters.concat(suite.afterFns);\r\n\r\n                    if (runnablesExplictlySet()) {\r\n                        beforeAlls = beforeAlls.concat(suite.beforeAllFns);\r\n                        afterAlls = afterAlls.concat(suite.afterAllFns);\r\n                    }\r\n\r\n                    suite = suite.parentSuite;\r\n                }\r\n                return {\r\n                    befores: beforeAlls.reverse().concat(befores.reverse()),\r\n                    afters: afters.concat(afterAlls)\r\n                };\r\n            };\r\n        };\r\n\r\n        var getSpecName = function(spec, suite) {\r\n            return suite.getFullName() + ' ' + spec.description;\r\n        };\r\n\r\n        // TODO: we may just be able to pass in the fn instead of wrapping here\r\n        var buildExpectationResult = j$.buildExpectationResult,\r\n            exceptionFormatter = new j$.ExceptionFormatter(),\r\n            expectationResultFactory = function(attrs) {\r\n                attrs.messageFormatter = exceptionFormatter.message;\r\n                attrs.stackFormatter = exceptionFormatter.stack;\r\n\r\n                return buildExpectationResult(attrs);\r\n            };\r\n\r\n        // TODO: fix this naming, and here's where the value comes in\r\n        this.catchExceptions = function(value) {\r\n            catchExceptions = !!value;\r\n            return catchExceptions;\r\n        };\r\n\r\n        this.catchingExceptions = function() {\r\n            return catchExceptions;\r\n        };\r\n\r\n        var maximumSpecCallbackDepth = 20;\r\n        var currentSpecCallbackDepth = 0;\r\n\r\n        function clearStack(fn) {\r\n            currentSpecCallbackDepth++;\r\n            if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {\r\n                currentSpecCallbackDepth = 0;\r\n                realSetTimeout(fn, 0);\r\n            } else {\r\n                fn();\r\n            }\r\n        }\r\n\r\n        var catchException = function(e) {\r\n            return j$.Spec.isPendingSpecException(e) || catchExceptions;\r\n        };\r\n\r\n        var queueRunnerFactory = function(options) {\r\n            options.catchException = catchException;\r\n            options.clearStack = options.clearStack || clearStack;\r\n            options.timer = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\r\n            options.fail = self.fail;\r\n\r\n            new j$.QueueRunner(options).execute();\r\n        };\r\n\r\n        var topSuite = new j$.Suite({\r\n            env: this,\r\n            id: getNextSuiteId(),\r\n            description: 'Jasmine__TopLevel__Suite',\r\n            queueRunner: queueRunnerFactory\r\n        });\r\n        runnableLookupTable[topSuite.id] = topSuite;\r\n        defaultResourcesForRunnable(topSuite.id);\r\n        currentDeclarationSuite = topSuite;\r\n\r\n        this.topSuite = function() {\r\n            return topSuite;\r\n        };\r\n\r\n        this.execute = function(runnablesToRun) {\r\n            if(runnablesToRun) {\r\n                runnablesExplictlySet = true;\r\n            } else if (focusedRunnables.length) {\r\n                runnablesExplictlySet = true;\r\n                runnablesToRun = focusedRunnables;\r\n            } else {\r\n                runnablesToRun = [topSuite.id];\r\n            }\r\n\r\n            var allFns = [];\r\n            for(var i = 0; i < runnablesToRun.length; i++) {\r\n                var runnable = runnableLookupTable[runnablesToRun[i]];\r\n                allFns.push((function(runnable) { return { fn: function(done) { runnable.execute(done); } }; })(runnable));\r\n            }\r\n\r\n            reporter.jasmineStarted({\r\n                totalSpecsDefined: totalSpecsDefined\r\n            });\r\n\r\n            queueRunnerFactory({queueableFns: allFns, onComplete: reporter.jasmineDone});\r\n        };\r\n\r\n        this.addReporter = function(reporterToAdd) {\r\n            reporter.addReporter(reporterToAdd);\r\n        };\r\n\r\n        var spyRegistry = new j$.SpyRegistry({currentSpies: function() {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Spies must be created in a before function or a spec');\r\n            }\r\n            return runnableResources[currentRunnable().id].spies;\r\n        }});\r\n\r\n        this.spyOn = function() {\r\n            return spyRegistry.spyOn.apply(spyRegistry, arguments);\r\n        };\r\n\r\n        var suiteFactory = function(description) {\r\n            var suite = new j$.Suite({\r\n                env: self,\r\n                id: getNextSuiteId(),\r\n                description: description,\r\n                parentSuite: currentDeclarationSuite,\r\n                queueRunner: queueRunnerFactory,\r\n                onStart: suiteStarted,\r\n                expectationFactory: expectationFactory,\r\n                expectationResultFactory: expectationResultFactory,\r\n                runnablesExplictlySetGetter: runnablesExplictlySetGetter,\r\n                resultCallback: function(attrs) {\r\n                    if (!suite.disabled) {\r\n                        clearResourcesForRunnable(suite.id);\r\n                    }\r\n                    currentlyExecutingSuites.pop();\r\n                    reporter.suiteDone(attrs);\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[suite.id] = suite;\r\n            return suite;\r\n\r\n            function suiteStarted(suite) {\r\n                currentlyExecutingSuites.push(suite);\r\n                defaultResourcesForRunnable(suite.id, suite.parentSuite.id);\r\n                reporter.suiteStarted(suite.result);\r\n            }\r\n        };\r\n\r\n        this.describe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            addSpecsToSuite(suite, specDefinitions);\r\n            return suite;\r\n        };\r\n\r\n        this.xdescribe = function(description, specDefinitions) {\r\n            var suite = this.describe(description, specDefinitions);\r\n            suite.disable();\r\n            return suite;\r\n        };\r\n\r\n        var focusedRunnables = [];\r\n\r\n        this.fdescribe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            suite.isFocused = true;\r\n\r\n            focusedRunnables.push(suite.id);\r\n            unfocusAncestor();\r\n            addSpecsToSuite(suite, specDefinitions);\r\n\r\n            return suite;\r\n        };\r\n\r\n        function addSpecsToSuite(suite, specDefinitions) {\r\n            var parentSuite = currentDeclarationSuite;\r\n            parentSuite.addChild(suite);\r\n            currentDeclarationSuite = suite;\r\n\r\n            var declarationError = null;\r\n            try {\r\n                specDefinitions.call(suite);\r\n            } catch (e) {\r\n                declarationError = e;\r\n            }\r\n\r\n            if (declarationError) {\r\n                self.it('encountered a declaration exception', function() {\r\n                    throw declarationError;\r\n                });\r\n            }\r\n\r\n            currentDeclarationSuite = parentSuite;\r\n        }\r\n\r\n        function findFocusedAncestor(suite) {\r\n            while (suite) {\r\n                if (suite.isFocused) {\r\n                    return suite.id;\r\n                }\r\n                suite = suite.parentSuite;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        function unfocusAncestor() {\r\n            var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\r\n            if (focusedAncestor) {\r\n                for (var i = 0; i < focusedRunnables.length; i++) {\r\n                    if (focusedRunnables[i] === focusedAncestor) {\r\n                        focusedRunnables.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var runnablesExplictlySet = false;\r\n\r\n        var runnablesExplictlySetGetter = function(){\r\n            return runnablesExplictlySet;\r\n        };\r\n\r\n        var specFactory = function(description, fn, suite, timeout) {\r\n            totalSpecsDefined++;\r\n            var spec = new j$.Spec({\r\n                id: getNextSpecId(),\r\n                beforeAndAfterFns: beforeAndAfterFns(suite, runnablesExplictlySetGetter),\r\n                expectationFactory: expectationFactory,\r\n                resultCallback: specResultCallback,\r\n                getSpecName: function(spec) {\r\n                    return getSpecName(spec, suite);\r\n                },\r\n                onStart: specStarted,\r\n                description: description,\r\n                expectationResultFactory: expectationResultFactory,\r\n                queueRunnerFactory: queueRunnerFactory,\r\n                userContext: function() { return suite.clonedSharedUserContext(); },\r\n                queueableFn: {\r\n                    fn: fn,\r\n                    timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[spec.id] = spec;\r\n\r\n            if (!self.specFilter(spec)) {\r\n                spec.disable();\r\n            }\r\n\r\n            return spec;\r\n\r\n            function specResultCallback(result) {\r\n                clearResourcesForRunnable(spec.id);\r\n                currentSpec = null;\r\n                reporter.specDone(result);\r\n            }\r\n\r\n            function specStarted(spec) {\r\n                currentSpec = spec;\r\n                defaultResourcesForRunnable(spec.id, suite.id);\r\n                reporter.specStarted(spec.result);\r\n            }\r\n        };\r\n\r\n        this.it = function(description, fn, timeout) {\r\n            var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\r\n            currentDeclarationSuite.addChild(spec);\r\n            return spec;\r\n        };\r\n\r\n        this.xit = function() {\r\n            var spec = this.it.apply(this, arguments);\r\n            spec.pend();\r\n            return spec;\r\n        };\r\n\r\n        this.fit = function(){\r\n            var spec = this.it.apply(this, arguments);\r\n\r\n            focusedRunnables.push(spec.id);\r\n            unfocusAncestor();\r\n            return spec;\r\n        };\r\n\r\n        this.expect = function(actual) {\r\n            if (!currentRunnable()) {\r\n                throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\r\n            }\r\n\r\n            return currentRunnable().expect(actual);\r\n        };\r\n\r\n        this.beforeEach = function(beforeEachFunction, timeout) {\r\n            currentDeclarationSuite.beforeEach({\r\n                fn: beforeEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.beforeAll = function(beforeAllFunction, timeout) {\r\n            currentDeclarationSuite.beforeAll({\r\n                fn: beforeAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterEach = function(afterEachFunction, timeout) {\r\n            currentDeclarationSuite.afterEach({\r\n                fn: afterEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterAll = function(afterAllFunction, timeout) {\r\n            currentDeclarationSuite.afterAll({\r\n                fn: afterAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.pending = function(message) {\r\n            var fullMessage = j$.Spec.pendingSpecExceptionMessage;\r\n            if(message) {\r\n                fullMessage += message;\r\n            }\r\n            throw fullMessage;\r\n        };\r\n\r\n        this.fail = function(error) {\r\n            var message = 'Failed';\r\n            if (error) {\r\n                message += ': ';\r\n                message += error.message || error;\r\n            }\r\n\r\n            currentRunnable().addExpectationResult(false, {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                message: message,\r\n                error: error && error.message ? error : null\r\n            });\r\n        };\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Env.[constructor].[return]","key":"throwOnExpectationFailure","newType":"(value: any) => void","isAny":false,"isClass":false,"containerType":"class Env1 {\n    constructor (options: {global: any});\n    addCustomEqualityTester: (tester: any) => void;\n    addMatchers: (matchersToAdd: any) => void;\n    addReporter: (reporterToAdd: any) => void;\n    afterAll: (afterAllFunction: any, timeout: any) => void;\n    afterEach: (afterEachFunction: any, timeout: any) => void;\n    allowRespy: (allow: any) => void;\n    beforeAll: (beforeAllFunction: any, timeout: any) => void;\n    beforeEach: (beforeEachFunction: any, timeout: any) => void;\n    catchExceptions: (value: any) => boolean;\n    catchingExceptions: () => boolean;\n    clock: jasmine.Clock;\n    describe: (description: any, specDefinitions: {call: (arg0: void) => void, length: number}) => jasmine.Suite;\n    execute: (runnablesToRun: string[]) => void;\n    expect: (actual: any) => any;\n    fail: (error: {message: any}) => void;\n    fdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite | {id: any, isFocused: boolean};\n    fit: (description: any, fn: any, timeout: any) => {disabled: boolean} | jasmine.Spec;\n    it: (description: string, fn: () => void, timeout: any) => {disabled: boolean} | jasmine.Spec;\n    pending: (message: string) => void;\n    provideFallbackReporter: (reporterToAdd: any) => void;\n    randomTests: () => boolean;\n    randomizeTests: (value: any) => void;\n    seed: (value: any) => any;\n    specFilter: (spec: jasmine.Spec) => boolean;\n    spyOn: () => interface_490;\n    throwOnExpectationFailure: (value: any) => void;\n    throwingExpectationFailures: () => boolean;\n    topSuite: () => jasmine.Suite;\n    xdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite;\n    xit: () => {pend: (arg0: void) => void};\n}\n","containerDescription":"class jasmine.Env"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Env.[constructor].[return].randomTests","newFunction":"function() {\r\n            return random;\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Env.[constructor]","oldFunction":"function Env(options) {\r\n        options = options || {};\r\n\r\n        var self = this;\r\n        var global = options.global || j$.getGlobal();\r\n\r\n        var totalSpecsDefined = 0;\r\n\r\n        var catchExceptions = true;\r\n\r\n        var realSetTimeout = j$.getGlobal().setTimeout;\r\n        var realClearTimeout = j$.getGlobal().clearTimeout;\r\n        this.clock = new j$.Clock(global, new j$.DelayedFunctionScheduler(), new j$.MockDate(global));\r\n\r\n        var runnableLookupTable = {};\r\n        var runnableResources = {};\r\n\r\n        var currentSpec = null;\r\n        var currentlyExecutingSuites = [];\r\n        var currentDeclarationSuite = null;\r\n\r\n        var currentSuite = function() {\r\n            return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\r\n        };\r\n\r\n        var currentRunnable = function() {\r\n            return currentSpec || currentSuite();\r\n        };\r\n\r\n        var reporter = new j$.ReportDispatcher([\r\n            'jasmineStarted',\r\n            'jasmineDone',\r\n            'suiteStarted',\r\n            'suiteDone',\r\n            'specStarted',\r\n            'specDone'\r\n        ]);\r\n\r\n        this.specFilter = function() {\r\n            return true;\r\n        };\r\n\r\n        this.addCustomEqualityTester = function(tester) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Custom Equalities must be added in a before function or a spec');\r\n            }\r\n            runnableResources[currentRunnable().id].customEqualityTesters.push(tester);\r\n        };\r\n\r\n        this.addMatchers = function(matchersToAdd) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Matchers must be added in a before function or a spec');\r\n            }\r\n            var customMatchers = runnableResources[currentRunnable().id].customMatchers;\r\n            for (var matcherName in matchersToAdd) {\r\n                customMatchers[matcherName] = matchersToAdd[matcherName];\r\n            }\r\n        };\r\n\r\n        j$.Expectation.addCoreMatchers(j$.matchers);\r\n\r\n        var nextSpecId = 0;\r\n        var getNextSpecId = function() {\r\n            return 'spec' + nextSpecId++;\r\n        };\r\n\r\n        var nextSuiteId = 0;\r\n        var getNextSuiteId = function() {\r\n            return 'suite' + nextSuiteId++;\r\n        };\r\n\r\n        var expectationFactory = function(actual, spec) {\r\n            return j$.Expectation.Factory({\r\n                util: j$.matchersUtil,\r\n                customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\r\n                customMatchers: runnableResources[spec.id].customMatchers,\r\n                actual: actual,\r\n                addExpectationResult: addExpectationResult\r\n            });\r\n\r\n            function addExpectationResult(passed, result) {\r\n                return spec.addExpectationResult(passed, result);\r\n            }\r\n        };\r\n\r\n        var defaultResourcesForRunnable = function(id, parentRunnableId) {\r\n            var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};\r\n\r\n            if(runnableResources[parentRunnableId]){\r\n                resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);\r\n                resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);\r\n            }\r\n\r\n            runnableResources[id] = resources;\r\n        };\r\n\r\n        var clearResourcesForRunnable = function(id) {\r\n            spyRegistry.clearSpies();\r\n            delete runnableResources[id];\r\n        };\r\n\r\n        var beforeAndAfterFns = function(suite, runnablesExplictlySet) {\r\n            return function() {\r\n                var befores = [],\r\n                    afters = [],\r\n                    beforeAlls = [],\r\n                    afterAlls = [];\r\n\r\n                while(suite) {\r\n                    befores = befores.concat(suite.beforeFns);\r\n                    afters = afters.concat(suite.afterFns);\r\n\r\n                    if (runnablesExplictlySet()) {\r\n                        beforeAlls = beforeAlls.concat(suite.beforeAllFns);\r\n                        afterAlls = afterAlls.concat(suite.afterAllFns);\r\n                    }\r\n\r\n                    suite = suite.parentSuite;\r\n                }\r\n                return {\r\n                    befores: beforeAlls.reverse().concat(befores.reverse()),\r\n                    afters: afters.concat(afterAlls)\r\n                };\r\n            };\r\n        };\r\n\r\n        var getSpecName = function(spec, suite) {\r\n            return suite.getFullName() + ' ' + spec.description;\r\n        };\r\n\r\n        // TODO: we may just be able to pass in the fn instead of wrapping here\r\n        var buildExpectationResult = j$.buildExpectationResult,\r\n            exceptionFormatter = new j$.ExceptionFormatter(),\r\n            expectationResultFactory = function(attrs) {\r\n                attrs.messageFormatter = exceptionFormatter.message;\r\n                attrs.stackFormatter = exceptionFormatter.stack;\r\n\r\n                return buildExpectationResult(attrs);\r\n            };\r\n\r\n        // TODO: fix this naming, and here's where the value comes in\r\n        this.catchExceptions = function(value) {\r\n            catchExceptions = !!value;\r\n            return catchExceptions;\r\n        };\r\n\r\n        this.catchingExceptions = function() {\r\n            return catchExceptions;\r\n        };\r\n\r\n        var maximumSpecCallbackDepth = 20;\r\n        var currentSpecCallbackDepth = 0;\r\n\r\n        function clearStack(fn) {\r\n            currentSpecCallbackDepth++;\r\n            if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {\r\n                currentSpecCallbackDepth = 0;\r\n                realSetTimeout(fn, 0);\r\n            } else {\r\n                fn();\r\n            }\r\n        }\r\n\r\n        var catchException = function(e) {\r\n            return j$.Spec.isPendingSpecException(e) || catchExceptions;\r\n        };\r\n\r\n        var queueRunnerFactory = function(options) {\r\n            options.catchException = catchException;\r\n            options.clearStack = options.clearStack || clearStack;\r\n            options.timer = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\r\n            options.fail = self.fail;\r\n\r\n            new j$.QueueRunner(options).execute();\r\n        };\r\n\r\n        var topSuite = new j$.Suite({\r\n            env: this,\r\n            id: getNextSuiteId(),\r\n            description: 'Jasmine__TopLevel__Suite',\r\n            queueRunner: queueRunnerFactory\r\n        });\r\n        runnableLookupTable[topSuite.id] = topSuite;\r\n        defaultResourcesForRunnable(topSuite.id);\r\n        currentDeclarationSuite = topSuite;\r\n\r\n        this.topSuite = function() {\r\n            return topSuite;\r\n        };\r\n\r\n        this.execute = function(runnablesToRun) {\r\n            if(runnablesToRun) {\r\n                runnablesExplictlySet = true;\r\n            } else if (focusedRunnables.length) {\r\n                runnablesExplictlySet = true;\r\n                runnablesToRun = focusedRunnables;\r\n            } else {\r\n                runnablesToRun = [topSuite.id];\r\n            }\r\n\r\n            var allFns = [];\r\n            for(var i = 0; i < runnablesToRun.length; i++) {\r\n                var runnable = runnableLookupTable[runnablesToRun[i]];\r\n                allFns.push((function(runnable) { return { fn: function(done) { runnable.execute(done); } }; })(runnable));\r\n            }\r\n\r\n            reporter.jasmineStarted({\r\n                totalSpecsDefined: totalSpecsDefined\r\n            });\r\n\r\n            queueRunnerFactory({queueableFns: allFns, onComplete: reporter.jasmineDone});\r\n        };\r\n\r\n        this.addReporter = function(reporterToAdd) {\r\n            reporter.addReporter(reporterToAdd);\r\n        };\r\n\r\n        var spyRegistry = new j$.SpyRegistry({currentSpies: function() {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Spies must be created in a before function or a spec');\r\n            }\r\n            return runnableResources[currentRunnable().id].spies;\r\n        }});\r\n\r\n        this.spyOn = function() {\r\n            return spyRegistry.spyOn.apply(spyRegistry, arguments);\r\n        };\r\n\r\n        var suiteFactory = function(description) {\r\n            var suite = new j$.Suite({\r\n                env: self,\r\n                id: getNextSuiteId(),\r\n                description: description,\r\n                parentSuite: currentDeclarationSuite,\r\n                queueRunner: queueRunnerFactory,\r\n                onStart: suiteStarted,\r\n                expectationFactory: expectationFactory,\r\n                expectationResultFactory: expectationResultFactory,\r\n                runnablesExplictlySetGetter: runnablesExplictlySetGetter,\r\n                resultCallback: function(attrs) {\r\n                    if (!suite.disabled) {\r\n                        clearResourcesForRunnable(suite.id);\r\n                    }\r\n                    currentlyExecutingSuites.pop();\r\n                    reporter.suiteDone(attrs);\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[suite.id] = suite;\r\n            return suite;\r\n\r\n            function suiteStarted(suite) {\r\n                currentlyExecutingSuites.push(suite);\r\n                defaultResourcesForRunnable(suite.id, suite.parentSuite.id);\r\n                reporter.suiteStarted(suite.result);\r\n            }\r\n        };\r\n\r\n        this.describe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            addSpecsToSuite(suite, specDefinitions);\r\n            return suite;\r\n        };\r\n\r\n        this.xdescribe = function(description, specDefinitions) {\r\n            var suite = this.describe(description, specDefinitions);\r\n            suite.disable();\r\n            return suite;\r\n        };\r\n\r\n        var focusedRunnables = [];\r\n\r\n        this.fdescribe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            suite.isFocused = true;\r\n\r\n            focusedRunnables.push(suite.id);\r\n            unfocusAncestor();\r\n            addSpecsToSuite(suite, specDefinitions);\r\n\r\n            return suite;\r\n        };\r\n\r\n        function addSpecsToSuite(suite, specDefinitions) {\r\n            var parentSuite = currentDeclarationSuite;\r\n            parentSuite.addChild(suite);\r\n            currentDeclarationSuite = suite;\r\n\r\n            var declarationError = null;\r\n            try {\r\n                specDefinitions.call(suite);\r\n            } catch (e) {\r\n                declarationError = e;\r\n            }\r\n\r\n            if (declarationError) {\r\n                self.it('encountered a declaration exception', function() {\r\n                    throw declarationError;\r\n                });\r\n            }\r\n\r\n            currentDeclarationSuite = parentSuite;\r\n        }\r\n\r\n        function findFocusedAncestor(suite) {\r\n            while (suite) {\r\n                if (suite.isFocused) {\r\n                    return suite.id;\r\n                }\r\n                suite = suite.parentSuite;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        function unfocusAncestor() {\r\n            var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\r\n            if (focusedAncestor) {\r\n                for (var i = 0; i < focusedRunnables.length; i++) {\r\n                    if (focusedRunnables[i] === focusedAncestor) {\r\n                        focusedRunnables.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var runnablesExplictlySet = false;\r\n\r\n        var runnablesExplictlySetGetter = function(){\r\n            return runnablesExplictlySet;\r\n        };\r\n\r\n        var specFactory = function(description, fn, suite, timeout) {\r\n            totalSpecsDefined++;\r\n            var spec = new j$.Spec({\r\n                id: getNextSpecId(),\r\n                beforeAndAfterFns: beforeAndAfterFns(suite, runnablesExplictlySetGetter),\r\n                expectationFactory: expectationFactory,\r\n                resultCallback: specResultCallback,\r\n                getSpecName: function(spec) {\r\n                    return getSpecName(spec, suite);\r\n                },\r\n                onStart: specStarted,\r\n                description: description,\r\n                expectationResultFactory: expectationResultFactory,\r\n                queueRunnerFactory: queueRunnerFactory,\r\n                userContext: function() { return suite.clonedSharedUserContext(); },\r\n                queueableFn: {\r\n                    fn: fn,\r\n                    timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[spec.id] = spec;\r\n\r\n            if (!self.specFilter(spec)) {\r\n                spec.disable();\r\n            }\r\n\r\n            return spec;\r\n\r\n            function specResultCallback(result) {\r\n                clearResourcesForRunnable(spec.id);\r\n                currentSpec = null;\r\n                reporter.specDone(result);\r\n            }\r\n\r\n            function specStarted(spec) {\r\n                currentSpec = spec;\r\n                defaultResourcesForRunnable(spec.id, suite.id);\r\n                reporter.specStarted(spec.result);\r\n            }\r\n        };\r\n\r\n        this.it = function(description, fn, timeout) {\r\n            var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\r\n            currentDeclarationSuite.addChild(spec);\r\n            return spec;\r\n        };\r\n\r\n        this.xit = function() {\r\n            var spec = this.it.apply(this, arguments);\r\n            spec.pend();\r\n            return spec;\r\n        };\r\n\r\n        this.fit = function(){\r\n            var spec = this.it.apply(this, arguments);\r\n\r\n            focusedRunnables.push(spec.id);\r\n            unfocusAncestor();\r\n            return spec;\r\n        };\r\n\r\n        this.expect = function(actual) {\r\n            if (!currentRunnable()) {\r\n                throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\r\n            }\r\n\r\n            return currentRunnable().expect(actual);\r\n        };\r\n\r\n        this.beforeEach = function(beforeEachFunction, timeout) {\r\n            currentDeclarationSuite.beforeEach({\r\n                fn: beforeEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.beforeAll = function(beforeAllFunction, timeout) {\r\n            currentDeclarationSuite.beforeAll({\r\n                fn: beforeAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterEach = function(afterEachFunction, timeout) {\r\n            currentDeclarationSuite.afterEach({\r\n                fn: afterEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterAll = function(afterAllFunction, timeout) {\r\n            currentDeclarationSuite.afterAll({\r\n                fn: afterAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.pending = function(message) {\r\n            var fullMessage = j$.Spec.pendingSpecExceptionMessage;\r\n            if(message) {\r\n                fullMessage += message;\r\n            }\r\n            throw fullMessage;\r\n        };\r\n\r\n        this.fail = function(error) {\r\n            var message = 'Failed';\r\n            if (error) {\r\n                message += ': ';\r\n                message += error.message || error;\r\n            }\r\n\r\n            currentRunnable().addExpectationResult(false, {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                message: message,\r\n                error: error && error.message ? error : null\r\n            });\r\n        };\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Env.[constructor].[return]","key":"randomTests","newType":"() => boolean","isAny":false,"isClass":false,"containerType":"class Env1 {\n    constructor (options: {global: any});\n    addCustomEqualityTester: (tester: any) => void;\n    addMatchers: (matchersToAdd: any) => void;\n    addReporter: (reporterToAdd: any) => void;\n    afterAll: (afterAllFunction: any, timeout: any) => void;\n    afterEach: (afterEachFunction: any, timeout: any) => void;\n    allowRespy: (allow: any) => void;\n    beforeAll: (beforeAllFunction: any, timeout: any) => void;\n    beforeEach: (beforeEachFunction: any, timeout: any) => void;\n    catchExceptions: (value: any) => boolean;\n    catchingExceptions: () => boolean;\n    clock: jasmine.Clock;\n    describe: (description: any, specDefinitions: {call: (arg0: void) => void, length: number}) => jasmine.Suite;\n    execute: (runnablesToRun: string[]) => void;\n    expect: (actual: any) => any;\n    fail: (error: {message: any}) => void;\n    fdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite | {id: any, isFocused: boolean};\n    fit: (description: any, fn: any, timeout: any) => {disabled: boolean} | jasmine.Spec;\n    it: (description: string, fn: () => void, timeout: any) => {disabled: boolean} | jasmine.Spec;\n    pending: (message: string) => void;\n    provideFallbackReporter: (reporterToAdd: any) => void;\n    randomTests: () => boolean;\n    randomizeTests: (value: any) => void;\n    seed: (value: any) => any;\n    specFilter: (spec: jasmine.Spec) => boolean;\n    spyOn: () => interface_490;\n    throwOnExpectationFailure: (value: any) => void;\n    throwingExpectationFailures: () => boolean;\n    topSuite: () => jasmine.Suite;\n    xdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite;\n    xit: () => {pend: (arg0: void) => void};\n}\n","containerDescription":"class jasmine.Env"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Env.[constructor].[return].randomizeTests","newFunction":"function(value) {\r\n            random = !!value;\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Env.[constructor]","oldFunction":"function Env(options) {\r\n        options = options || {};\r\n\r\n        var self = this;\r\n        var global = options.global || j$.getGlobal();\r\n\r\n        var totalSpecsDefined = 0;\r\n\r\n        var catchExceptions = true;\r\n\r\n        var realSetTimeout = j$.getGlobal().setTimeout;\r\n        var realClearTimeout = j$.getGlobal().clearTimeout;\r\n        this.clock = new j$.Clock(global, new j$.DelayedFunctionScheduler(), new j$.MockDate(global));\r\n\r\n        var runnableLookupTable = {};\r\n        var runnableResources = {};\r\n\r\n        var currentSpec = null;\r\n        var currentlyExecutingSuites = [];\r\n        var currentDeclarationSuite = null;\r\n\r\n        var currentSuite = function() {\r\n            return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\r\n        };\r\n\r\n        var currentRunnable = function() {\r\n            return currentSpec || currentSuite();\r\n        };\r\n\r\n        var reporter = new j$.ReportDispatcher([\r\n            'jasmineStarted',\r\n            'jasmineDone',\r\n            'suiteStarted',\r\n            'suiteDone',\r\n            'specStarted',\r\n            'specDone'\r\n        ]);\r\n\r\n        this.specFilter = function() {\r\n            return true;\r\n        };\r\n\r\n        this.addCustomEqualityTester = function(tester) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Custom Equalities must be added in a before function or a spec');\r\n            }\r\n            runnableResources[currentRunnable().id].customEqualityTesters.push(tester);\r\n        };\r\n\r\n        this.addMatchers = function(matchersToAdd) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Matchers must be added in a before function or a spec');\r\n            }\r\n            var customMatchers = runnableResources[currentRunnable().id].customMatchers;\r\n            for (var matcherName in matchersToAdd) {\r\n                customMatchers[matcherName] = matchersToAdd[matcherName];\r\n            }\r\n        };\r\n\r\n        j$.Expectation.addCoreMatchers(j$.matchers);\r\n\r\n        var nextSpecId = 0;\r\n        var getNextSpecId = function() {\r\n            return 'spec' + nextSpecId++;\r\n        };\r\n\r\n        var nextSuiteId = 0;\r\n        var getNextSuiteId = function() {\r\n            return 'suite' + nextSuiteId++;\r\n        };\r\n\r\n        var expectationFactory = function(actual, spec) {\r\n            return j$.Expectation.Factory({\r\n                util: j$.matchersUtil,\r\n                customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\r\n                customMatchers: runnableResources[spec.id].customMatchers,\r\n                actual: actual,\r\n                addExpectationResult: addExpectationResult\r\n            });\r\n\r\n            function addExpectationResult(passed, result) {\r\n                return spec.addExpectationResult(passed, result);\r\n            }\r\n        };\r\n\r\n        var defaultResourcesForRunnable = function(id, parentRunnableId) {\r\n            var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};\r\n\r\n            if(runnableResources[parentRunnableId]){\r\n                resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);\r\n                resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);\r\n            }\r\n\r\n            runnableResources[id] = resources;\r\n        };\r\n\r\n        var clearResourcesForRunnable = function(id) {\r\n            spyRegistry.clearSpies();\r\n            delete runnableResources[id];\r\n        };\r\n\r\n        var beforeAndAfterFns = function(suite, runnablesExplictlySet) {\r\n            return function() {\r\n                var befores = [],\r\n                    afters = [],\r\n                    beforeAlls = [],\r\n                    afterAlls = [];\r\n\r\n                while(suite) {\r\n                    befores = befores.concat(suite.beforeFns);\r\n                    afters = afters.concat(suite.afterFns);\r\n\r\n                    if (runnablesExplictlySet()) {\r\n                        beforeAlls = beforeAlls.concat(suite.beforeAllFns);\r\n                        afterAlls = afterAlls.concat(suite.afterAllFns);\r\n                    }\r\n\r\n                    suite = suite.parentSuite;\r\n                }\r\n                return {\r\n                    befores: beforeAlls.reverse().concat(befores.reverse()),\r\n                    afters: afters.concat(afterAlls)\r\n                };\r\n            };\r\n        };\r\n\r\n        var getSpecName = function(spec, suite) {\r\n            return suite.getFullName() + ' ' + spec.description;\r\n        };\r\n\r\n        // TODO: we may just be able to pass in the fn instead of wrapping here\r\n        var buildExpectationResult = j$.buildExpectationResult,\r\n            exceptionFormatter = new j$.ExceptionFormatter(),\r\n            expectationResultFactory = function(attrs) {\r\n                attrs.messageFormatter = exceptionFormatter.message;\r\n                attrs.stackFormatter = exceptionFormatter.stack;\r\n\r\n                return buildExpectationResult(attrs);\r\n            };\r\n\r\n        // TODO: fix this naming, and here's where the value comes in\r\n        this.catchExceptions = function(value) {\r\n            catchExceptions = !!value;\r\n            return catchExceptions;\r\n        };\r\n\r\n        this.catchingExceptions = function() {\r\n            return catchExceptions;\r\n        };\r\n\r\n        var maximumSpecCallbackDepth = 20;\r\n        var currentSpecCallbackDepth = 0;\r\n\r\n        function clearStack(fn) {\r\n            currentSpecCallbackDepth++;\r\n            if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {\r\n                currentSpecCallbackDepth = 0;\r\n                realSetTimeout(fn, 0);\r\n            } else {\r\n                fn();\r\n            }\r\n        }\r\n\r\n        var catchException = function(e) {\r\n            return j$.Spec.isPendingSpecException(e) || catchExceptions;\r\n        };\r\n\r\n        var queueRunnerFactory = function(options) {\r\n            options.catchException = catchException;\r\n            options.clearStack = options.clearStack || clearStack;\r\n            options.timer = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\r\n            options.fail = self.fail;\r\n\r\n            new j$.QueueRunner(options).execute();\r\n        };\r\n\r\n        var topSuite = new j$.Suite({\r\n            env: this,\r\n            id: getNextSuiteId(),\r\n            description: 'Jasmine__TopLevel__Suite',\r\n            queueRunner: queueRunnerFactory\r\n        });\r\n        runnableLookupTable[topSuite.id] = topSuite;\r\n        defaultResourcesForRunnable(topSuite.id);\r\n        currentDeclarationSuite = topSuite;\r\n\r\n        this.topSuite = function() {\r\n            return topSuite;\r\n        };\r\n\r\n        this.execute = function(runnablesToRun) {\r\n            if(runnablesToRun) {\r\n                runnablesExplictlySet = true;\r\n            } else if (focusedRunnables.length) {\r\n                runnablesExplictlySet = true;\r\n                runnablesToRun = focusedRunnables;\r\n            } else {\r\n                runnablesToRun = [topSuite.id];\r\n            }\r\n\r\n            var allFns = [];\r\n            for(var i = 0; i < runnablesToRun.length; i++) {\r\n                var runnable = runnableLookupTable[runnablesToRun[i]];\r\n                allFns.push((function(runnable) { return { fn: function(done) { runnable.execute(done); } }; })(runnable));\r\n            }\r\n\r\n            reporter.jasmineStarted({\r\n                totalSpecsDefined: totalSpecsDefined\r\n            });\r\n\r\n            queueRunnerFactory({queueableFns: allFns, onComplete: reporter.jasmineDone});\r\n        };\r\n\r\n        this.addReporter = function(reporterToAdd) {\r\n            reporter.addReporter(reporterToAdd);\r\n        };\r\n\r\n        var spyRegistry = new j$.SpyRegistry({currentSpies: function() {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Spies must be created in a before function or a spec');\r\n            }\r\n            return runnableResources[currentRunnable().id].spies;\r\n        }});\r\n\r\n        this.spyOn = function() {\r\n            return spyRegistry.spyOn.apply(spyRegistry, arguments);\r\n        };\r\n\r\n        var suiteFactory = function(description) {\r\n            var suite = new j$.Suite({\r\n                env: self,\r\n                id: getNextSuiteId(),\r\n                description: description,\r\n                parentSuite: currentDeclarationSuite,\r\n                queueRunner: queueRunnerFactory,\r\n                onStart: suiteStarted,\r\n                expectationFactory: expectationFactory,\r\n                expectationResultFactory: expectationResultFactory,\r\n                runnablesExplictlySetGetter: runnablesExplictlySetGetter,\r\n                resultCallback: function(attrs) {\r\n                    if (!suite.disabled) {\r\n                        clearResourcesForRunnable(suite.id);\r\n                    }\r\n                    currentlyExecutingSuites.pop();\r\n                    reporter.suiteDone(attrs);\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[suite.id] = suite;\r\n            return suite;\r\n\r\n            function suiteStarted(suite) {\r\n                currentlyExecutingSuites.push(suite);\r\n                defaultResourcesForRunnable(suite.id, suite.parentSuite.id);\r\n                reporter.suiteStarted(suite.result);\r\n            }\r\n        };\r\n\r\n        this.describe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            addSpecsToSuite(suite, specDefinitions);\r\n            return suite;\r\n        };\r\n\r\n        this.xdescribe = function(description, specDefinitions) {\r\n            var suite = this.describe(description, specDefinitions);\r\n            suite.disable();\r\n            return suite;\r\n        };\r\n\r\n        var focusedRunnables = [];\r\n\r\n        this.fdescribe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            suite.isFocused = true;\r\n\r\n            focusedRunnables.push(suite.id);\r\n            unfocusAncestor();\r\n            addSpecsToSuite(suite, specDefinitions);\r\n\r\n            return suite;\r\n        };\r\n\r\n        function addSpecsToSuite(suite, specDefinitions) {\r\n            var parentSuite = currentDeclarationSuite;\r\n            parentSuite.addChild(suite);\r\n            currentDeclarationSuite = suite;\r\n\r\n            var declarationError = null;\r\n            try {\r\n                specDefinitions.call(suite);\r\n            } catch (e) {\r\n                declarationError = e;\r\n            }\r\n\r\n            if (declarationError) {\r\n                self.it('encountered a declaration exception', function() {\r\n                    throw declarationError;\r\n                });\r\n            }\r\n\r\n            currentDeclarationSuite = parentSuite;\r\n        }\r\n\r\n        function findFocusedAncestor(suite) {\r\n            while (suite) {\r\n                if (suite.isFocused) {\r\n                    return suite.id;\r\n                }\r\n                suite = suite.parentSuite;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        function unfocusAncestor() {\r\n            var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\r\n            if (focusedAncestor) {\r\n                for (var i = 0; i < focusedRunnables.length; i++) {\r\n                    if (focusedRunnables[i] === focusedAncestor) {\r\n                        focusedRunnables.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var runnablesExplictlySet = false;\r\n\r\n        var runnablesExplictlySetGetter = function(){\r\n            return runnablesExplictlySet;\r\n        };\r\n\r\n        var specFactory = function(description, fn, suite, timeout) {\r\n            totalSpecsDefined++;\r\n            var spec = new j$.Spec({\r\n                id: getNextSpecId(),\r\n                beforeAndAfterFns: beforeAndAfterFns(suite, runnablesExplictlySetGetter),\r\n                expectationFactory: expectationFactory,\r\n                resultCallback: specResultCallback,\r\n                getSpecName: function(spec) {\r\n                    return getSpecName(spec, suite);\r\n                },\r\n                onStart: specStarted,\r\n                description: description,\r\n                expectationResultFactory: expectationResultFactory,\r\n                queueRunnerFactory: queueRunnerFactory,\r\n                userContext: function() { return suite.clonedSharedUserContext(); },\r\n                queueableFn: {\r\n                    fn: fn,\r\n                    timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[spec.id] = spec;\r\n\r\n            if (!self.specFilter(spec)) {\r\n                spec.disable();\r\n            }\r\n\r\n            return spec;\r\n\r\n            function specResultCallback(result) {\r\n                clearResourcesForRunnable(spec.id);\r\n                currentSpec = null;\r\n                reporter.specDone(result);\r\n            }\r\n\r\n            function specStarted(spec) {\r\n                currentSpec = spec;\r\n                defaultResourcesForRunnable(spec.id, suite.id);\r\n                reporter.specStarted(spec.result);\r\n            }\r\n        };\r\n\r\n        this.it = function(description, fn, timeout) {\r\n            var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\r\n            currentDeclarationSuite.addChild(spec);\r\n            return spec;\r\n        };\r\n\r\n        this.xit = function() {\r\n            var spec = this.it.apply(this, arguments);\r\n            spec.pend();\r\n            return spec;\r\n        };\r\n\r\n        this.fit = function(){\r\n            var spec = this.it.apply(this, arguments);\r\n\r\n            focusedRunnables.push(spec.id);\r\n            unfocusAncestor();\r\n            return spec;\r\n        };\r\n\r\n        this.expect = function(actual) {\r\n            if (!currentRunnable()) {\r\n                throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\r\n            }\r\n\r\n            return currentRunnable().expect(actual);\r\n        };\r\n\r\n        this.beforeEach = function(beforeEachFunction, timeout) {\r\n            currentDeclarationSuite.beforeEach({\r\n                fn: beforeEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.beforeAll = function(beforeAllFunction, timeout) {\r\n            currentDeclarationSuite.beforeAll({\r\n                fn: beforeAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterEach = function(afterEachFunction, timeout) {\r\n            currentDeclarationSuite.afterEach({\r\n                fn: afterEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterAll = function(afterAllFunction, timeout) {\r\n            currentDeclarationSuite.afterAll({\r\n                fn: afterAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.pending = function(message) {\r\n            var fullMessage = j$.Spec.pendingSpecExceptionMessage;\r\n            if(message) {\r\n                fullMessage += message;\r\n            }\r\n            throw fullMessage;\r\n        };\r\n\r\n        this.fail = function(error) {\r\n            var message = 'Failed';\r\n            if (error) {\r\n                message += ': ';\r\n                message += error.message || error;\r\n            }\r\n\r\n            currentRunnable().addExpectationResult(false, {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                message: message,\r\n                error: error && error.message ? error : null\r\n            });\r\n        };\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Env.[constructor].[return]","key":"randomizeTests","newType":"(value: any) => void","isAny":false,"isClass":false,"containerType":"class Env1 {\n    constructor (options: {global: any});\n    addCustomEqualityTester: (tester: any) => void;\n    addMatchers: (matchersToAdd: any) => void;\n    addReporter: (reporterToAdd: any) => void;\n    afterAll: (afterAllFunction: any, timeout: any) => void;\n    afterEach: (afterEachFunction: any, timeout: any) => void;\n    allowRespy: (allow: any) => void;\n    beforeAll: (beforeAllFunction: any, timeout: any) => void;\n    beforeEach: (beforeEachFunction: any, timeout: any) => void;\n    catchExceptions: (value: any) => boolean;\n    catchingExceptions: () => boolean;\n    clock: jasmine.Clock;\n    describe: (description: any, specDefinitions: {call: (arg0: void) => void, length: number}) => jasmine.Suite;\n    execute: (runnablesToRun: string[]) => void;\n    expect: (actual: any) => any;\n    fail: (error: {message: any}) => void;\n    fdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite | {id: any, isFocused: boolean};\n    fit: (description: any, fn: any, timeout: any) => {disabled: boolean} | jasmine.Spec;\n    it: (description: string, fn: () => void, timeout: any) => {disabled: boolean} | jasmine.Spec;\n    pending: (message: string) => void;\n    provideFallbackReporter: (reporterToAdd: any) => void;\n    randomTests: () => boolean;\n    randomizeTests: (value: any) => void;\n    seed: (value: any) => any;\n    specFilter: (spec: jasmine.Spec) => boolean;\n    spyOn: () => interface_490;\n    throwOnExpectationFailure: (value: any) => void;\n    throwingExpectationFailures: () => boolean;\n    topSuite: () => jasmine.Suite;\n    xdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite;\n    xit: () => {pend: (arg0: void) => void};\n}\n","containerDescription":"class jasmine.Env"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.ReportDispatcher.[constructor].[return].provideFallbackReporter","newFunction":"function(reporter) {\r\n            fallbackReporter = reporter;\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.ReportDispatcher.[constructor]","oldFunction":"function ReportDispatcher(methods) {\r\n\r\n        var dispatchedMethods = methods || [];\r\n\r\n        for (var i = 0; i < dispatchedMethods.length; i++) {\r\n            var method = dispatchedMethods[i];\r\n            this[method] = (function(m) {\r\n                return function() {\r\n                    dispatch(m, arguments);\r\n                };\r\n            }(method));\r\n        }\r\n\r\n        var reporters = [];\r\n\r\n        this.addReporter = function(reporter) {\r\n            reporters.push(reporter);\r\n        };\r\n\r\n        return this;\r\n\r\n        function dispatch(method, args) {\r\n            for (var i = 0; i < reporters.length; i++) {\r\n                var reporter = reporters[i];\r\n                if (reporter[method]) {\r\n                    reporter[method].apply(reporter, args);\r\n                }\r\n            }\r\n        }\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.ReportDispatcher.[constructor].[return]","key":"provideFallbackReporter","newType":"(reporter: any) => void","isAny":false,"isClass":false,"containerType":"class ReportDispatcher1 {\n    constructor (methods: string[]);\n    addReporter: (reporter: any) => void;\n    jasmineDone: () => void;\n    jasmineStarted: () => void;\n    provideFallbackReporter: (reporter: any) => void;\n    specDone: () => void;\n    specStarted: () => void;\n    suiteDone: () => void;\n    suiteStarted: () => void;\n}\n","containerDescription":"class jasmine.ReportDispatcher"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Expectation.[constructor].[return].toHaveBeenCalledTimes","newFunction":"function() {\r\n            var args = Array.prototype.slice.call(arguments, 0),\r\n                expected = args.slice(0),\r\n                message = '';\r\n\r\n            args.unshift(this.actual);\r\n\r\n            var matcher = matcherFactory(this.util, this.customEqualityTesters),\r\n                matcherCompare = matcher.compare;\r\n\r\n            function defaultNegativeCompare() {\r\n                var result = matcher.compare.apply(null, args);\r\n                result.pass = !result.pass;\r\n                return result;\r\n            }\r\n\r\n            if (this.isNot) {\r\n                matcherCompare = matcher.negativeCompare || defaultNegativeCompare;\r\n            }\r\n\r\n            var result = matcherCompare.apply(null, args);\r\n\r\n            if (!result.pass) {\r\n                if (!result.message) {\r\n                    args.unshift(this.isNot);\r\n                    args.unshift(name);\r\n                    message = this.util.buildFailureMessage.apply(null, args);\r\n                } else {\r\n                    if (Object.prototype.toString.apply(result.message) === '[object Function]') {\r\n                        message = result.message();\r\n                    } else {\r\n                        message = result.message;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (expected.length == 1) {\r\n                expected = expected[0];\r\n            }\r\n\r\n            // TODO: how many of these params are needed?\r\n            this.addExpectationResult(\r\n                result.pass,\r\n                {\r\n                    matcherName: name,\r\n                    passed: result.pass,\r\n                    message: message,\r\n                    actual: this.actual,\r\n                    expected: expected // TODO: this may need to be arrayified/sliced\r\n                }\r\n            );\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Expectation.[constructor]","oldFunction":"function Expectation(options) {\r\n        this.util = options.util || { buildFailureMessage: function() {} };\r\n        this.customEqualityTesters = options.customEqualityTesters || [];\r\n        this.actual = options.actual;\r\n        this.addExpectationResult = options.addExpectationResult || function(){};\r\n        this.isNot = options.isNot;\r\n\r\n        var customMatchers = options.customMatchers || {};\r\n        for (var matcherName in customMatchers) {\r\n            this[matcherName] = Expectation.prototype.wrapCompare(matcherName, customMatchers[matcherName]);\r\n        }\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Expectation.[constructor].[return]","key":"toHaveBeenCalledTimes","newType":"() => void","isAny":false,"isClass":false,"containerType":"class Expectation1 {\n    constructor (options: interface_686);\n    static Factory: (options: interface_689) => jasmine.Expectation | {not: jasmine.Expectation};\n    static addCoreMatchers: (matchers: interface_691) => void;\n    actual: any;\n    addExpectationResult: () => void;\n    customEqualityTesters: Array<any>;\n    isNot: any;\n    toBe: () => void;\n    toBeCloseTo: () => void;\n    toBeDefined: () => void;\n    toBeFalsy: () => void;\n    toBeGreaterThan: () => void;\n    toBeGreaterThanOrEqual: () => void;\n    toBeLessThan: () => void;\n    toBeLessThanOrEqual: () => void;\n    toBeNaN: () => void;\n    toBeNull: () => void;\n    toBeTruthy: () => void;\n    toBeUndefined: () => void;\n    toContain: () => void;\n    toEqual: () => void;\n    toHaveBeenCalled: () => void;\n    toHaveBeenCalledTimes: () => void;\n    toHaveBeenCalledWith: () => void;\n    toMatch: () => void;\n    toThrow: () => void;\n    toThrowError: () => void;\n    util: {buildFailureMessage: () => void};\n    wrapCompare: (name: any, matcherFactory: (arg0: void, arg1: void) => void) => () => void;\n}\n","containerDescription":"class jasmine.Expectation"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Expectation.[constructor].[return].toBeGreaterThanOrEqual","newFunction":"function() {\r\n            var args = Array.prototype.slice.call(arguments, 0),\r\n                expected = args.slice(0),\r\n                message = '';\r\n\r\n            args.unshift(this.actual);\r\n\r\n            var matcher = matcherFactory(this.util, this.customEqualityTesters),\r\n                matcherCompare = matcher.compare;\r\n\r\n            function defaultNegativeCompare() {\r\n                var result = matcher.compare.apply(null, args);\r\n                result.pass = !result.pass;\r\n                return result;\r\n            }\r\n\r\n            if (this.isNot) {\r\n                matcherCompare = matcher.negativeCompare || defaultNegativeCompare;\r\n            }\r\n\r\n            var result = matcherCompare.apply(null, args);\r\n\r\n            if (!result.pass) {\r\n                if (!result.message) {\r\n                    args.unshift(this.isNot);\r\n                    args.unshift(name);\r\n                    message = this.util.buildFailureMessage.apply(null, args);\r\n                } else {\r\n                    if (Object.prototype.toString.apply(result.message) === '[object Function]') {\r\n                        message = result.message();\r\n                    } else {\r\n                        message = result.message;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (expected.length == 1) {\r\n                expected = expected[0];\r\n            }\r\n\r\n            // TODO: how many of these params are needed?\r\n            this.addExpectationResult(\r\n                result.pass,\r\n                {\r\n                    matcherName: name,\r\n                    passed: result.pass,\r\n                    message: message,\r\n                    actual: this.actual,\r\n                    expected: expected // TODO: this may need to be arrayified/sliced\r\n                }\r\n            );\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Expectation.[constructor]","oldFunction":"function Expectation(options) {\r\n        this.util = options.util || { buildFailureMessage: function() {} };\r\n        this.customEqualityTesters = options.customEqualityTesters || [];\r\n        this.actual = options.actual;\r\n        this.addExpectationResult = options.addExpectationResult || function(){};\r\n        this.isNot = options.isNot;\r\n\r\n        var customMatchers = options.customMatchers || {};\r\n        for (var matcherName in customMatchers) {\r\n            this[matcherName] = Expectation.prototype.wrapCompare(matcherName, customMatchers[matcherName]);\r\n        }\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Expectation.[constructor].[return]","key":"toBeGreaterThanOrEqual","newType":"() => void","isAny":false,"isClass":false,"containerType":"class Expectation1 {\n    constructor (options: interface_686);\n    static Factory: (options: interface_689) => jasmine.Expectation | {not: jasmine.Expectation};\n    static addCoreMatchers: (matchers: interface_691) => void;\n    actual: any;\n    addExpectationResult: () => void;\n    customEqualityTesters: Array<any>;\n    isNot: any;\n    toBe: () => void;\n    toBeCloseTo: () => void;\n    toBeDefined: () => void;\n    toBeFalsy: () => void;\n    toBeGreaterThan: () => void;\n    toBeGreaterThanOrEqual: () => void;\n    toBeLessThan: () => void;\n    toBeLessThanOrEqual: () => void;\n    toBeNaN: () => void;\n    toBeNull: () => void;\n    toBeTruthy: () => void;\n    toBeUndefined: () => void;\n    toContain: () => void;\n    toEqual: () => void;\n    toHaveBeenCalled: () => void;\n    toHaveBeenCalledTimes: () => void;\n    toHaveBeenCalledWith: () => void;\n    toMatch: () => void;\n    toThrow: () => void;\n    toThrowError: () => void;\n    util: {buildFailureMessage: () => void};\n    wrapCompare: (name: any, matcherFactory: (arg0: void, arg1: void) => void) => () => void;\n}\n","containerDescription":"class jasmine.Expectation"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Expectation.[constructor].[return].toBeLessThanOrEqual","newFunction":"function() {\r\n            var args = Array.prototype.slice.call(arguments, 0),\r\n                expected = args.slice(0),\r\n                message = '';\r\n\r\n            args.unshift(this.actual);\r\n\r\n            var matcher = matcherFactory(this.util, this.customEqualityTesters),\r\n                matcherCompare = matcher.compare;\r\n\r\n            function defaultNegativeCompare() {\r\n                var result = matcher.compare.apply(null, args);\r\n                result.pass = !result.pass;\r\n                return result;\r\n            }\r\n\r\n            if (this.isNot) {\r\n                matcherCompare = matcher.negativeCompare || defaultNegativeCompare;\r\n            }\r\n\r\n            var result = matcherCompare.apply(null, args);\r\n\r\n            if (!result.pass) {\r\n                if (!result.message) {\r\n                    args.unshift(this.isNot);\r\n                    args.unshift(name);\r\n                    message = this.util.buildFailureMessage.apply(null, args);\r\n                } else {\r\n                    if (Object.prototype.toString.apply(result.message) === '[object Function]') {\r\n                        message = result.message();\r\n                    } else {\r\n                        message = result.message;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (expected.length == 1) {\r\n                expected = expected[0];\r\n            }\r\n\r\n            // TODO: how many of these params are needed?\r\n            this.addExpectationResult(\r\n                result.pass,\r\n                {\r\n                    matcherName: name,\r\n                    passed: result.pass,\r\n                    message: message,\r\n                    actual: this.actual,\r\n                    expected: expected // TODO: this may need to be arrayified/sliced\r\n                }\r\n            );\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Expectation.[constructor]","oldFunction":"function Expectation(options) {\r\n        this.util = options.util || { buildFailureMessage: function() {} };\r\n        this.customEqualityTesters = options.customEqualityTesters || [];\r\n        this.actual = options.actual;\r\n        this.addExpectationResult = options.addExpectationResult || function(){};\r\n        this.isNot = options.isNot;\r\n\r\n        var customMatchers = options.customMatchers || {};\r\n        for (var matcherName in customMatchers) {\r\n            this[matcherName] = Expectation.prototype.wrapCompare(matcherName, customMatchers[matcherName]);\r\n        }\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Expectation.[constructor].[return]","key":"toBeLessThanOrEqual","newType":"() => void","isAny":false,"isClass":false,"containerType":"class Expectation1 {\n    constructor (options: interface_686);\n    static Factory: (options: interface_689) => jasmine.Expectation | {not: jasmine.Expectation};\n    static addCoreMatchers: (matchers: interface_691) => void;\n    actual: any;\n    addExpectationResult: () => void;\n    customEqualityTesters: Array<any>;\n    isNot: any;\n    toBe: () => void;\n    toBeCloseTo: () => void;\n    toBeDefined: () => void;\n    toBeFalsy: () => void;\n    toBeGreaterThan: () => void;\n    toBeGreaterThanOrEqual: () => void;\n    toBeLessThan: () => void;\n    toBeLessThanOrEqual: () => void;\n    toBeNaN: () => void;\n    toBeNull: () => void;\n    toBeTruthy: () => void;\n    toBeUndefined: () => void;\n    toContain: () => void;\n    toEqual: () => void;\n    toHaveBeenCalled: () => void;\n    toHaveBeenCalledTimes: () => void;\n    toHaveBeenCalledWith: () => void;\n    toMatch: () => void;\n    toThrow: () => void;\n    toThrowError: () => void;\n    util: {buildFailureMessage: () => void};\n    wrapCompare: (name: any, matcherFactory: (arg0: void, arg1: void) => void) => () => void;\n}\n","containerDescription":"class jasmine.Expectation"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor]","newFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor].[return].runnablesExplictlySetGetter","oldFunction":"function() {}","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.Suite.[constructor].[return]","key":"runnablesExplictlySetGetter","isClass":false,"containerType":"class Suite {\n    constructor (attrs: interface_731);\n    addChild: (child: jasmine.Suite | jasmine.Spec | {id: void, isFocused: boolean}) => void;\n    addExpectationResult: () => void;\n    afterAll: (fn: {fn: any, timeout: () => number}) => void;\n    afterAllFns: Array<any>;\n    afterEach: (fn: {fn: any, timeout: () => number}) => void;\n    afterFns: Array<any>;\n    beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n    beforeAllFns: Array<any>;\n    beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n    beforeFns: Array<any>;\n    canBeReentered: () => boolean;\n    children: Array<any>;\n    clonedSharedUserContext: () => any;\n    description: string;\n    disable: () => void;\n    disabled: boolean;\n    env: jasmine.Env;\n    expect: (actual: any) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n    expectationResultFactory: (attrs: interface_722) => interface_724;\n    getFullName: () => string;\n    getResult: () => interface_733;\n    id: string;\n    isExecutable: () => boolean;\n    onException: () => void;\n    parentSuite: any;\n    pend: (message: any) => void;\n    result: interface_735;\n    sharedContext: any;\n    sharedUserContext: () => any;\n    status: () => string;\n    throwOnExpectationFailure: boolean;\n}\n","containerDescription":"class jasmine.Suite"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor]","newFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor].[return].clearStack","oldFunction":"function(fn) {fn();}","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.Suite.[constructor].[return]","key":"clearStack","isClass":false,"containerType":"class Suite {\n    constructor (attrs: interface_731);\n    addChild: (child: jasmine.Suite | jasmine.Spec | {id: void, isFocused: boolean}) => void;\n    addExpectationResult: () => void;\n    afterAll: (fn: {fn: any, timeout: () => number}) => void;\n    afterAllFns: Array<any>;\n    afterEach: (fn: {fn: any, timeout: () => number}) => void;\n    afterFns: Array<any>;\n    beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n    beforeAllFns: Array<any>;\n    beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n    beforeFns: Array<any>;\n    canBeReentered: () => boolean;\n    children: Array<any>;\n    clonedSharedUserContext: () => any;\n    description: string;\n    disable: () => void;\n    disabled: boolean;\n    env: jasmine.Env;\n    expect: (actual: any) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n    expectationResultFactory: (attrs: interface_722) => interface_724;\n    getFullName: () => string;\n    getResult: () => interface_733;\n    id: string;\n    isExecutable: () => boolean;\n    onException: () => void;\n    parentSuite: any;\n    pend: (message: any) => void;\n    result: interface_735;\n    sharedContext: any;\n    sharedUserContext: () => any;\n    status: () => string;\n    throwOnExpectationFailure: boolean;\n}\n","containerDescription":"class jasmine.Suite"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor]","newFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor].[return].onStart","oldFunction":"function() {}","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.Suite.[constructor].[return]","key":"onStart","isClass":false,"containerType":"class Suite {\n    constructor (attrs: interface_731);\n    addChild: (child: jasmine.Suite | jasmine.Spec | {id: void, isFocused: boolean}) => void;\n    addExpectationResult: () => void;\n    afterAll: (fn: {fn: any, timeout: () => number}) => void;\n    afterAllFns: Array<any>;\n    afterEach: (fn: {fn: any, timeout: () => number}) => void;\n    afterFns: Array<any>;\n    beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n    beforeAllFns: Array<any>;\n    beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n    beforeFns: Array<any>;\n    canBeReentered: () => boolean;\n    children: Array<any>;\n    clonedSharedUserContext: () => any;\n    description: string;\n    disable: () => void;\n    disabled: boolean;\n    env: jasmine.Env;\n    expect: (actual: any) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n    expectationResultFactory: (attrs: interface_722) => interface_724;\n    getFullName: () => string;\n    getResult: () => interface_733;\n    id: string;\n    isExecutable: () => boolean;\n    onException: () => void;\n    parentSuite: any;\n    pend: (message: any) => void;\n    result: interface_735;\n    sharedContext: any;\n    sharedUserContext: () => any;\n    status: () => string;\n    throwOnExpectationFailure: boolean;\n}\n","containerDescription":"class jasmine.Suite"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor]","newFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor].[return].resultCallback","oldFunction":"function() {}","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.Suite.[constructor].[return]","key":"resultCallback","isClass":false,"containerType":"class Suite {\n    constructor (attrs: interface_731);\n    addChild: (child: jasmine.Suite | jasmine.Spec | {id: void, isFocused: boolean}) => void;\n    addExpectationResult: () => void;\n    afterAll: (fn: {fn: any, timeout: () => number}) => void;\n    afterAllFns: Array<any>;\n    afterEach: (fn: {fn: any, timeout: () => number}) => void;\n    afterFns: Array<any>;\n    beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n    beforeAllFns: Array<any>;\n    beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n    beforeFns: Array<any>;\n    canBeReentered: () => boolean;\n    children: Array<any>;\n    clonedSharedUserContext: () => any;\n    description: string;\n    disable: () => void;\n    disabled: boolean;\n    env: jasmine.Env;\n    expect: (actual: any) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n    expectationResultFactory: (attrs: interface_722) => interface_724;\n    getFullName: () => string;\n    getResult: () => interface_733;\n    id: string;\n    isExecutable: () => boolean;\n    onException: () => void;\n    parentSuite: any;\n    pend: (message: any) => void;\n    result: interface_735;\n    sharedContext: any;\n    sharedUserContext: () => any;\n    status: () => string;\n    throwOnExpectationFailure: boolean;\n}\n","containerDescription":"class jasmine.Suite"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor]","newFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor].[return].execute","oldFunction":"function(onComplete) {\r\n        var self = this;\r\n\r\n        this.onStart(this);\r\n\r\n        if (this.disabled) {\r\n            complete();\r\n            return;\r\n        }\r\n\r\n        var allFns = [];\r\n\r\n        for (var i = 0; i < this.children.length; i++) {\r\n            allFns.push(wrapChildAsAsync(this.children[i]));\r\n        }\r\n\r\n        if (this.isExecutable()) {\r\n            allFns = this.beforeAllFns.concat(allFns);\r\n            allFns = allFns.concat(this.afterAllFns);\r\n        }\r\n\r\n        this.queueRunner({\r\n            queueableFns: allFns,\r\n            onComplete: complete,\r\n            userContext: this.sharedUserContext(),\r\n            onException: function() { self.onException.apply(self, arguments); }\r\n        });\r\n\r\n        function complete() {\r\n            self.result.status = self.status();\r\n            self.resultCallback(self.result);\r\n\r\n            if (onComplete) {\r\n                onComplete();\r\n            }\r\n        }\r\n\r\n        function wrapChildAsAsync(child) {\r\n            return { fn: function(done) { child.execute(done); } };\r\n        }\r\n    }","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.Suite.[constructor].[return]","key":"execute","isClass":false,"containerType":"class Suite {\n    constructor (attrs: interface_731);\n    addChild: (child: jasmine.Suite | jasmine.Spec | {id: void, isFocused: boolean}) => void;\n    addExpectationResult: () => void;\n    afterAll: (fn: {fn: any, timeout: () => number}) => void;\n    afterAllFns: Array<any>;\n    afterEach: (fn: {fn: any, timeout: () => number}) => void;\n    afterFns: Array<any>;\n    beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n    beforeAllFns: Array<any>;\n    beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n    beforeFns: Array<any>;\n    canBeReentered: () => boolean;\n    children: Array<any>;\n    clonedSharedUserContext: () => any;\n    description: string;\n    disable: () => void;\n    disabled: boolean;\n    env: jasmine.Env;\n    expect: (actual: any) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n    expectationResultFactory: (attrs: interface_722) => interface_724;\n    getFullName: () => string;\n    getResult: () => interface_733;\n    id: string;\n    isExecutable: () => boolean;\n    onException: () => void;\n    parentSuite: any;\n    pend: (message: any) => void;\n    result: interface_735;\n    sharedContext: any;\n    sharedUserContext: () => any;\n    status: () => string;\n    throwOnExpectationFailure: boolean;\n}\n","containerDescription":"class jasmine.Suite"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor]","newFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor].[return].queueRunner","oldFunction":"function(options) {\r\n            options.catchException = catchException;\r\n            options.clearStack = options.clearStack || clearStack;\r\n            options.timer = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\r\n            options.fail = self.fail;\r\n\r\n            new j$.QueueRunner(options).execute();\r\n        }","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.Suite.[constructor].[return]","key":"queueRunner","isClass":false,"containerType":"class Suite {\n    constructor (attrs: interface_731);\n    addChild: (child: jasmine.Suite | jasmine.Spec | {id: void, isFocused: boolean}) => void;\n    addExpectationResult: () => void;\n    afterAll: (fn: {fn: any, timeout: () => number}) => void;\n    afterAllFns: Array<any>;\n    afterEach: (fn: {fn: any, timeout: () => number}) => void;\n    afterFns: Array<any>;\n    beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n    beforeAllFns: Array<any>;\n    beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n    beforeFns: Array<any>;\n    canBeReentered: () => boolean;\n    children: Array<any>;\n    clonedSharedUserContext: () => any;\n    description: string;\n    disable: () => void;\n    disabled: boolean;\n    env: jasmine.Env;\n    expect: (actual: any) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n    expectationResultFactory: (attrs: interface_722) => interface_724;\n    getFullName: () => string;\n    getResult: () => interface_733;\n    id: string;\n    isExecutable: () => boolean;\n    onException: () => void;\n    parentSuite: any;\n    pend: (message: any) => void;\n    result: interface_735;\n    sharedContext: any;\n    sharedUserContext: () => any;\n    status: () => string;\n    throwOnExpectationFailure: boolean;\n}\n","containerDescription":"class jasmine.Suite"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor].[return].pend","newFunction":"function(message) {\r\n        this.markedPending = true;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor]","oldFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Suite.[constructor].[return]","key":"pend","newType":"(message: any) => void","isAny":false,"isClass":false,"containerType":"class Suite {\n    constructor (attrs: interface_731);\n    addChild: (child: jasmine.Suite | jasmine.Spec | {id: void, isFocused: boolean}) => void;\n    addExpectationResult: () => void;\n    afterAll: (fn: {fn: any, timeout: () => number}) => void;\n    afterAllFns: Array<any>;\n    afterEach: (fn: {fn: any, timeout: () => number}) => void;\n    afterFns: Array<any>;\n    beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n    beforeAllFns: Array<any>;\n    beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n    beforeFns: Array<any>;\n    canBeReentered: () => boolean;\n    children: Array<any>;\n    clonedSharedUserContext: () => any;\n    description: string;\n    disable: () => void;\n    disabled: boolean;\n    env: jasmine.Env;\n    expect: (actual: any) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n    expectationResultFactory: (attrs: interface_722) => interface_724;\n    getFullName: () => string;\n    getResult: () => interface_733;\n    id: string;\n    isExecutable: () => boolean;\n    onException: () => void;\n    parentSuite: any;\n    pend: (message: any) => void;\n    result: interface_735;\n    sharedContext: any;\n    sharedUserContext: () => any;\n    status: () => string;\n    throwOnExpectationFailure: boolean;\n}\n","containerDescription":"class jasmine.Suite"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor]","newFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor]","oldFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Suite.[constructor].[return]","key":"throwOnExpectationFailure","newType":"boolean","isAny":false,"isClass":false,"containerType":"class Suite {\n    constructor (attrs: interface_731);\n    addChild: (child: jasmine.Suite | jasmine.Spec | {id: void, isFocused: boolean}) => void;\n    addExpectationResult: () => void;\n    afterAll: (fn: {fn: any, timeout: () => number}) => void;\n    afterAllFns: Array<any>;\n    afterEach: (fn: {fn: any, timeout: () => number}) => void;\n    afterFns: Array<any>;\n    beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n    beforeAllFns: Array<any>;\n    beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n    beforeFns: Array<any>;\n    canBeReentered: () => boolean;\n    children: Array<any>;\n    clonedSharedUserContext: () => any;\n    description: string;\n    disable: () => void;\n    disabled: boolean;\n    env: jasmine.Env;\n    expect: (actual: any) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n    expectationResultFactory: (attrs: interface_722) => interface_724;\n    getFullName: () => string;\n    getResult: () => interface_733;\n    id: string;\n    isExecutable: () => boolean;\n    onException: () => void;\n    parentSuite: any;\n    pend: (message: any) => void;\n    result: interface_735;\n    sharedContext: any;\n    sharedUserContext: () => any;\n    status: () => string;\n    throwOnExpectationFailure: boolean;\n}\n","containerDescription":"class jasmine.Suite"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor].[return].getResult","newFunction":"function() {\r\n        this.result.status = this.status();\r\n        return this.result;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor]","oldFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Suite.[constructor].[return]","key":"getResult","newType":"() => interface_733","isAny":false,"isClass":false,"containerType":"class Suite {\n    constructor (attrs: interface_731);\n    addChild: (child: jasmine.Suite | jasmine.Spec | {id: void, isFocused: boolean}) => void;\n    addExpectationResult: () => void;\n    afterAll: (fn: {fn: any, timeout: () => number}) => void;\n    afterAllFns: Array<any>;\n    afterEach: (fn: {fn: any, timeout: () => number}) => void;\n    afterFns: Array<any>;\n    beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n    beforeAllFns: Array<any>;\n    beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n    beforeFns: Array<any>;\n    canBeReentered: () => boolean;\n    children: Array<any>;\n    clonedSharedUserContext: () => any;\n    description: string;\n    disable: () => void;\n    disabled: boolean;\n    env: jasmine.Env;\n    expect: (actual: any) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n    expectationResultFactory: (attrs: interface_722) => interface_724;\n    getFullName: () => string;\n    getResult: () => interface_733;\n    id: string;\n    isExecutable: () => boolean;\n    onException: () => void;\n    parentSuite: any;\n    pend: (message: any) => void;\n    result: interface_735;\n    sharedContext: any;\n    sharedUserContext: () => any;\n    status: () => string;\n    throwOnExpectationFailure: boolean;\n}\n","containerDescription":"class jasmine.Suite"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor].[return].canBeReentered","newFunction":"function() {\r\n        return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor]","oldFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Suite.[constructor].[return]","key":"canBeReentered","newType":"() => boolean","isAny":false,"isClass":false,"containerType":"class Suite {\n    constructor (attrs: interface_731);\n    addChild: (child: jasmine.Suite | jasmine.Spec | {id: void, isFocused: boolean}) => void;\n    addExpectationResult: () => void;\n    afterAll: (fn: {fn: any, timeout: () => number}) => void;\n    afterAllFns: Array<any>;\n    afterEach: (fn: {fn: any, timeout: () => number}) => void;\n    afterFns: Array<any>;\n    beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n    beforeAllFns: Array<any>;\n    beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n    beforeFns: Array<any>;\n    canBeReentered: () => boolean;\n    children: Array<any>;\n    clonedSharedUserContext: () => any;\n    description: string;\n    disable: () => void;\n    disabled: boolean;\n    env: jasmine.Env;\n    expect: (actual: any) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n    expectationResultFactory: (attrs: interface_722) => interface_724;\n    getFullName: () => string;\n    getResult: () => interface_733;\n    id: string;\n    isExecutable: () => boolean;\n    onException: () => void;\n    parentSuite: any;\n    pend: (message: any) => void;\n    result: interface_735;\n    sharedContext: any;\n    sharedUserContext: () => any;\n    status: () => string;\n    throwOnExpectationFailure: boolean;\n}\n","containerDescription":"class jasmine.Suite"},{"isInOldDec":false,"isInOldDecContainer":true,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.HtmlReporter.[constructor].[return].jasmineDone","newFunction":"function(doneResult) {\r\n            var banner = find('.jasmine-banner');\r\n            var alert = find('.jasmine-alert');\r\n            var order = doneResult && doneResult.order;\r\n            alert.appendChild(createDom('span', {className: 'jasmine-duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));\r\n\r\n            banner.appendChild(\r\n                createDom('div', { className: 'jasmine-run-options' },\r\n                    createDom('span', { className: 'jasmine-trigger' }, 'Options'),\r\n                    createDom('div', { className: 'jasmine-payload' },\r\n                        createDom('div', { className: 'jasmine-exceptions' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-raise',\r\n                                id: 'jasmine-raise-exceptions',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-raise-exceptions' }, 'raise exceptions')),\r\n                        createDom('div', { className: 'jasmine-throw-failures' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-throw',\r\n                                id: 'jasmine-throw-failures',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-throw-failures' }, 'stop spec on expectation failure')),\r\n                        createDom('div', { className: 'jasmine-random-order' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-random',\r\n                                id: 'jasmine-random-order',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-random-order' }, 'run tests in random order'))\r\n                    )\r\n                ));\r\n\r\n            var raiseCheckbox = find('#jasmine-raise-exceptions');\r\n\r\n            raiseCheckbox.checked = !env.catchingExceptions();\r\n            raiseCheckbox.onclick = onRaiseExceptionsClick;\r\n\r\n            var throwCheckbox = find('#jasmine-throw-failures');\r\n            throwCheckbox.checked = env.throwingExpectationFailures();\r\n            throwCheckbox.onclick = onThrowExpectationsClick;\r\n\r\n            var randomCheckbox = find('#jasmine-random-order');\r\n            randomCheckbox.checked = env.randomTests();\r\n            randomCheckbox.onclick = onRandomClick;\r\n\r\n            var optionsMenu = find('.jasmine-run-options'),\r\n                optionsTrigger = optionsMenu.querySelector('.jasmine-trigger'),\r\n                optionsPayload = optionsMenu.querySelector('.jasmine-payload'),\r\n                isOpen = /\\bjasmine-open\\b/;\r\n\r\n            optionsTrigger.onclick = function() {\r\n                if (isOpen.test(optionsPayload.className)) {\r\n                    optionsPayload.className = optionsPayload.className.replace(isOpen, '');\r\n                } else {\r\n                    optionsPayload.className += ' jasmine-open';\r\n                }\r\n            };\r\n\r\n            if (specsExecuted < totalSpecsDefined) {\r\n                var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';\r\n                var skippedLink = order && order.random ? '?random=true' : '?';\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-bar jasmine-skipped'},\r\n                        createDom('a', {href: skippedLink, title: 'Run all specs'}, skippedMessage)\r\n                    )\r\n                );\r\n            }\r\n            var statusBarMessage = '';\r\n            var statusBarClassName = 'jasmine-bar ';\r\n\r\n            if (totalSpecsDefined > 0) {\r\n                statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);\r\n                if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }\r\n                statusBarClassName += (failureCount > 0) ? 'jasmine-failed' : 'jasmine-passed';\r\n            } else {\r\n                statusBarClassName += 'jasmine-skipped';\r\n                statusBarMessage += 'No specs found';\r\n            }\r\n\r\n            var seedBar;\r\n            if (order && order.random) {\r\n                seedBar = createDom('span', {className: 'jasmine-seed-bar'},\r\n                    ', randomized with seed ',\r\n                    createDom('a', {title: 'randomized with seed ' + order.seed, href: seedHref(order.seed)}, order.seed)\r\n                );\r\n            }\r\n\r\n            alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage, seedBar));\r\n\r\n            var errorBarClassName = 'jasmine-bar jasmine-errored';\r\n            var errorBarMessagePrefix = 'AfterAll ';\r\n\r\n            for(var i = 0; i < failedSuites.length; i++) {\r\n                var failedSuite = failedSuites[i];\r\n                for(var j = 0; j < failedSuite.failedExpectations.length; j++) {\r\n                    alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessagePrefix + failedSuite.failedExpectations[j].message));\r\n                }\r\n            }\r\n\r\n            var globalFailures = (doneResult && doneResult.failedExpectations) || [];\r\n            for(i = 0; i < globalFailures.length; i++) {\r\n                var failure = globalFailures[i];\r\n                alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessagePrefix + failure.message));\r\n            }\r\n\r\n            var results = find('.jasmine-results');\r\n            results.appendChild(summary);\r\n\r\n            summaryList(topResults, summary);\r\n\r\n            function summaryList(resultsTree, domParent) {\r\n                var specListNode;\r\n                for (var i = 0; i < resultsTree.children.length; i++) {\r\n                    var resultNode = resultsTree.children[i];\r\n                    if (resultNode.type == 'suite') {\r\n                        var suiteListNode = createDom('ul', {className: 'jasmine-suite', id: 'suite-' + resultNode.result.id},\r\n                            createDom('li', {className: 'jasmine-suite-detail'},\r\n                                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)\r\n                            )\r\n                        );\r\n\r\n                        summaryList(resultNode, suiteListNode);\r\n                        domParent.appendChild(suiteListNode);\r\n                    }\r\n                    if (resultNode.type == 'spec') {\r\n                        if (domParent.getAttribute('class') != 'jasmine-specs') {\r\n                            specListNode = createDom('ul', {className: 'jasmine-specs'});\r\n                            domParent.appendChild(specListNode);\r\n                        }\r\n                        var specDescription = resultNode.result.description;\r\n                        if(noExpectations(resultNode.result)) {\r\n                            specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;\r\n                        }\r\n                        if(resultNode.result.status === 'pending' && resultNode.result.pendingReason !== '') {\r\n                            specDescription = specDescription + ' PENDING WITH MESSAGE: ' + resultNode.result.pendingReason;\r\n                        }\r\n                        specListNode.appendChild(\r\n                            createDom('li', {\r\n                                    className: 'jasmine-' + resultNode.result.status,\r\n                                    id: 'spec-' + resultNode.result.id\r\n                                },\r\n                                createDom('a', {href: specHref(resultNode.result)}, specDescription)\r\n                            )\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (failures.length) {\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-spec-list'},\r\n                        createDom('span', {}, 'Spec List | '),\r\n                        createDom('a', {className: 'jasmine-failures-menu', href: '#'}, 'Failures')));\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-failure-list'},\r\n                        createDom('a', {className: 'jasmine-spec-list-menu', href: '#'}, 'Spec List'),\r\n                        createDom('span', {}, ' | Failures ')));\r\n\r\n                find('.jasmine-failures-menu').onclick = function() {\r\n                    setMenuModeTo('jasmine-failure-list');\r\n                };\r\n                find('.jasmine-spec-list-menu').onclick = function() {\r\n                    setMenuModeTo('jasmine-spec-list');\r\n                };\r\n\r\n                setMenuModeTo('jasmine-failure-list');\r\n\r\n                var failureNode = find('.jasmine-failures');\r\n                for (i = 0; i < failures.length; i++) {\r\n                    failureNode.appendChild(failures[i]);\r\n                }\r\n            }\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.HtmlReporter.[constructor].[return].jasmineDone","oldFunction":"function() {\r\n            var banner = find('.banner');\r\n            banner.appendChild(createDom('span', {className: 'duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));\r\n\r\n            var alert = find('.alert');\r\n\r\n            alert.appendChild(createDom('span', { className: 'exceptions' },\r\n                createDom('label', { className: 'label', 'for': 'raise-exceptions' }, 'raise exceptions'),\r\n                createDom('input', {\r\n                    className: 'raise',\r\n                    id: 'raise-exceptions',\r\n                    type: 'checkbox'\r\n                })\r\n            ));\r\n            var checkbox = find('#raise-exceptions');\r\n\r\n            checkbox.checked = !env.catchingExceptions();\r\n            checkbox.onclick = onRaiseExceptionsClick;\r\n\r\n            if (specsExecuted < totalSpecsDefined) {\r\n                var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'bar skipped'},\r\n                        createDom('a', {href: '?', title: 'Run all specs'}, skippedMessage)\r\n                    )\r\n                );\r\n            }\r\n            var statusBarMessage = '';\r\n            var statusBarClassName = 'bar ';\r\n\r\n            if (totalSpecsDefined > 0) {\r\n                statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);\r\n                if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }\r\n                statusBarClassName += (failureCount > 0) ? 'failed' : 'passed';\r\n            } else {\r\n                statusBarClassName += 'skipped';\r\n                statusBarMessage += 'No specs found';\r\n            }\r\n\r\n            alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage));\r\n\r\n            for(i = 0; i < failedSuites.length; i++) {\r\n                var failedSuite = failedSuites[i];\r\n                for(var j = 0; j < failedSuite.failedExpectations.length; j++) {\r\n                    var errorBarMessage = 'AfterAll ' + failedSuite.failedExpectations[j].message;\r\n                    var errorBarClassName = 'bar errored';\r\n                    alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessage));\r\n                }\r\n            }\r\n\r\n            var results = find('.results');\r\n            results.appendChild(summary);\r\n\r\n            summaryList(topResults, summary);\r\n\r\n            function summaryList(resultsTree, domParent) {\r\n                var specListNode;\r\n                for (var i = 0; i < resultsTree.children.length; i++) {\r\n                    var resultNode = resultsTree.children[i];\r\n                    if (resultNode.type == 'suite') {\r\n                        var suiteListNode = createDom('ul', {className: 'suite', id: 'suite-' + resultNode.result.id},\r\n                            createDom('li', {className: 'suite-detail'},\r\n                                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)\r\n                            )\r\n                        );\r\n\r\n                        summaryList(resultNode, suiteListNode);\r\n                        domParent.appendChild(suiteListNode);\r\n                    }\r\n                    if (resultNode.type == 'spec') {\r\n                        if (domParent.getAttribute('class') != 'specs') {\r\n                            specListNode = createDom('ul', {className: 'specs'});\r\n                            domParent.appendChild(specListNode);\r\n                        }\r\n                        var specDescription = resultNode.result.description;\r\n                        if(noExpectations(resultNode.result)) {\r\n                            specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;\r\n                        }\r\n                        if(resultNode.result.status === 'pending' && resultNode.result.pendingReason !== '') {\r\n                            specDescription = specDescription + ' PENDING WITH MESSAGE: ' + resultNode.result.pendingReason;\r\n                        }\r\n                        specListNode.appendChild(\r\n                            createDom('li', {\r\n                                    className: resultNode.result.status,\r\n                                    id: 'spec-' + resultNode.result.id\r\n                                },\r\n                                createDom('a', {href: specHref(resultNode.result)}, specDescription)\r\n                            )\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (failures.length) {\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'menu bar spec-list'},\r\n                        createDom('span', {}, 'Spec List | '),\r\n                        createDom('a', {className: 'failures-menu', href: '#'}, 'Failures')));\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'menu bar failure-list'},\r\n                        createDom('a', {className: 'spec-list-menu', href: '#'}, 'Spec List'),\r\n                        createDom('span', {}, ' | Failures ')));\r\n\r\n                find('.failures-menu').onclick = function() {\r\n                    setMenuModeTo('failure-list');\r\n                };\r\n                find('.spec-list-menu').onclick = function() {\r\n                    setMenuModeTo('spec-list');\r\n                };\r\n\r\n                setMenuModeTo('failure-list');\r\n\r\n                var failureNode = find('.failures');\r\n                for (var i = 0; i < failures.length; i++) {\r\n                    failureNode.appendChild(failures[i]);\r\n                }\r\n            }\r\n        }","oldJSDoc":null,"type":"changedArgCount","typePath":"window.jasmine.HtmlReporter.[constructor].[return].jasmineDone","isClass":true,"newType":"(doneResult: interface_696) => void","newTypeDescription":"function","oldType":"() => void","oldArgCount":0,"newArgCount":1,"containerType":"class HtmlReporter1 {\n    constructor (options: interface_694);\n    initialize: () => void;\n    jasmineDone: (doneResult: interface_696) => void;\n    jasmineStarted: (options: {totalSpecsDefined: number}) => void;\n    specDone: (result: interface_699) => void;\n    specStarted: (result: any) => void;\n    suiteDone: (result: {status: string}) => void;\n    suiteStarted: (result: any) => void;\n}\n","containerDescription":"class jasmine.HtmlReporter"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor]","newFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor]","oldFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.Suite.[constructor].[return].result","key":"status","isClass":false,"containerType":"interface interface_735 {\n    description: string;\n    failedExpectations: Array<any>;\n    fullName: string;\n    id: string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor].[return].expectationResultFactory","newFunction":"function(attrs) {\r\n                attrs.messageFormatter = exceptionFormatter.message;\r\n                attrs.stackFormatter = exceptionFormatter.stack;\r\n\r\n                return buildExpectationResult(attrs);\r\n            }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor]","oldFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.Suite.[constructor].[return].expectationResultFactory","newType":"(attrs: interface_722) => interface_724","oldType":"any","containerType":"class Suite {\n    constructor (attrs: interface_731);\n    addChild: (child: jasmine.Suite | jasmine.Spec | {id: void, isFocused: boolean}) => void;\n    addExpectationResult: () => void;\n    afterAll: (fn: {fn: any, timeout: () => number}) => void;\n    afterAllFns: Array<any>;\n    afterEach: (fn: {fn: any, timeout: () => number}) => void;\n    afterFns: Array<any>;\n    beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n    beforeAllFns: Array<any>;\n    beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n    beforeFns: Array<any>;\n    canBeReentered: () => boolean;\n    children: Array<any>;\n    clonedSharedUserContext: () => any;\n    description: string;\n    disable: () => void;\n    disabled: boolean;\n    env: jasmine.Env;\n    expect: (actual: any) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n    expectationResultFactory: (attrs: interface_722) => interface_724;\n    getFullName: () => string;\n    getResult: () => interface_733;\n    id: string;\n    isExecutable: () => boolean;\n    onException: () => void;\n    parentSuite: any;\n    pend: (message: any) => void;\n    result: interface_735;\n    sharedContext: any;\n    sharedUserContext: () => any;\n    status: () => string;\n    throwOnExpectationFailure: boolean;\n}\n","containerDescription":"class jasmine.Suite"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor].[return].expectationFactory","newFunction":"function(actual, spec) {\r\n            return j$.Expectation.Factory({\r\n                util: j$.matchersUtil,\r\n                customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\r\n                customMatchers: runnableResources[spec.id].customMatchers,\r\n                actual: actual,\r\n                addExpectationResult: addExpectationResult\r\n            });\r\n\r\n            function addExpectationResult(passed, result) {\r\n                return spec.addExpectationResult(passed, result);\r\n            }\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor]","oldFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.Suite.[constructor].[return].expectationFactory","newType":"(actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation","oldType":"any","containerType":"class Suite {\n    constructor (attrs: interface_731);\n    addChild: (child: jasmine.Suite | jasmine.Spec | {id: void, isFocused: boolean}) => void;\n    addExpectationResult: () => void;\n    afterAll: (fn: {fn: any, timeout: () => number}) => void;\n    afterAllFns: Array<any>;\n    afterEach: (fn: {fn: any, timeout: () => number}) => void;\n    afterFns: Array<any>;\n    beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n    beforeAllFns: Array<any>;\n    beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n    beforeFns: Array<any>;\n    canBeReentered: () => boolean;\n    children: Array<any>;\n    clonedSharedUserContext: () => any;\n    description: string;\n    disable: () => void;\n    disabled: boolean;\n    env: jasmine.Env;\n    expect: (actual: any) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n    expectationResultFactory: (attrs: interface_722) => interface_724;\n    getFullName: () => string;\n    getResult: () => interface_733;\n    id: string;\n    isExecutable: () => boolean;\n    onException: () => void;\n    parentSuite: any;\n    pend: (message: any) => void;\n    result: interface_735;\n    sharedContext: any;\n    sharedUserContext: () => any;\n    status: () => string;\n    throwOnExpectationFailure: boolean;\n}\n","containerDescription":"class jasmine.Suite"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.JsApiReporter.[constructor].[return].jasmineDone","newFunction":"function(runDetails) {\r\n            this.finished = true;\r\n            this.runDetails = runDetails;\r\n            executionTime = timer.elapsed();\r\n            status = 'done';\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.JsApiReporter.[constructor].[return].jasmineDone","oldFunction":"function() {\r\n            this.finished = true;\r\n            executionTime = timer.elapsed();\r\n            status = 'done';\r\n        }","oldJSDoc":null,"type":"changedArgCount","typePath":"window.jasmine.JsApiReporter.[constructor].[return].jasmineDone","isClass":true,"newType":"(runDetails: interface_696) => void","newTypeDescription":"function","oldType":"() => void","oldArgCount":0,"newArgCount":1,"containerType":"class JsApiReporter1 {\n    constructor (options: {timer: any});\n    executionTime: () => number;\n    finished: boolean;\n    jasmineDone: (runDetails: interface_696) => void;\n    jasmineStarted: (arg0: {totalSpecsDefined: number}) => void;\n    runDetails: interface_701;\n    specDone: (result: any) => void;\n    specResults: (index: number, length: string | number) => Array<any>;\n    specs: () => Array<any>;\n    started: boolean;\n    status: () => string;\n    suiteDone: (result: {id: string | number}) => void;\n    suiteResults: (index: number, length: string | number) => Array<any>;\n    suiteStarted: (result: {id: string | number}) => void;\n    suites: () => any;\n}\n","containerDescription":"class jasmine.JsApiReporter"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.DelayedFunctionScheduler.[constructor]","newFunction":"function DelayedFunctionScheduler() {\r\n        var self = this;\r\n        var scheduledLookup = [];\r\n        var scheduledFunctions = {};\r\n        var currentTime = 0;\r\n        var delayedFnCount = 0;\r\n\r\n        self.tick = function(millis, tickDate) {\r\n            millis = millis || 0;\r\n            var endTime = currentTime + millis;\r\n\r\n            runScheduledFunctions(endTime, tickDate);\r\n            currentTime = endTime;\r\n        };\r\n\r\n        self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {\r\n            var f;\r\n            if (typeof(funcToCall) === 'string') {\r\n                /* jshint evil: true */\r\n                f = function() { return eval(funcToCall); };\r\n                /* jshint evil: false */\r\n            } else {\r\n                f = funcToCall;\r\n            }\r\n\r\n            millis = millis || 0;\r\n            timeoutKey = timeoutKey || ++delayedFnCount;\r\n            runAtMillis = runAtMillis || (currentTime + millis);\r\n\r\n            var funcToSchedule = {\r\n                runAtMillis: runAtMillis,\r\n                funcToCall: f,\r\n                recurring: recurring,\r\n                params: params,\r\n                timeoutKey: timeoutKey,\r\n                millis: millis\r\n            };\r\n\r\n            if (runAtMillis in scheduledFunctions) {\r\n                scheduledFunctions[runAtMillis].push(funcToSchedule);\r\n            } else {\r\n                scheduledFunctions[runAtMillis] = [funcToSchedule];\r\n                scheduledLookup.push(runAtMillis);\r\n                scheduledLookup.sort(function (a, b) {\r\n                    return a - b;\r\n                });\r\n            }\r\n\r\n            return timeoutKey;\r\n        };\r\n\r\n        self.removeFunctionWithId = function(timeoutKey) {\r\n            for (var runAtMillis in scheduledFunctions) {\r\n                var funcs = scheduledFunctions[runAtMillis];\r\n                var i = indexOfFirstToPass(funcs, function (func) {\r\n                    return func.timeoutKey === timeoutKey;\r\n                });\r\n\r\n                if (i > -1) {\r\n                    if (funcs.length === 1) {\r\n                        delete scheduledFunctions[runAtMillis];\r\n                        deleteFromLookup(runAtMillis);\r\n                    } else {\r\n                        funcs.splice(i, 1);\r\n                    }\r\n\r\n                    // intervals get rescheduled when executed, so there's never more\r\n                    // than a single scheduled function with a given timeoutKey\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n\r\n        return self;\r\n\r\n        function indexOfFirstToPass(array, testFn) {\r\n            var index = -1;\r\n\r\n            for (var i = 0; i < array.length; ++i) {\r\n                if (testFn(array[i])) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return index;\r\n        }\r\n\r\n        function deleteFromLookup(key) {\r\n            var value = Number(key);\r\n            var i = indexOfFirstToPass(scheduledLookup, function (millis) {\r\n                return millis === value;\r\n            });\r\n\r\n            if (i > -1) {\r\n                scheduledLookup.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        function reschedule(scheduledFn) {\r\n            self.scheduleFunction(scheduledFn.funcToCall,\r\n                scheduledFn.millis,\r\n                scheduledFn.params,\r\n                true,\r\n                scheduledFn.timeoutKey,\r\n                scheduledFn.runAtMillis + scheduledFn.millis);\r\n        }\r\n\r\n        function forEachFunction(funcsToRun, callback) {\r\n            for (var i = 0; i < funcsToRun.length; ++i) {\r\n                callback(funcsToRun[i]);\r\n            }\r\n        }\r\n\r\n        function runScheduledFunctions(endTime, tickDate) {\r\n            tickDate = tickDate || function() {};\r\n            if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {\r\n                tickDate(endTime);\r\n                return;\r\n            }\r\n\r\n            do {\r\n                var newCurrentTime = scheduledLookup.shift();\r\n                tickDate(newCurrentTime - currentTime);\r\n\r\n                currentTime = newCurrentTime;\r\n\r\n                var funcsToRun = scheduledFunctions[currentTime];\r\n                delete scheduledFunctions[currentTime];\r\n\r\n                forEachFunction(funcsToRun, function(funcToRun) {\r\n                    if (funcToRun.recurring) {\r\n                        reschedule(funcToRun);\r\n                    }\r\n                });\r\n\r\n                forEachFunction(funcsToRun, function(funcToRun) {\r\n                    funcToRun.funcToCall.apply(null, funcToRun.params || []);\r\n                });\r\n            } while (scheduledLookup.length > 0 &&\r\n            // checking first if we're out of time prevents setTimeout(0)\r\n            // scheduled in a funcToRun from forcing an extra iteration\r\n            currentTime !== endTime  &&\r\n            scheduledLookup[0] <= endTime);\r\n        }\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.DelayedFunctionScheduler.[constructor].[return].tick","oldFunction":"function(millis) {\r\n            millis = millis || 0;\r\n            var endTime = currentTime + millis;\r\n\r\n            runScheduledFunctions(endTime);\r\n            currentTime = endTime;\r\n        }","oldJSDoc":null,"type":"changedArgCount","typePath":"window.jasmine.DelayedFunctionScheduler.[constructor].[return].tick","isClass":true,"newType":"(millis: number, tickDate: (arg0: void) => void) => void","newTypeDescription":"function","oldType":"(millis: number) => void","oldArgCount":1,"newArgCount":2,"containerType":"class DelayedFunctionScheduler1 {\n    constructor ();\n    removeFunctionWithId: (timeoutKey: any) => void;\n    scheduleFunction: (funcToCall: string | (() => any), millis: number, params: any, recurring: any, timeoutKey: number, newCurrentTime: string) => number;\n    tick: (millis: number, tickDate: (arg0: void) => void) => void;\n}\n","containerDescription":"class jasmine.DelayedFunctionScheduler"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Spec.[constructor].[return].addExpectationResult","newFunction":"function(passed, data, isError) {\r\n        var expectationResult = this.expectationResultFactory(data);\r\n        if (passed) {\r\n            this.result.passedExpectations.push(expectationResult);\r\n        } else {\r\n            this.result.failedExpectations.push(expectationResult);\r\n\r\n            if (this.throwOnExpectationFailure && !isError) {\r\n                throw new j$.errors.ExpectationFailed();\r\n            }\r\n        }\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Spec.[constructor].[return].addExpectationResult","oldFunction":"function(passed, data) {\r\n        var expectationResult = this.expectationResultFactory(data);\r\n        if (passed) {\r\n            this.result.passedExpectations.push(expectationResult);\r\n        } else {\r\n            this.result.failedExpectations.push(expectationResult);\r\n        }\r\n    }","oldJSDoc":null,"type":"changedArgCount","typePath":"window.jasmine.Spec.[constructor].[return].addExpectationResult","isClass":true,"newType":"(passed: boolean, data: interface_716, isError: boolean) => void","newTypeDescription":"function","oldType":"(passed: boolean, data: interface_714) => void","oldArgCount":2,"newArgCount":3,"containerType":"class Spec1 {\n    constructor (attrs: interface_715);\n    static isPendingSpecException: (e: {toString: () => void}) => boolean;\n    static pendingSpecExceptionMessage: string;\n    addExpectationResult: (passed: boolean, data: interface_716, isError: boolean) => void;\n    beforeAndAfterFns: () => {afters: Array<any>, befores: Array<any>};\n    catchingExceptions: () => boolean;\n    description: string;\n    disable: () => void;\n    execute: (onComplete: () => void, enabled: boolean) => void;\n    expect: (actual: any) => any;\n    expectationFactory: any;\n    expectationResultFactory: () => void;\n    getFullName: () => any;\n    getResult: () => {status: string};\n    getSpecName: () => string;\n    id: any;\n    isExecutable: () => boolean;\n    onException: (e: {toString: () => void}) => void;\n    onStart: () => void;\n    pend: (message: any) => void;\n    queueRunnerFactory: () => void;\n    queueableFn: {fn: any};\n    result: interface_718;\n    resultCallback: () => void;\n    status: (enabled: boolean) => string;\n    throwOnExpectationFailure: boolean;\n    userContext: () => any;\n}\n","containerDescription":"class jasmine.Spec"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Spec.[constructor].[return].execute","newFunction":"function(onComplete, enabled) {\r\n        var self = this;\r\n\r\n        this.onStart(this);\r\n\r\n        if (!this.isExecutable() || this.markedPending || enabled === false) {\r\n            complete(enabled);\r\n            return;\r\n        }\r\n\r\n        var fns = this.beforeAndAfterFns();\r\n        var allFns = fns.befores.concat(this.queueableFn).concat(fns.afters);\r\n\r\n        this.queueRunnerFactory({\r\n            queueableFns: allFns,\r\n            onException: function() { self.onException.apply(self, arguments); },\r\n            onComplete: complete,\r\n            userContext: this.userContext()\r\n        });\r\n\r\n        function complete(enabledAgain) {\r\n            self.result.status = self.status(enabledAgain);\r\n            self.resultCallback(self.result);\r\n\r\n            if (onComplete) {\r\n                onComplete();\r\n            }\r\n        }\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Spec.[constructor].[return].execute","oldFunction":"function(onComplete) {\r\n        var self = this;\r\n\r\n        this.onStart(this);\r\n\r\n        if (this.markedPending || this.disabled) {\r\n            complete();\r\n            return;\r\n        }\r\n\r\n        var fns = this.beforeAndAfterFns();\r\n        var allFns = fns.befores.concat(this.queueableFn).concat(fns.afters);\r\n\r\n        this.queueRunnerFactory({\r\n            queueableFns: allFns,\r\n            onException: function() { self.onException.apply(self, arguments); },\r\n            onComplete: complete,\r\n            userContext: this.userContext()\r\n        });\r\n\r\n        function complete() {\r\n            self.result.status = self.status();\r\n            self.resultCallback(self.result);\r\n\r\n            if (onComplete) {\r\n                onComplete();\r\n            }\r\n        }\r\n    }","oldJSDoc":null,"type":"changedArgCount","typePath":"window.jasmine.Spec.[constructor].[return].execute","isClass":true,"newType":"(onComplete: () => void, enabled: boolean) => void","newTypeDescription":"function","oldType":"(onComplete: () => void) => void","oldArgCount":1,"newArgCount":2,"containerType":"class Spec1 {\n    constructor (attrs: interface_715);\n    static isPendingSpecException: (e: {toString: () => void}) => boolean;\n    static pendingSpecExceptionMessage: string;\n    addExpectationResult: (passed: boolean, data: interface_716, isError: boolean) => void;\n    beforeAndAfterFns: () => {afters: Array<any>, befores: Array<any>};\n    catchingExceptions: () => boolean;\n    description: string;\n    disable: () => void;\n    execute: (onComplete: () => void, enabled: boolean) => void;\n    expect: (actual: any) => any;\n    expectationFactory: any;\n    expectationResultFactory: () => void;\n    getFullName: () => any;\n    getResult: () => {status: string};\n    getSpecName: () => string;\n    id: any;\n    isExecutable: () => boolean;\n    onException: (e: {toString: () => void}) => void;\n    onStart: () => void;\n    pend: (message: any) => void;\n    queueRunnerFactory: () => void;\n    queueableFn: {fn: any};\n    result: interface_718;\n    resultCallback: () => void;\n    status: (enabled: boolean) => string;\n    throwOnExpectationFailure: boolean;\n    userContext: () => any;\n}\n","containerDescription":"class jasmine.Spec"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Spec.[constructor].[return].status","newFunction":"function(enabled) {\r\n        if (this.disabled || enabled === false) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.markedPending) {\r\n            return 'pending';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'passed';\r\n        }\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Spec.[constructor].[return].status","oldFunction":"function() {\r\n        if (this.disabled) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.markedPending) {\r\n            return 'pending';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'passed';\r\n        }\r\n    }","oldJSDoc":null,"type":"changedArgCount","typePath":"window.jasmine.Spec.[constructor].[return].status","isClass":true,"newType":"(enabled: boolean) => string","newTypeDescription":"function","oldType":"() => string","oldArgCount":0,"newArgCount":1,"containerType":"class Spec1 {\n    constructor (attrs: interface_715);\n    static isPendingSpecException: (e: {toString: () => void}) => boolean;\n    static pendingSpecExceptionMessage: string;\n    addExpectationResult: (passed: boolean, data: interface_716, isError: boolean) => void;\n    beforeAndAfterFns: () => {afters: Array<any>, befores: Array<any>};\n    catchingExceptions: () => boolean;\n    description: string;\n    disable: () => void;\n    execute: (onComplete: () => void, enabled: boolean) => void;\n    expect: (actual: any) => any;\n    expectationFactory: any;\n    expectationResultFactory: () => void;\n    getFullName: () => any;\n    getResult: () => {status: string};\n    getSpecName: () => string;\n    id: any;\n    isExecutable: () => boolean;\n    onException: (e: {toString: () => void}) => void;\n    onStart: () => void;\n    pend: (message: any) => void;\n    queueRunnerFactory: () => void;\n    queueableFn: {fn: any};\n    result: interface_718;\n    resultCallback: () => void;\n    status: (enabled: boolean) => string;\n    throwOnExpectationFailure: boolean;\n    userContext: () => any;\n}\n","containerDescription":"class jasmine.Spec"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Env.[constructor].[return].fit","newFunction":"function(description, fn, timeout){\r\n            var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\r\n            currentDeclarationSuite.addChild(spec);\r\n            focusedRunnables.push(spec.id);\r\n            unfocusAncestor();\r\n            return spec;\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Env.[constructor].[return].fit","oldFunction":"function(){\r\n            var spec = this.it.apply(this, arguments);\r\n\r\n            focusedRunnables.push(spec.id);\r\n            unfocusAncestor();\r\n            return spec;\r\n        }","oldJSDoc":null,"type":"changedArgCount","typePath":"window.jasmine.Env.[constructor].[return].fit","isClass":true,"newType":"(description: any, fn: any, timeout: any) => {disabled: boolean} | jasmine.Spec","newTypeDescription":"function","oldType":"() => {id: any}","oldArgCount":0,"newArgCount":3,"containerType":"class Env1 {\n    constructor (options: {global: any});\n    addCustomEqualityTester: (tester: any) => void;\n    addMatchers: (matchersToAdd: any) => void;\n    addReporter: (reporterToAdd: any) => void;\n    afterAll: (afterAllFunction: any, timeout: any) => void;\n    afterEach: (afterEachFunction: any, timeout: any) => void;\n    allowRespy: (allow: any) => void;\n    beforeAll: (beforeAllFunction: any, timeout: any) => void;\n    beforeEach: (beforeEachFunction: any, timeout: any) => void;\n    catchExceptions: (value: any) => boolean;\n    catchingExceptions: () => boolean;\n    clock: jasmine.Clock;\n    describe: (description: any, specDefinitions: {call: (arg0: void) => void, length: number}) => jasmine.Suite;\n    execute: (runnablesToRun: string[]) => void;\n    expect: (actual: any) => any;\n    fail: (error: {message: any}) => void;\n    fdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite | {id: any, isFocused: boolean};\n    fit: (description: any, fn: any, timeout: any) => {disabled: boolean} | jasmine.Spec;\n    it: (description: string, fn: () => void, timeout: any) => {disabled: boolean} | jasmine.Spec;\n    pending: (message: string) => void;\n    provideFallbackReporter: (reporterToAdd: any) => void;\n    randomTests: () => boolean;\n    randomizeTests: (value: any) => void;\n    seed: (value: any) => any;\n    specFilter: (spec: jasmine.Spec) => boolean;\n    spyOn: () => interface_490;\n    throwOnExpectationFailure: (value: any) => void;\n    throwingExpectationFailures: () => boolean;\n    topSuite: () => jasmine.Suite;\n    xdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite;\n    xit: () => {pend: (arg0: void) => void};\n}\n","containerDescription":"class jasmine.Env"},{"isInOldDec":false,"isInOldDecContainer":true,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.describe.[function]","newFunction":"function(description, specDefinitions) {\r\n            return env.describe(description, specDefinitions);\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.describe.[function]","oldFunction":"function(description, specDefinitions) {\r\n            return env.describe(description, specDefinitions);\r\n        }","oldJSDoc":null,"type":"addedProperty","typePath":"window.describe.[function].[arg1]","key":"length","newType":"number","isAny":false,"isClass":false,"containerType":"{\n    call: (arg0: void) => void, \n    length: number\n}\n","containerDescription":"object"},{"isInOldDec":true,"isInOldDecContainer":true,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.xdescribe.[function]","newFunction":"function(description, specDefinitions) {\r\n            return env.xdescribe(description, specDefinitions);\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.xdescribe.[function]","oldFunction":"function(description, specDefinitions) {\r\n            return env.xdescribe(description, specDefinitions);\r\n        }","oldJSDoc":null,"type":"changedType","typePath":"window.xdescribe.[function].[arg1]","newType":"{\n    call: (arg0: void) => void\n}\n","oldType":"any","containerType":"(description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.getJasmineRequireObj.[function].[return].TreeProcessor","newFunction":"function() {\r\n    function TreeProcessor(attrs) {\r\n        var tree = attrs.tree,\r\n            runnableIds = attrs.runnableIds,\r\n            queueRunnerFactory = attrs.queueRunnerFactory,\r\n            nodeStart = attrs.nodeStart || function() {},\r\n            nodeComplete = attrs.nodeComplete || function() {},\r\n            orderChildren = attrs.orderChildren || function(node) { return node.children; },\r\n            stats = { valid: true },\r\n            processed = false,\r\n            defaultMin = Infinity,\r\n            defaultMax = 1 - Infinity;\r\n\r\n        this.processTree = function() {\r\n            processNode(tree, false);\r\n            processed = true;\r\n            return stats;\r\n        };\r\n\r\n        this.execute = function(done) {\r\n            if (!processed) {\r\n                this.processTree();\r\n            }\r\n\r\n            if (!stats.valid) {\r\n                throw 'invalid order';\r\n            }\r\n\r\n            var childFns = wrapChildren(tree, 0);\r\n\r\n            queueRunnerFactory({\r\n                queueableFns: childFns,\r\n                userContext: tree.sharedUserContext(),\r\n                onException: function() {\r\n                    tree.onException.apply(tree, arguments);\r\n                },\r\n                onComplete: done\r\n            });\r\n        };\r\n\r\n        function runnableIndex(id) {\r\n            for (var i = 0; i < runnableIds.length; i++) {\r\n                if (runnableIds[i] === id) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n\r\n        function processNode(node, parentEnabled) {\r\n            var executableIndex = runnableIndex(node.id);\r\n\r\n            if (executableIndex !== undefined) {\r\n                parentEnabled = true;\r\n            }\r\n\r\n            parentEnabled = parentEnabled && node.isExecutable();\r\n\r\n            if (!node.children) {\r\n                stats[node.id] = {\r\n                    executable: parentEnabled && node.isExecutable(),\r\n                    segments: [{\r\n                        index: 0,\r\n                        owner: node,\r\n                        nodes: [node],\r\n                        min: startingMin(executableIndex),\r\n                        max: startingMax(executableIndex)\r\n                    }]\r\n                };\r\n            } else {\r\n                var hasExecutableChild = false;\r\n\r\n                var orderedChildren = orderChildren(node);\r\n\r\n                for (var i = 0; i < orderedChildren.length; i++) {\r\n                    var child = orderedChildren[i];\r\n\r\n                    processNode(child, parentEnabled);\r\n\r\n                    if (!stats.valid) {\r\n                        return;\r\n                    }\r\n\r\n                    var childStats = stats[child.id];\r\n\r\n                    hasExecutableChild = hasExecutableChild || childStats.executable;\r\n                }\r\n\r\n                stats[node.id] = {\r\n                    executable: hasExecutableChild\r\n                };\r\n\r\n                segmentChildren(node, orderedChildren, stats[node.id], executableIndex);\r\n\r\n                if (!node.canBeReentered() && stats[node.id].segments.length > 1) {\r\n                    stats = { valid: false };\r\n                }\r\n            }\r\n        }\r\n\r\n        function startingMin(executableIndex) {\r\n            return executableIndex === undefined ? defaultMin : executableIndex;\r\n        }\r\n\r\n        function startingMax(executableIndex) {\r\n            return executableIndex === undefined ? defaultMax : executableIndex;\r\n        }\r\n\r\n        function segmentChildren(node, orderedChildren, nodeStats, executableIndex) {\r\n            var currentSegment = { index: 0, owner: node, nodes: [], min: startingMin(executableIndex), max: startingMax(executableIndex) },\r\n                result = [currentSegment],\r\n                lastMax = defaultMax,\r\n                orderedChildSegments = orderChildSegments(orderedChildren);\r\n\r\n            function isSegmentBoundary(minIndex) {\r\n                return lastMax !== defaultMax && minIndex !== defaultMin && lastMax < minIndex - 1;\r\n            }\r\n\r\n            for (var i = 0; i < orderedChildSegments.length; i++) {\r\n                var childSegment = orderedChildSegments[i],\r\n                    maxIndex = childSegment.max,\r\n                    minIndex = childSegment.min;\r\n\r\n                if (isSegmentBoundary(minIndex)) {\r\n                    currentSegment = {index: result.length, owner: node, nodes: [], min: defaultMin, max: defaultMax};\r\n                    result.push(currentSegment);\r\n                }\r\n\r\n                currentSegment.nodes.push(childSegment);\r\n                currentSegment.min = Math.min(currentSegment.min, minIndex);\r\n                currentSegment.max = Math.max(currentSegment.max, maxIndex);\r\n                lastMax = maxIndex;\r\n            }\r\n\r\n            nodeStats.segments = result;\r\n        }\r\n\r\n        function orderChildSegments(children) {\r\n            var specifiedOrder = [],\r\n                unspecifiedOrder = [];\r\n\r\n            for (var i = 0; i < children.length; i++) {\r\n                var child = children[i],\r\n                    segments = stats[child.id].segments;\r\n\r\n                for (var j = 0; j < segments.length; j++) {\r\n                    var seg = segments[j];\r\n\r\n                    if (seg.min === defaultMin) {\r\n                        unspecifiedOrder.push(seg);\r\n                    } else {\r\n                        specifiedOrder.push(seg);\r\n                    }\r\n                }\r\n            }\r\n\r\n            specifiedOrder.sort(function(a, b) {\r\n                return a.min - b.min;\r\n            });\r\n\r\n            return specifiedOrder.concat(unspecifiedOrder);\r\n        }\r\n\r\n        function executeNode(node, segmentNumber) {\r\n            if (node.children) {\r\n                return {\r\n                    fn: function(done) {\r\n                        nodeStart(node);\r\n\r\n                        queueRunnerFactory({\r\n                            onComplete: function() {\r\n                                nodeComplete(node, node.getResult());\r\n                                done();\r\n                            },\r\n                            queueableFns: wrapChildren(node, segmentNumber),\r\n                            userContext: node.sharedUserContext(),\r\n                            onException: function() {\r\n                                node.onException.apply(node, arguments);\r\n                            }\r\n                        });\r\n                    }\r\n                };\r\n            } else {\r\n                return {\r\n                    fn: function(done) { node.execute(done, stats[node.id].executable); }\r\n                };\r\n            }\r\n        }\r\n\r\n        function wrapChildren(node, segmentNumber) {\r\n            var result = [],\r\n                segmentChildren = stats[node.id].segments[segmentNumber].nodes;\r\n\r\n            for (var i = 0; i < segmentChildren.length; i++) {\r\n                result.push(executeNode(segmentChildren[i].owner, segmentChildren[i].index));\r\n            }\r\n\r\n            if (!stats[node.id].executable) {\r\n                return result;\r\n            }\r\n\r\n            return node.beforeAllFns.concat(result).concat(node.afterAllFns);\r\n        }\r\n    }\r\n\r\n    return TreeProcessor;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.getJasmineRequireObj.[function]","oldFunction":"function getJasmineRequire() {\r\n        return jasmineRequire;\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.getJasmineRequireObj.[function].[return]","key":"TreeProcessor","newType":"() => (attrs: interface_840) => void","isAny":false,"isClass":false,"containerType":"interface interface_676 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.getJasmineRequireObj.[function].[return].toHaveBeenCalledTimes","newFunction":"function(j$) {\r\n\r\n    var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalledTimes>', 'expect(<spyObj>).toHaveBeenCalledTimes(<Number>)');\r\n\r\n    function toHaveBeenCalledTimes() {\r\n        return {\r\n            compare: function(actual, expected) {\r\n                if (!j$.isSpy(actual)) {\r\n                    throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));\r\n                }\r\n\r\n                var args = Array.prototype.slice.call(arguments, 0),\r\n                    result = { pass: false };\r\n\r\n                if (!j$.isNumber_(expected)){\r\n                    throw new Error(getErrorMsg('The expected times failed is a required argument and must be a number.'));\r\n                }\r\n\r\n                actual = args[0];\r\n                var calls = actual.calls.count();\r\n                var timesMessage = expected === 1 ? 'once' : expected + ' times';\r\n                result.pass = calls === expected;\r\n                result.message = result.pass ?\r\n                'Expected spy ' + actual.and.identity() + ' not to have been called ' + timesMessage + '. It was called ' +  calls + ' times.' :\r\n                'Expected spy ' + actual.and.identity() + ' to have been called ' + timesMessage + '. It was called ' +  calls + ' times.';\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n\r\n    return toHaveBeenCalledTimes;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.getJasmineRequireObj.[function]","oldFunction":"function getJasmineRequire() {\r\n        return jasmineRequire;\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.getJasmineRequireObj.[function].[return]","key":"toHaveBeenCalledTimes","newType":"(j$: interface_893) => () => interface_895","isAny":false,"isClass":false,"containerType":"interface interface_676 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.getJasmineRequireObj.[function].[return].toBeGreaterThanOrEqual","newFunction":"function() {\r\n\r\n    function toBeGreaterThanOrEqual() {\r\n        return {\r\n            compare: function(actual, expected) {\r\n                return {\r\n                    pass: actual >= expected\r\n                };\r\n            }\r\n        };\r\n    }\r\n\r\n    return toBeGreaterThanOrEqual;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.getJasmineRequireObj.[function]","oldFunction":"function getJasmineRequire() {\r\n        return jasmineRequire;\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.getJasmineRequireObj.[function].[return]","key":"toBeGreaterThanOrEqual","newType":"() => () => interface_882","isAny":false,"isClass":false,"containerType":"interface interface_676 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.getJasmineRequireObj.[function].[return].toBeLessThanOrEqual","newFunction":"function() {\r\n    function toBeLessThanOrEqual() {\r\n        return {\r\n\r\n            compare: function(actual, expected) {\r\n                return {\r\n                    pass: actual <= expected\r\n                };\r\n            }\r\n        };\r\n    }\r\n\r\n    return toBeLessThanOrEqual;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.getJasmineRequireObj.[function]","oldFunction":"function getJasmineRequire() {\r\n        return jasmineRequire;\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.getJasmineRequireObj.[function].[return]","key":"toBeLessThanOrEqual","newType":"() => () => interface_884","isAny":false,"isClass":false,"containerType":"interface interface_676 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.getJasmineRequireObj.[function].[return].Order","newFunction":"function() {\r\n    function Order(options) {\r\n        this.random = 'random' in options ? options.random : true;\r\n        var seed = this.seed = options.seed || generateSeed();\r\n        this.sort = this.random ? randomOrder : naturalOrder;\r\n\r\n        function naturalOrder(items) {\r\n            return items;\r\n        }\r\n\r\n        function randomOrder(items) {\r\n            var copy = items.slice();\r\n            copy.sort(function(a, b) {\r\n                return jenkinsHash(seed + a.id) - jenkinsHash(seed + b.id);\r\n            });\r\n            return copy;\r\n        }\r\n\r\n        function generateSeed() {\r\n            return String(Math.random()).slice(-5);\r\n        }\r\n\r\n        // Bob Jenkins One-at-a-Time Hash algorithm is a non-cryptographic hash function\r\n        // used to get a different output when the key changes slighly.\r\n        // We use your return to sort the children randomly in a consistent way when\r\n        // used in conjunction with a seed\r\n\r\n        function jenkinsHash(key) {\r\n            var hash, i;\r\n            for(hash = i = 0; i < key.length; ++i) {\r\n                hash += key.charCodeAt(i);\r\n                hash += (hash << 10);\r\n                hash ^= (hash >> 6);\r\n            }\r\n            hash += (hash << 3);\r\n            hash ^= (hash >> 11);\r\n            hash += (hash << 15);\r\n            return hash;\r\n        }\r\n\r\n    }\r\n\r\n    return Order;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.getJasmineRequireObj.[function]","oldFunction":"function getJasmineRequire() {\r\n        return jasmineRequire;\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.getJasmineRequireObj.[function].[return]","key":"Order","newType":"() => (options: {random: boolean, seed: any}) => void","isAny":false,"isClass":false,"containerType":"interface interface_676 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.getJasmineRequireObj.[function].[return].errors","newFunction":"function() {\r\n    function ExpectationFailed() {}\r\n\r\n    ExpectationFailed.prototype = new Error();\r\n    ExpectationFailed.prototype.constructor = ExpectationFailed;\r\n\r\n    return {\r\n        ExpectationFailed: ExpectationFailed\r\n    };\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.getJasmineRequireObj.[function]","oldFunction":"function getJasmineRequire() {\r\n        return jasmineRequire;\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.getJasmineRequireObj.[function].[return]","key":"errors","newType":"() => interface_870","isAny":false,"isClass":false,"containerType":"interface interface_676 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.getJasmineRequireObj.[function].[return].formatErrorMsg","newFunction":"function() {\r\n    function generateErrorMsg(domain, usage) {\r\n        var usageDefinition = usage ? '\\nUsage: ' + usage : '';\r\n\r\n        return function errorMsg(msg) {\r\n            return domain + ' : ' + msg + usageDefinition;\r\n        };\r\n    }\r\n\r\n    return generateErrorMsg;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.getJasmineRequireObj.[function]","oldFunction":"function getJasmineRequire() {\r\n        return jasmineRequire;\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.getJasmineRequireObj.[function].[return]","key":"formatErrorMsg","newType":"() => (domain: string | number, usage: string | number) => (msg: string | number) => string","isAny":false,"isClass":false,"containerType":"interface interface_676 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n","containerDescription":"object"},{"isInOldDec":true,"isInOldDecContainer":true,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.fit.[function]","newFunction":"function() {\r\n            return env.fit.apply(env, arguments);\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.fit.[function]","oldFunction":"function() {\r\n            return env.fit.apply(env, arguments);\r\n        }","oldJSDoc":null,"type":"changedType","typePath":"window.fit.[function].[return]","newType":"{disabled: boolean} | jasmine.Spec","oldType":"{\n    id: any\n}\n","containerType":"() => {disabled: boolean} | jasmine.Spec","containerDescription":"function"},{"isInOldDec":true,"isInOldDecContainer":true,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.xdescribe.[function]","newFunction":"function(description, specDefinitions) {\r\n            return env.xdescribe(description, specDefinitions);\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.xdescribe.[function]","oldFunction":"function(description, specDefinitions) {\r\n            return env.xdescribe(description, specDefinitions);\r\n        }","oldJSDoc":null,"type":"changedType","typePath":"window.xdescribe.[function].[return]","newType":"jasmine.Suite","oldType":"{\n    disable: () => void\n}\n","containerType":"(description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":true,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.xit.[function]","newFunction":"function() {\r\n            return env.xit.apply(env, arguments);\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.xit.[function]","oldFunction":"function() {\r\n            return env.xit.apply(env, arguments);\r\n        }","oldJSDoc":null,"type":"changedArgCount","typePath":"window.xit.[function].[return].pend","isClass":false,"newType":"(arg0: void) => void","newTypeDescription":"function","oldType":"() => void","oldArgCount":0,"newArgCount":1,"containerType":"{\n    pend: (arg0: void) => void\n}\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.toHaveBeenCalledWith.[function]","newFunction":"function(j$) {\r\n\r\n    var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalledWith>', 'expect(<spyObj>).toHaveBeenCalledWith(...arguments)');\r\n\r\n    function toHaveBeenCalledWith(util, customEqualityTesters) {\r\n        return {\r\n            compare: function() {\r\n                var args = Array.prototype.slice.call(arguments, 0),\r\n                    actual = args[0],\r\n                    expectedArgs = args.slice(1),\r\n                    result = { pass: false };\r\n\r\n                if (!j$.isSpy(actual)) {\r\n                    throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));\r\n                }\r\n\r\n                if (!actual.calls.any()) {\r\n                    result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but it was never called.'; };\r\n                    return result;\r\n                }\r\n\r\n                if (util.contains(actual.calls.allArgs(), expectedArgs, customEqualityTesters)) {\r\n                    result.pass = true;\r\n                    result.message = function() { return 'Expected spy ' + actual.and.identity() + ' not to have been called with ' + j$.pp(expectedArgs) + ' but it was.'; };\r\n                } else {\r\n                    result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but actual calls were ' + j$.pp(actual.calls.allArgs()).replace(/^\\[ | \\]$/g, '') + '.'; };\r\n                }\r\n\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n\r\n    return toHaveBeenCalledWith;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.toHaveBeenCalledWith.[function]","oldFunction":"function(j$) {\r\n\r\n    function toHaveBeenCalledWith(util, customEqualityTesters) {\r\n        return {\r\n            compare: function() {\r\n                var args = Array.prototype.slice.call(arguments, 0),\r\n                    actual = args[0],\r\n                    expectedArgs = args.slice(1),\r\n                    result = { pass: false };\r\n\r\n                if (!j$.isSpy(actual)) {\r\n                    throw new Error('Expected a spy, but got ' + j$.pp(actual) + '.');\r\n                }\r\n\r\n                if (!actual.calls.any()) {\r\n                    result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but it was never called.'; };\r\n                    return result;\r\n                }\r\n\r\n                if (util.contains(actual.calls.allArgs(), expectedArgs, customEqualityTesters)) {\r\n                    result.pass = true;\r\n                    result.message = function() { return 'Expected spy ' + actual.and.identity() + ' not to have been called with ' + j$.pp(expectedArgs) + ' but it was.'; };\r\n                } else {\r\n                    result.message = function() { return 'Expected spy ' + actual.and.identity() + ' to have been called with ' + j$.pp(expectedArgs) + ' but actual calls were ' + j$.pp(actual.calls.allArgs()).replace(/^\\[ | \\]$/g, '') + '.'; };\r\n                }\r\n\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n\r\n    return toHaveBeenCalledWith;\r\n}","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.toHaveBeenCalledWith.[function].[arg0]","key":"formatErrorMsg","newType":"(arg0: void, arg1: void) => void","isAny":false,"isClass":false,"containerType":"// Seen as: j$\ninterface interface_896 {\n    formatErrorMsg: (arg0: void, arg1: void) => void;\n    isSpy: (arg0: void) => void;\n    pp: (arg0: void) => void;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.isSpy.[function]","newFunction":"function(putativeSpy) {\r\n        if (!putativeSpy) {\r\n            return false;\r\n        }\r\n        return putativeSpy.and instanceof j$.SpyStrategy &&\r\n            putativeSpy.calls instanceof j$.CallTracker;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.isSpy.[function]","oldFunction":"function(putativeSpy) {\r\n        if (!putativeSpy) {\r\n            return false;\r\n        }\r\n        return putativeSpy.and instanceof j$.SpyStrategy &&\r\n            putativeSpy.calls instanceof j$.CallTracker;\r\n    }","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.isSpy.[function].[arg0]","key":"test","isClass":false,"containerType":"// Seen as: actual, putativeSpy, value\ninterface interface_751 {\n    and: {identity: void};\n    calls: {allArgs: void, any: void, count: void};\n    jasmineToString: void;\n    nodeType: any;\n    toString: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.toThrow.[function]","newFunction":"function(j$) {\r\n\r\n    var getErrorMsg = j$.formatErrorMsg('<toThrow>', 'expect(function() {<expectation>}).toThrow()');\r\n\r\n    function toThrow(util) {\r\n        return {\r\n            compare: function(actual, expected) {\r\n                var result = { pass: false },\r\n                    threw = false,\r\n                    thrown;\r\n\r\n                if (typeof actual != 'function') {\r\n                    throw new Error(getErrorMsg('Actual is not a Function'));\r\n                }\r\n\r\n                try {\r\n                    actual();\r\n                } catch (e) {\r\n                    threw = true;\r\n                    thrown = e;\r\n                }\r\n\r\n                if (!threw) {\r\n                    result.message = 'Expected function to throw an exception.';\r\n                    return result;\r\n                }\r\n\r\n                if (arguments.length == 1) {\r\n                    result.pass = true;\r\n                    result.message = function() { return 'Expected function not to throw, but it threw ' + j$.pp(thrown) + '.'; };\r\n\r\n                    return result;\r\n                }\r\n\r\n                if (util.equals(thrown, expected)) {\r\n                    result.pass = true;\r\n                    result.message = function() { return 'Expected function not to throw ' + j$.pp(expected) + '.'; };\r\n                } else {\r\n                    result.message = function() { return 'Expected function to throw ' + j$.pp(expected) + ', but it threw ' +  j$.pp(thrown) + '.'; };\r\n                }\r\n\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n\r\n    return toThrow;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.toThrow.[function]","oldFunction":"function(j$) {\r\n\r\n    function toThrow(util) {\r\n        return {\r\n            compare: function(actual, expected) {\r\n                var result = { pass: false },\r\n                    threw = false,\r\n                    thrown;\r\n\r\n                if (typeof actual != 'function') {\r\n                    throw new Error('Actual is not a Function');\r\n                }\r\n\r\n                try {\r\n                    actual();\r\n                } catch (e) {\r\n                    threw = true;\r\n                    thrown = e;\r\n                }\r\n\r\n                if (!threw) {\r\n                    result.message = 'Expected function to throw an exception.';\r\n                    return result;\r\n                }\r\n\r\n                if (arguments.length == 1) {\r\n                    result.pass = true;\r\n                    result.message = function() { return 'Expected function not to throw, but it threw ' + j$.pp(thrown) + '.'; };\r\n\r\n                    return result;\r\n                }\r\n\r\n                if (util.equals(thrown, expected)) {\r\n                    result.pass = true;\r\n                    result.message = function() { return 'Expected function not to throw ' + j$.pp(expected) + '.'; };\r\n                } else {\r\n                    result.message = function() { return 'Expected function to throw ' + j$.pp(expected) + ', but it threw ' +  j$.pp(thrown) + '.'; };\r\n                }\r\n\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n\r\n    return toThrow;\r\n}","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.toThrow.[function].[arg0]","key":"formatErrorMsg","newType":"(arg0: void, arg1: void) => void","isAny":false,"isClass":false,"containerType":"// Seen as: j$\ninterface interface_901 {\n    formatErrorMsg: (arg0: void, arg1: void) => void;\n    pp: (arg0: void) => void;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.fnNameFor.[function]","newFunction":"function(func) {\r\n        if (func.name) {\r\n            return func.name;\r\n        }\r\n\r\n        var matches = func.toString().match(/^\\s*function\\s*(\\w*)\\s*\\(/);\r\n        return matches ? matches[1] : '<anonymous>';\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.fnNameFor.[function]","oldFunction":"function(func) {\r\n        return func.name || func.toString().match(/^\\s*function\\s*(\\w*)\\s*\\(/)[1];\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.fnNameFor.[function].[return]","newType":"string","oldType":"any","containerType":"(func: {name: any, test: void, toString: () => void}) => string","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.Env.[function]","newFunction":"function(j$) {\r\n    function Env(options) {\r\n        options = options || {};\r\n\r\n        var self = this;\r\n        var global = options.global || j$.getGlobal();\r\n\r\n        var totalSpecsDefined = 0;\r\n\r\n        var catchExceptions = true;\r\n\r\n        var realSetTimeout = j$.getGlobal().setTimeout;\r\n        var realClearTimeout = j$.getGlobal().clearTimeout;\r\n        this.clock = new j$.Clock(global, function () { return new j$.DelayedFunctionScheduler(); }, new j$.MockDate(global));\r\n\r\n        var runnableResources = {};\r\n\r\n        var currentSpec = null;\r\n        var currentlyExecutingSuites = [];\r\n        var currentDeclarationSuite = null;\r\n        var throwOnExpectationFailure = false;\r\n        var random = false;\r\n        var seed = null;\r\n\r\n        var currentSuite = function() {\r\n            return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\r\n        };\r\n\r\n        var currentRunnable = function() {\r\n            return currentSpec || currentSuite();\r\n        };\r\n\r\n        var reporter = new j$.ReportDispatcher([\r\n            'jasmineStarted',\r\n            'jasmineDone',\r\n            'suiteStarted',\r\n            'suiteDone',\r\n            'specStarted',\r\n            'specDone'\r\n        ]);\r\n\r\n        this.specFilter = function() {\r\n            return true;\r\n        };\r\n\r\n        this.addCustomEqualityTester = function(tester) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Custom Equalities must be added in a before function or a spec');\r\n            }\r\n            runnableResources[currentRunnable().id].customEqualityTesters.push(tester);\r\n        };\r\n\r\n        this.addMatchers = function(matchersToAdd) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Matchers must be added in a before function or a spec');\r\n            }\r\n            var customMatchers = runnableResources[currentRunnable().id].customMatchers;\r\n            for (var matcherName in matchersToAdd) {\r\n                customMatchers[matcherName] = matchersToAdd[matcherName];\r\n            }\r\n        };\r\n\r\n        j$.Expectation.addCoreMatchers(j$.matchers);\r\n\r\n        var nextSpecId = 0;\r\n        var getNextSpecId = function() {\r\n            return 'spec' + nextSpecId++;\r\n        };\r\n\r\n        var nextSuiteId = 0;\r\n        var getNextSuiteId = function() {\r\n            return 'suite' + nextSuiteId++;\r\n        };\r\n\r\n        var expectationFactory = function(actual, spec) {\r\n            return j$.Expectation.Factory({\r\n                util: j$.matchersUtil,\r\n                customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\r\n                customMatchers: runnableResources[spec.id].customMatchers,\r\n                actual: actual,\r\n                addExpectationResult: addExpectationResult\r\n            });\r\n\r\n            function addExpectationResult(passed, result) {\r\n                return spec.addExpectationResult(passed, result);\r\n            }\r\n        };\r\n\r\n        var defaultResourcesForRunnable = function(id, parentRunnableId) {\r\n            var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};\r\n\r\n            if(runnableResources[parentRunnableId]){\r\n                resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);\r\n                resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);\r\n            }\r\n\r\n            runnableResources[id] = resources;\r\n        };\r\n\r\n        var clearResourcesForRunnable = function(id) {\r\n            spyRegistry.clearSpies();\r\n            delete runnableResources[id];\r\n        };\r\n\r\n        var beforeAndAfterFns = function(suite) {\r\n            return function() {\r\n                var befores = [],\r\n                    afters = [];\r\n\r\n                while(suite) {\r\n                    befores = befores.concat(suite.beforeFns);\r\n                    afters = afters.concat(suite.afterFns);\r\n\r\n                    suite = suite.parentSuite;\r\n                }\r\n\r\n                return {\r\n                    befores: befores.reverse(),\r\n                    afters: afters\r\n                };\r\n            };\r\n        };\r\n\r\n        var getSpecName = function(spec, suite) {\r\n            var fullName = [spec.description],\r\n                suiteFullName = suite.getFullName();\r\n\r\n            if (suiteFullName !== '') {\r\n                fullName.unshift(suiteFullName);\r\n            }\r\n            return fullName.join(' ');\r\n        };\r\n\r\n        // TODO: we may just be able to pass in the fn instead of wrapping here\r\n        var buildExpectationResult = j$.buildExpectationResult,\r\n            exceptionFormatter = new j$.ExceptionFormatter(),\r\n            expectationResultFactory = function(attrs) {\r\n                attrs.messageFormatter = exceptionFormatter.message;\r\n                attrs.stackFormatter = exceptionFormatter.stack;\r\n\r\n                return buildExpectationResult(attrs);\r\n            };\r\n\r\n        // TODO: fix this naming, and here's where the value comes in\r\n        this.catchExceptions = function(value) {\r\n            catchExceptions = !!value;\r\n            return catchExceptions;\r\n        };\r\n\r\n        this.catchingExceptions = function() {\r\n            return catchExceptions;\r\n        };\r\n\r\n        var maximumSpecCallbackDepth = 20;\r\n        var currentSpecCallbackDepth = 0;\r\n\r\n        function clearStack(fn) {\r\n            currentSpecCallbackDepth++;\r\n            if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {\r\n                currentSpecCallbackDepth = 0;\r\n                realSetTimeout(fn, 0);\r\n            } else {\r\n                fn();\r\n            }\r\n        }\r\n\r\n        var catchException = function(e) {\r\n            return j$.Spec.isPendingSpecException(e) || catchExceptions;\r\n        };\r\n\r\n        this.throwOnExpectationFailure = function(value) {\r\n            throwOnExpectationFailure = !!value;\r\n        };\r\n\r\n        this.throwingExpectationFailures = function() {\r\n            return throwOnExpectationFailure;\r\n        };\r\n\r\n        this.randomizeTests = function(value) {\r\n            random = !!value;\r\n        };\r\n\r\n        this.randomTests = function() {\r\n            return random;\r\n        };\r\n\r\n        this.seed = function(value) {\r\n            if (value) {\r\n                seed = value;\r\n            }\r\n            return seed;\r\n        };\r\n\r\n        var queueRunnerFactory = function(options) {\r\n            options.catchException = catchException;\r\n            options.clearStack = options.clearStack || clearStack;\r\n            options.timeout = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\r\n            options.fail = self.fail;\r\n\r\n            new j$.QueueRunner(options).execute();\r\n        };\r\n\r\n        var topSuite = new j$.Suite({\r\n            env: this,\r\n            id: getNextSuiteId(),\r\n            description: 'Jasmine__TopLevel__Suite',\r\n            expectationFactory: expectationFactory,\r\n            expectationResultFactory: expectationResultFactory\r\n        });\r\n        defaultResourcesForRunnable(topSuite.id);\r\n        currentDeclarationSuite = topSuite;\r\n\r\n        this.topSuite = function() {\r\n            return topSuite;\r\n        };\r\n\r\n        this.execute = function(runnablesToRun) {\r\n            if(!runnablesToRun) {\r\n                if (focusedRunnables.length) {\r\n                    runnablesToRun = focusedRunnables;\r\n                } else {\r\n                    runnablesToRun = [topSuite.id];\r\n                }\r\n            }\r\n\r\n            var order = new j$.Order({\r\n                random: random,\r\n                seed: seed\r\n            });\r\n\r\n            var processor = new j$.TreeProcessor({\r\n                tree: topSuite,\r\n                runnableIds: runnablesToRun,\r\n                queueRunnerFactory: queueRunnerFactory,\r\n                nodeStart: function(suite) {\r\n                    currentlyExecutingSuites.push(suite);\r\n                    defaultResourcesForRunnable(suite.id, suite.parentSuite.id);\r\n                    reporter.suiteStarted(suite.result);\r\n                },\r\n                nodeComplete: function(suite, result) {\r\n                    if (!suite.disabled) {\r\n                        clearResourcesForRunnable(suite.id);\r\n                    }\r\n                    currentlyExecutingSuites.pop();\r\n                    reporter.suiteDone(result);\r\n                },\r\n                orderChildren: function(node) {\r\n                    return order.sort(node.children);\r\n                }\r\n            });\r\n\r\n            if(!processor.processTree().valid) {\r\n                throw new Error('Invalid order: would cause a beforeAll or afterAll to be run multiple times');\r\n            }\r\n\r\n            reporter.jasmineStarted({\r\n                totalSpecsDefined: totalSpecsDefined\r\n            });\r\n\r\n            currentlyExecutingSuites.push(topSuite);\r\n\r\n            processor.execute(function() {\r\n                clearResourcesForRunnable(topSuite.id);\r\n                currentlyExecutingSuites.pop();\r\n\r\n                reporter.jasmineDone({\r\n                    order: order,\r\n                    failedExpectations: topSuite.result.failedExpectations\r\n                });\r\n            });\r\n        };\r\n\r\n        this.addReporter = function(reporterToAdd) {\r\n            reporter.addReporter(reporterToAdd);\r\n        };\r\n\r\n        this.provideFallbackReporter = function(reporterToAdd) {\r\n            reporter.provideFallbackReporter(reporterToAdd);\r\n        };\r\n\r\n        var spyRegistry = new j$.SpyRegistry({currentSpies: function() {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Spies must be created in a before function or a spec');\r\n            }\r\n            return runnableResources[currentRunnable().id].spies;\r\n        }});\r\n\r\n        this.allowRespy = function(allow){\r\n            spyRegistry.allowRespy(allow);\r\n        };\r\n\r\n        this.spyOn = function() {\r\n            return spyRegistry.spyOn.apply(spyRegistry, arguments);\r\n        };\r\n\r\n        var suiteFactory = function(description) {\r\n            var suite = new j$.Suite({\r\n                env: self,\r\n                id: getNextSuiteId(),\r\n                description: description,\r\n                parentSuite: currentDeclarationSuite,\r\n                expectationFactory: expectationFactory,\r\n                expectationResultFactory: expectationResultFactory,\r\n                throwOnExpectationFailure: throwOnExpectationFailure\r\n            });\r\n\r\n            return suite;\r\n        };\r\n\r\n        this.describe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            if (specDefinitions.length > 0) {\r\n                throw new Error('describe does not expect any arguments');\r\n            }\r\n            if (currentDeclarationSuite.markedPending) {\r\n                suite.pend();\r\n            }\r\n            addSpecsToSuite(suite, specDefinitions);\r\n            return suite;\r\n        };\r\n\r\n        this.xdescribe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            suite.pend();\r\n            addSpecsToSuite(suite, specDefinitions);\r\n            return suite;\r\n        };\r\n\r\n        var focusedRunnables = [];\r\n\r\n        this.fdescribe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            suite.isFocused = true;\r\n\r\n            focusedRunnables.push(suite.id);\r\n            unfocusAncestor();\r\n            addSpecsToSuite(suite, specDefinitions);\r\n\r\n            return suite;\r\n        };\r\n\r\n        function addSpecsToSuite(suite, specDefinitions) {\r\n            var parentSuite = currentDeclarationSuite;\r\n            parentSuite.addChild(suite);\r\n            currentDeclarationSuite = suite;\r\n\r\n            var declarationError = null;\r\n            try {\r\n                specDefinitions.call(suite);\r\n            } catch (e) {\r\n                declarationError = e;\r\n            }\r\n\r\n            if (declarationError) {\r\n                self.it('encountered a declaration exception', function() {\r\n                    throw declarationError;\r\n                });\r\n            }\r\n\r\n            currentDeclarationSuite = parentSuite;\r\n        }\r\n\r\n        function findFocusedAncestor(suite) {\r\n            while (suite) {\r\n                if (suite.isFocused) {\r\n                    return suite.id;\r\n                }\r\n                suite = suite.parentSuite;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        function unfocusAncestor() {\r\n            var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\r\n            if (focusedAncestor) {\r\n                for (var i = 0; i < focusedRunnables.length; i++) {\r\n                    if (focusedRunnables[i] === focusedAncestor) {\r\n                        focusedRunnables.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var specFactory = function(description, fn, suite, timeout) {\r\n            totalSpecsDefined++;\r\n            var spec = new j$.Spec({\r\n                id: getNextSpecId(),\r\n                beforeAndAfterFns: beforeAndAfterFns(suite),\r\n                expectationFactory: expectationFactory,\r\n                resultCallback: specResultCallback,\r\n                getSpecName: function(spec) {\r\n                    return getSpecName(spec, suite);\r\n                },\r\n                onStart: specStarted,\r\n                description: description,\r\n                expectationResultFactory: expectationResultFactory,\r\n                queueRunnerFactory: queueRunnerFactory,\r\n                userContext: function() { return suite.clonedSharedUserContext(); },\r\n                queueableFn: {\r\n                    fn: fn,\r\n                    timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n                },\r\n                throwOnExpectationFailure: throwOnExpectationFailure\r\n            });\r\n\r\n            if (!self.specFilter(spec)) {\r\n                spec.disable();\r\n            }\r\n\r\n            return spec;\r\n\r\n            function specResultCallback(result) {\r\n                clearResourcesForRunnable(spec.id);\r\n                currentSpec = null;\r\n                reporter.specDone(result);\r\n            }\r\n\r\n            function specStarted(spec) {\r\n                currentSpec = spec;\r\n                defaultResourcesForRunnable(spec.id, suite.id);\r\n                reporter.specStarted(spec.result);\r\n            }\r\n        };\r\n\r\n        this.it = function(description, fn, timeout) {\r\n            var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\r\n            if (currentDeclarationSuite.markedPending) {\r\n                spec.pend();\r\n            }\r\n            currentDeclarationSuite.addChild(spec);\r\n            return spec;\r\n        };\r\n\r\n        this.xit = function() {\r\n            var spec = this.it.apply(this, arguments);\r\n            spec.pend('Temporarily disabled with xit');\r\n            return spec;\r\n        };\r\n\r\n        this.fit = function(description, fn, timeout){\r\n            var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\r\n            currentDeclarationSuite.addChild(spec);\r\n            focusedRunnables.push(spec.id);\r\n            unfocusAncestor();\r\n            return spec;\r\n        };\r\n\r\n        this.expect = function(actual) {\r\n            if (!currentRunnable()) {\r\n                throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\r\n            }\r\n\r\n            return currentRunnable().expect(actual);\r\n        };\r\n\r\n        this.beforeEach = function(beforeEachFunction, timeout) {\r\n            currentDeclarationSuite.beforeEach({\r\n                fn: beforeEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.beforeAll = function(beforeAllFunction, timeout) {\r\n            currentDeclarationSuite.beforeAll({\r\n                fn: beforeAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterEach = function(afterEachFunction, timeout) {\r\n            currentDeclarationSuite.afterEach({\r\n                fn: afterEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterAll = function(afterAllFunction, timeout) {\r\n            currentDeclarationSuite.afterAll({\r\n                fn: afterAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.pending = function(message) {\r\n            var fullMessage = j$.Spec.pendingSpecExceptionMessage;\r\n            if(message) {\r\n                fullMessage += message;\r\n            }\r\n            throw fullMessage;\r\n        };\r\n\r\n        this.fail = function(error) {\r\n            var message = 'Failed';\r\n            if (error) {\r\n                message += ': ';\r\n                message += error.message || error;\r\n            }\r\n\r\n            currentRunnable().addExpectationResult(false, {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                message: message,\r\n                error: error && error.message ? error : null\r\n            });\r\n        };\r\n    }\r\n\r\n    return Env;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.Env.[function]","oldFunction":"function(j$) {\r\n    function Env(options) {\r\n        options = options || {};\r\n\r\n        var self = this;\r\n        var global = options.global || j$.getGlobal();\r\n\r\n        var totalSpecsDefined = 0;\r\n\r\n        var catchExceptions = true;\r\n\r\n        var realSetTimeout = j$.getGlobal().setTimeout;\r\n        var realClearTimeout = j$.getGlobal().clearTimeout;\r\n        this.clock = new j$.Clock(global, new j$.DelayedFunctionScheduler(), new j$.MockDate(global));\r\n\r\n        var runnableLookupTable = {};\r\n        var runnableResources = {};\r\n\r\n        var currentSpec = null;\r\n        var currentlyExecutingSuites = [];\r\n        var currentDeclarationSuite = null;\r\n\r\n        var currentSuite = function() {\r\n            return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\r\n        };\r\n\r\n        var currentRunnable = function() {\r\n            return currentSpec || currentSuite();\r\n        };\r\n\r\n        var reporter = new j$.ReportDispatcher([\r\n            'jasmineStarted',\r\n            'jasmineDone',\r\n            'suiteStarted',\r\n            'suiteDone',\r\n            'specStarted',\r\n            'specDone'\r\n        ]);\r\n\r\n        this.specFilter = function() {\r\n            return true;\r\n        };\r\n\r\n        this.addCustomEqualityTester = function(tester) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Custom Equalities must be added in a before function or a spec');\r\n            }\r\n            runnableResources[currentRunnable().id].customEqualityTesters.push(tester);\r\n        };\r\n\r\n        this.addMatchers = function(matchersToAdd) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Matchers must be added in a before function or a spec');\r\n            }\r\n            var customMatchers = runnableResources[currentRunnable().id].customMatchers;\r\n            for (var matcherName in matchersToAdd) {\r\n                customMatchers[matcherName] = matchersToAdd[matcherName];\r\n            }\r\n        };\r\n\r\n        j$.Expectation.addCoreMatchers(j$.matchers);\r\n\r\n        var nextSpecId = 0;\r\n        var getNextSpecId = function() {\r\n            return 'spec' + nextSpecId++;\r\n        };\r\n\r\n        var nextSuiteId = 0;\r\n        var getNextSuiteId = function() {\r\n            return 'suite' + nextSuiteId++;\r\n        };\r\n\r\n        var expectationFactory = function(actual, spec) {\r\n            return j$.Expectation.Factory({\r\n                util: j$.matchersUtil,\r\n                customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\r\n                customMatchers: runnableResources[spec.id].customMatchers,\r\n                actual: actual,\r\n                addExpectationResult: addExpectationResult\r\n            });\r\n\r\n            function addExpectationResult(passed, result) {\r\n                return spec.addExpectationResult(passed, result);\r\n            }\r\n        };\r\n\r\n        var defaultResourcesForRunnable = function(id, parentRunnableId) {\r\n            var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};\r\n\r\n            if(runnableResources[parentRunnableId]){\r\n                resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);\r\n                resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);\r\n            }\r\n\r\n            runnableResources[id] = resources;\r\n        };\r\n\r\n        var clearResourcesForRunnable = function(id) {\r\n            spyRegistry.clearSpies();\r\n            delete runnableResources[id];\r\n        };\r\n\r\n        var beforeAndAfterFns = function(suite, runnablesExplictlySet) {\r\n            return function() {\r\n                var befores = [],\r\n                    afters = [],\r\n                    beforeAlls = [],\r\n                    afterAlls = [];\r\n\r\n                while(suite) {\r\n                    befores = befores.concat(suite.beforeFns);\r\n                    afters = afters.concat(suite.afterFns);\r\n\r\n                    if (runnablesExplictlySet()) {\r\n                        beforeAlls = beforeAlls.concat(suite.beforeAllFns);\r\n                        afterAlls = afterAlls.concat(suite.afterAllFns);\r\n                    }\r\n\r\n                    suite = suite.parentSuite;\r\n                }\r\n                return {\r\n                    befores: beforeAlls.reverse().concat(befores.reverse()),\r\n                    afters: afters.concat(afterAlls)\r\n                };\r\n            };\r\n        };\r\n\r\n        var getSpecName = function(spec, suite) {\r\n            return suite.getFullName() + ' ' + spec.description;\r\n        };\r\n\r\n        // TODO: we may just be able to pass in the fn instead of wrapping here\r\n        var buildExpectationResult = j$.buildExpectationResult,\r\n            exceptionFormatter = new j$.ExceptionFormatter(),\r\n            expectationResultFactory = function(attrs) {\r\n                attrs.messageFormatter = exceptionFormatter.message;\r\n                attrs.stackFormatter = exceptionFormatter.stack;\r\n\r\n                return buildExpectationResult(attrs);\r\n            };\r\n\r\n        // TODO: fix this naming, and here's where the value comes in\r\n        this.catchExceptions = function(value) {\r\n            catchExceptions = !!value;\r\n            return catchExceptions;\r\n        };\r\n\r\n        this.catchingExceptions = function() {\r\n            return catchExceptions;\r\n        };\r\n\r\n        var maximumSpecCallbackDepth = 20;\r\n        var currentSpecCallbackDepth = 0;\r\n\r\n        function clearStack(fn) {\r\n            currentSpecCallbackDepth++;\r\n            if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {\r\n                currentSpecCallbackDepth = 0;\r\n                realSetTimeout(fn, 0);\r\n            } else {\r\n                fn();\r\n            }\r\n        }\r\n\r\n        var catchException = function(e) {\r\n            return j$.Spec.isPendingSpecException(e) || catchExceptions;\r\n        };\r\n\r\n        var queueRunnerFactory = function(options) {\r\n            options.catchException = catchException;\r\n            options.clearStack = options.clearStack || clearStack;\r\n            options.timer = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\r\n            options.fail = self.fail;\r\n\r\n            new j$.QueueRunner(options).execute();\r\n        };\r\n\r\n        var topSuite = new j$.Suite({\r\n            env: this,\r\n            id: getNextSuiteId(),\r\n            description: 'Jasmine__TopLevel__Suite',\r\n            queueRunner: queueRunnerFactory\r\n        });\r\n        runnableLookupTable[topSuite.id] = topSuite;\r\n        defaultResourcesForRunnable(topSuite.id);\r\n        currentDeclarationSuite = topSuite;\r\n\r\n        this.topSuite = function() {\r\n            return topSuite;\r\n        };\r\n\r\n        this.execute = function(runnablesToRun) {\r\n            if(runnablesToRun) {\r\n                runnablesExplictlySet = true;\r\n            } else if (focusedRunnables.length) {\r\n                runnablesExplictlySet = true;\r\n                runnablesToRun = focusedRunnables;\r\n            } else {\r\n                runnablesToRun = [topSuite.id];\r\n            }\r\n\r\n            var allFns = [];\r\n            for(var i = 0; i < runnablesToRun.length; i++) {\r\n                var runnable = runnableLookupTable[runnablesToRun[i]];\r\n                allFns.push((function(runnable) { return { fn: function(done) { runnable.execute(done); } }; })(runnable));\r\n            }\r\n\r\n            reporter.jasmineStarted({\r\n                totalSpecsDefined: totalSpecsDefined\r\n            });\r\n\r\n            queueRunnerFactory({queueableFns: allFns, onComplete: reporter.jasmineDone});\r\n        };\r\n\r\n        this.addReporter = function(reporterToAdd) {\r\n            reporter.addReporter(reporterToAdd);\r\n        };\r\n\r\n        var spyRegistry = new j$.SpyRegistry({currentSpies: function() {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Spies must be created in a before function or a spec');\r\n            }\r\n            return runnableResources[currentRunnable().id].spies;\r\n        }});\r\n\r\n        this.spyOn = function() {\r\n            return spyRegistry.spyOn.apply(spyRegistry, arguments);\r\n        };\r\n\r\n        var suiteFactory = function(description) {\r\n            var suite = new j$.Suite({\r\n                env: self,\r\n                id: getNextSuiteId(),\r\n                description: description,\r\n                parentSuite: currentDeclarationSuite,\r\n                queueRunner: queueRunnerFactory,\r\n                onStart: suiteStarted,\r\n                expectationFactory: expectationFactory,\r\n                expectationResultFactory: expectationResultFactory,\r\n                runnablesExplictlySetGetter: runnablesExplictlySetGetter,\r\n                resultCallback: function(attrs) {\r\n                    if (!suite.disabled) {\r\n                        clearResourcesForRunnable(suite.id);\r\n                    }\r\n                    currentlyExecutingSuites.pop();\r\n                    reporter.suiteDone(attrs);\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[suite.id] = suite;\r\n            return suite;\r\n\r\n            function suiteStarted(suite) {\r\n                currentlyExecutingSuites.push(suite);\r\n                defaultResourcesForRunnable(suite.id, suite.parentSuite.id);\r\n                reporter.suiteStarted(suite.result);\r\n            }\r\n        };\r\n\r\n        this.describe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            addSpecsToSuite(suite, specDefinitions);\r\n            return suite;\r\n        };\r\n\r\n        this.xdescribe = function(description, specDefinitions) {\r\n            var suite = this.describe(description, specDefinitions);\r\n            suite.disable();\r\n            return suite;\r\n        };\r\n\r\n        var focusedRunnables = [];\r\n\r\n        this.fdescribe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            suite.isFocused = true;\r\n\r\n            focusedRunnables.push(suite.id);\r\n            unfocusAncestor();\r\n            addSpecsToSuite(suite, specDefinitions);\r\n\r\n            return suite;\r\n        };\r\n\r\n        function addSpecsToSuite(suite, specDefinitions) {\r\n            var parentSuite = currentDeclarationSuite;\r\n            parentSuite.addChild(suite);\r\n            currentDeclarationSuite = suite;\r\n\r\n            var declarationError = null;\r\n            try {\r\n                specDefinitions.call(suite);\r\n            } catch (e) {\r\n                declarationError = e;\r\n            }\r\n\r\n            if (declarationError) {\r\n                self.it('encountered a declaration exception', function() {\r\n                    throw declarationError;\r\n                });\r\n            }\r\n\r\n            currentDeclarationSuite = parentSuite;\r\n        }\r\n\r\n        function findFocusedAncestor(suite) {\r\n            while (suite) {\r\n                if (suite.isFocused) {\r\n                    return suite.id;\r\n                }\r\n                suite = suite.parentSuite;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        function unfocusAncestor() {\r\n            var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\r\n            if (focusedAncestor) {\r\n                for (var i = 0; i < focusedRunnables.length; i++) {\r\n                    if (focusedRunnables[i] === focusedAncestor) {\r\n                        focusedRunnables.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var runnablesExplictlySet = false;\r\n\r\n        var runnablesExplictlySetGetter = function(){\r\n            return runnablesExplictlySet;\r\n        };\r\n\r\n        var specFactory = function(description, fn, suite, timeout) {\r\n            totalSpecsDefined++;\r\n            var spec = new j$.Spec({\r\n                id: getNextSpecId(),\r\n                beforeAndAfterFns: beforeAndAfterFns(suite, runnablesExplictlySetGetter),\r\n                expectationFactory: expectationFactory,\r\n                resultCallback: specResultCallback,\r\n                getSpecName: function(spec) {\r\n                    return getSpecName(spec, suite);\r\n                },\r\n                onStart: specStarted,\r\n                description: description,\r\n                expectationResultFactory: expectationResultFactory,\r\n                queueRunnerFactory: queueRunnerFactory,\r\n                userContext: function() { return suite.clonedSharedUserContext(); },\r\n                queueableFn: {\r\n                    fn: fn,\r\n                    timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[spec.id] = spec;\r\n\r\n            if (!self.specFilter(spec)) {\r\n                spec.disable();\r\n            }\r\n\r\n            return spec;\r\n\r\n            function specResultCallback(result) {\r\n                clearResourcesForRunnable(spec.id);\r\n                currentSpec = null;\r\n                reporter.specDone(result);\r\n            }\r\n\r\n            function specStarted(spec) {\r\n                currentSpec = spec;\r\n                defaultResourcesForRunnable(spec.id, suite.id);\r\n                reporter.specStarted(spec.result);\r\n            }\r\n        };\r\n\r\n        this.it = function(description, fn, timeout) {\r\n            var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\r\n            currentDeclarationSuite.addChild(spec);\r\n            return spec;\r\n        };\r\n\r\n        this.xit = function() {\r\n            var spec = this.it.apply(this, arguments);\r\n            spec.pend();\r\n            return spec;\r\n        };\r\n\r\n        this.fit = function(){\r\n            var spec = this.it.apply(this, arguments);\r\n\r\n            focusedRunnables.push(spec.id);\r\n            unfocusAncestor();\r\n            return spec;\r\n        };\r\n\r\n        this.expect = function(actual) {\r\n            if (!currentRunnable()) {\r\n                throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\r\n            }\r\n\r\n            return currentRunnable().expect(actual);\r\n        };\r\n\r\n        this.beforeEach = function(beforeEachFunction, timeout) {\r\n            currentDeclarationSuite.beforeEach({\r\n                fn: beforeEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.beforeAll = function(beforeAllFunction, timeout) {\r\n            currentDeclarationSuite.beforeAll({\r\n                fn: beforeAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterEach = function(afterEachFunction, timeout) {\r\n            currentDeclarationSuite.afterEach({\r\n                fn: afterEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterAll = function(afterAllFunction, timeout) {\r\n            currentDeclarationSuite.afterAll({\r\n                fn: afterAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.pending = function(message) {\r\n            var fullMessage = j$.Spec.pendingSpecExceptionMessage;\r\n            if(message) {\r\n                fullMessage += message;\r\n            }\r\n            throw fullMessage;\r\n        };\r\n\r\n        this.fail = function(error) {\r\n            var message = 'Failed';\r\n            if (error) {\r\n                message += ': ';\r\n                message += error.message || error;\r\n            }\r\n\r\n            currentRunnable().addExpectationResult(false, {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                message: message,\r\n                error: error && error.message ? error : null\r\n            });\r\n        };\r\n    }\r\n\r\n    return Env;\r\n}","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.Env.[function].[arg0]","key":"Order","newType":"(arg0: void) => void","isAny":false,"isClass":false,"containerType":"// Seen as: j$\ninterface interface_802 {\n    Clock: (arg0: void, arg1: void, arg2: void) => void;\n    DEFAULT_TIMEOUT_INTERVAL: any;\n    DelayedFunctionScheduler: () => void;\n    ExceptionFormatter: () => void;\n    Expectation: interface_800;\n    MockDate: (arg0: void) => void;\n    Order: (arg0: void) => void;\n    QueueRunner: (arg0: void) => void;\n    ReportDispatcher: (arg0: void) => void;\n    Spec: interface_540;\n    SpyRegistry: (arg0: void) => void;\n    Suite: (arg0: void) => void;\n    TreeProcessor: (arg0: void) => void;\n    buildExpectationResult: (arg0: void) => void;\n    getGlobal: () => void;\n    matchers: any;\n    matchersUtil: any;\n    util: {clone: (arg0: void) => void};\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.Env.[function]","newFunction":"function(j$) {\r\n    function Env(options) {\r\n        options = options || {};\r\n\r\n        var self = this;\r\n        var global = options.global || j$.getGlobal();\r\n\r\n        var totalSpecsDefined = 0;\r\n\r\n        var catchExceptions = true;\r\n\r\n        var realSetTimeout = j$.getGlobal().setTimeout;\r\n        var realClearTimeout = j$.getGlobal().clearTimeout;\r\n        this.clock = new j$.Clock(global, function () { return new j$.DelayedFunctionScheduler(); }, new j$.MockDate(global));\r\n\r\n        var runnableResources = {};\r\n\r\n        var currentSpec = null;\r\n        var currentlyExecutingSuites = [];\r\n        var currentDeclarationSuite = null;\r\n        var throwOnExpectationFailure = false;\r\n        var random = false;\r\n        var seed = null;\r\n\r\n        var currentSuite = function() {\r\n            return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\r\n        };\r\n\r\n        var currentRunnable = function() {\r\n            return currentSpec || currentSuite();\r\n        };\r\n\r\n        var reporter = new j$.ReportDispatcher([\r\n            'jasmineStarted',\r\n            'jasmineDone',\r\n            'suiteStarted',\r\n            'suiteDone',\r\n            'specStarted',\r\n            'specDone'\r\n        ]);\r\n\r\n        this.specFilter = function() {\r\n            return true;\r\n        };\r\n\r\n        this.addCustomEqualityTester = function(tester) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Custom Equalities must be added in a before function or a spec');\r\n            }\r\n            runnableResources[currentRunnable().id].customEqualityTesters.push(tester);\r\n        };\r\n\r\n        this.addMatchers = function(matchersToAdd) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Matchers must be added in a before function or a spec');\r\n            }\r\n            var customMatchers = runnableResources[currentRunnable().id].customMatchers;\r\n            for (var matcherName in matchersToAdd) {\r\n                customMatchers[matcherName] = matchersToAdd[matcherName];\r\n            }\r\n        };\r\n\r\n        j$.Expectation.addCoreMatchers(j$.matchers);\r\n\r\n        var nextSpecId = 0;\r\n        var getNextSpecId = function() {\r\n            return 'spec' + nextSpecId++;\r\n        };\r\n\r\n        var nextSuiteId = 0;\r\n        var getNextSuiteId = function() {\r\n            return 'suite' + nextSuiteId++;\r\n        };\r\n\r\n        var expectationFactory = function(actual, spec) {\r\n            return j$.Expectation.Factory({\r\n                util: j$.matchersUtil,\r\n                customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\r\n                customMatchers: runnableResources[spec.id].customMatchers,\r\n                actual: actual,\r\n                addExpectationResult: addExpectationResult\r\n            });\r\n\r\n            function addExpectationResult(passed, result) {\r\n                return spec.addExpectationResult(passed, result);\r\n            }\r\n        };\r\n\r\n        var defaultResourcesForRunnable = function(id, parentRunnableId) {\r\n            var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};\r\n\r\n            if(runnableResources[parentRunnableId]){\r\n                resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);\r\n                resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);\r\n            }\r\n\r\n            runnableResources[id] = resources;\r\n        };\r\n\r\n        var clearResourcesForRunnable = function(id) {\r\n            spyRegistry.clearSpies();\r\n            delete runnableResources[id];\r\n        };\r\n\r\n        var beforeAndAfterFns = function(suite) {\r\n            return function() {\r\n                var befores = [],\r\n                    afters = [];\r\n\r\n                while(suite) {\r\n                    befores = befores.concat(suite.beforeFns);\r\n                    afters = afters.concat(suite.afterFns);\r\n\r\n                    suite = suite.parentSuite;\r\n                }\r\n\r\n                return {\r\n                    befores: befores.reverse(),\r\n                    afters: afters\r\n                };\r\n            };\r\n        };\r\n\r\n        var getSpecName = function(spec, suite) {\r\n            var fullName = [spec.description],\r\n                suiteFullName = suite.getFullName();\r\n\r\n            if (suiteFullName !== '') {\r\n                fullName.unshift(suiteFullName);\r\n            }\r\n            return fullName.join(' ');\r\n        };\r\n\r\n        // TODO: we may just be able to pass in the fn instead of wrapping here\r\n        var buildExpectationResult = j$.buildExpectationResult,\r\n            exceptionFormatter = new j$.ExceptionFormatter(),\r\n            expectationResultFactory = function(attrs) {\r\n                attrs.messageFormatter = exceptionFormatter.message;\r\n                attrs.stackFormatter = exceptionFormatter.stack;\r\n\r\n                return buildExpectationResult(attrs);\r\n            };\r\n\r\n        // TODO: fix this naming, and here's where the value comes in\r\n        this.catchExceptions = function(value) {\r\n            catchExceptions = !!value;\r\n            return catchExceptions;\r\n        };\r\n\r\n        this.catchingExceptions = function() {\r\n            return catchExceptions;\r\n        };\r\n\r\n        var maximumSpecCallbackDepth = 20;\r\n        var currentSpecCallbackDepth = 0;\r\n\r\n        function clearStack(fn) {\r\n            currentSpecCallbackDepth++;\r\n            if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {\r\n                currentSpecCallbackDepth = 0;\r\n                realSetTimeout(fn, 0);\r\n            } else {\r\n                fn();\r\n            }\r\n        }\r\n\r\n        var catchException = function(e) {\r\n            return j$.Spec.isPendingSpecException(e) || catchExceptions;\r\n        };\r\n\r\n        this.throwOnExpectationFailure = function(value) {\r\n            throwOnExpectationFailure = !!value;\r\n        };\r\n\r\n        this.throwingExpectationFailures = function() {\r\n            return throwOnExpectationFailure;\r\n        };\r\n\r\n        this.randomizeTests = function(value) {\r\n            random = !!value;\r\n        };\r\n\r\n        this.randomTests = function() {\r\n            return random;\r\n        };\r\n\r\n        this.seed = function(value) {\r\n            if (value) {\r\n                seed = value;\r\n            }\r\n            return seed;\r\n        };\r\n\r\n        var queueRunnerFactory = function(options) {\r\n            options.catchException = catchException;\r\n            options.clearStack = options.clearStack || clearStack;\r\n            options.timeout = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\r\n            options.fail = self.fail;\r\n\r\n            new j$.QueueRunner(options).execute();\r\n        };\r\n\r\n        var topSuite = new j$.Suite({\r\n            env: this,\r\n            id: getNextSuiteId(),\r\n            description: 'Jasmine__TopLevel__Suite',\r\n            expectationFactory: expectationFactory,\r\n            expectationResultFactory: expectationResultFactory\r\n        });\r\n        defaultResourcesForRunnable(topSuite.id);\r\n        currentDeclarationSuite = topSuite;\r\n\r\n        this.topSuite = function() {\r\n            return topSuite;\r\n        };\r\n\r\n        this.execute = function(runnablesToRun) {\r\n            if(!runnablesToRun) {\r\n                if (focusedRunnables.length) {\r\n                    runnablesToRun = focusedRunnables;\r\n                } else {\r\n                    runnablesToRun = [topSuite.id];\r\n                }\r\n            }\r\n\r\n            var order = new j$.Order({\r\n                random: random,\r\n                seed: seed\r\n            });\r\n\r\n            var processor = new j$.TreeProcessor({\r\n                tree: topSuite,\r\n                runnableIds: runnablesToRun,\r\n                queueRunnerFactory: queueRunnerFactory,\r\n                nodeStart: function(suite) {\r\n                    currentlyExecutingSuites.push(suite);\r\n                    defaultResourcesForRunnable(suite.id, suite.parentSuite.id);\r\n                    reporter.suiteStarted(suite.result);\r\n                },\r\n                nodeComplete: function(suite, result) {\r\n                    if (!suite.disabled) {\r\n                        clearResourcesForRunnable(suite.id);\r\n                    }\r\n                    currentlyExecutingSuites.pop();\r\n                    reporter.suiteDone(result);\r\n                },\r\n                orderChildren: function(node) {\r\n                    return order.sort(node.children);\r\n                }\r\n            });\r\n\r\n            if(!processor.processTree().valid) {\r\n                throw new Error('Invalid order: would cause a beforeAll or afterAll to be run multiple times');\r\n            }\r\n\r\n            reporter.jasmineStarted({\r\n                totalSpecsDefined: totalSpecsDefined\r\n            });\r\n\r\n            currentlyExecutingSuites.push(topSuite);\r\n\r\n            processor.execute(function() {\r\n                clearResourcesForRunnable(topSuite.id);\r\n                currentlyExecutingSuites.pop();\r\n\r\n                reporter.jasmineDone({\r\n                    order: order,\r\n                    failedExpectations: topSuite.result.failedExpectations\r\n                });\r\n            });\r\n        };\r\n\r\n        this.addReporter = function(reporterToAdd) {\r\n            reporter.addReporter(reporterToAdd);\r\n        };\r\n\r\n        this.provideFallbackReporter = function(reporterToAdd) {\r\n            reporter.provideFallbackReporter(reporterToAdd);\r\n        };\r\n\r\n        var spyRegistry = new j$.SpyRegistry({currentSpies: function() {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Spies must be created in a before function or a spec');\r\n            }\r\n            return runnableResources[currentRunnable().id].spies;\r\n        }});\r\n\r\n        this.allowRespy = function(allow){\r\n            spyRegistry.allowRespy(allow);\r\n        };\r\n\r\n        this.spyOn = function() {\r\n            return spyRegistry.spyOn.apply(spyRegistry, arguments);\r\n        };\r\n\r\n        var suiteFactory = function(description) {\r\n            var suite = new j$.Suite({\r\n                env: self,\r\n                id: getNextSuiteId(),\r\n                description: description,\r\n                parentSuite: currentDeclarationSuite,\r\n                expectationFactory: expectationFactory,\r\n                expectationResultFactory: expectationResultFactory,\r\n                throwOnExpectationFailure: throwOnExpectationFailure\r\n            });\r\n\r\n            return suite;\r\n        };\r\n\r\n        this.describe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            if (specDefinitions.length > 0) {\r\n                throw new Error('describe does not expect any arguments');\r\n            }\r\n            if (currentDeclarationSuite.markedPending) {\r\n                suite.pend();\r\n            }\r\n            addSpecsToSuite(suite, specDefinitions);\r\n            return suite;\r\n        };\r\n\r\n        this.xdescribe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            suite.pend();\r\n            addSpecsToSuite(suite, specDefinitions);\r\n            return suite;\r\n        };\r\n\r\n        var focusedRunnables = [];\r\n\r\n        this.fdescribe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            suite.isFocused = true;\r\n\r\n            focusedRunnables.push(suite.id);\r\n            unfocusAncestor();\r\n            addSpecsToSuite(suite, specDefinitions);\r\n\r\n            return suite;\r\n        };\r\n\r\n        function addSpecsToSuite(suite, specDefinitions) {\r\n            var parentSuite = currentDeclarationSuite;\r\n            parentSuite.addChild(suite);\r\n            currentDeclarationSuite = suite;\r\n\r\n            var declarationError = null;\r\n            try {\r\n                specDefinitions.call(suite);\r\n            } catch (e) {\r\n                declarationError = e;\r\n            }\r\n\r\n            if (declarationError) {\r\n                self.it('encountered a declaration exception', function() {\r\n                    throw declarationError;\r\n                });\r\n            }\r\n\r\n            currentDeclarationSuite = parentSuite;\r\n        }\r\n\r\n        function findFocusedAncestor(suite) {\r\n            while (suite) {\r\n                if (suite.isFocused) {\r\n                    return suite.id;\r\n                }\r\n                suite = suite.parentSuite;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        function unfocusAncestor() {\r\n            var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\r\n            if (focusedAncestor) {\r\n                for (var i = 0; i < focusedRunnables.length; i++) {\r\n                    if (focusedRunnables[i] === focusedAncestor) {\r\n                        focusedRunnables.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var specFactory = function(description, fn, suite, timeout) {\r\n            totalSpecsDefined++;\r\n            var spec = new j$.Spec({\r\n                id: getNextSpecId(),\r\n                beforeAndAfterFns: beforeAndAfterFns(suite),\r\n                expectationFactory: expectationFactory,\r\n                resultCallback: specResultCallback,\r\n                getSpecName: function(spec) {\r\n                    return getSpecName(spec, suite);\r\n                },\r\n                onStart: specStarted,\r\n                description: description,\r\n                expectationResultFactory: expectationResultFactory,\r\n                queueRunnerFactory: queueRunnerFactory,\r\n                userContext: function() { return suite.clonedSharedUserContext(); },\r\n                queueableFn: {\r\n                    fn: fn,\r\n                    timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n                },\r\n                throwOnExpectationFailure: throwOnExpectationFailure\r\n            });\r\n\r\n            if (!self.specFilter(spec)) {\r\n                spec.disable();\r\n            }\r\n\r\n            return spec;\r\n\r\n            function specResultCallback(result) {\r\n                clearResourcesForRunnable(spec.id);\r\n                currentSpec = null;\r\n                reporter.specDone(result);\r\n            }\r\n\r\n            function specStarted(spec) {\r\n                currentSpec = spec;\r\n                defaultResourcesForRunnable(spec.id, suite.id);\r\n                reporter.specStarted(spec.result);\r\n            }\r\n        };\r\n\r\n        this.it = function(description, fn, timeout) {\r\n            var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\r\n            if (currentDeclarationSuite.markedPending) {\r\n                spec.pend();\r\n            }\r\n            currentDeclarationSuite.addChild(spec);\r\n            return spec;\r\n        };\r\n\r\n        this.xit = function() {\r\n            var spec = this.it.apply(this, arguments);\r\n            spec.pend('Temporarily disabled with xit');\r\n            return spec;\r\n        };\r\n\r\n        this.fit = function(description, fn, timeout){\r\n            var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\r\n            currentDeclarationSuite.addChild(spec);\r\n            focusedRunnables.push(spec.id);\r\n            unfocusAncestor();\r\n            return spec;\r\n        };\r\n\r\n        this.expect = function(actual) {\r\n            if (!currentRunnable()) {\r\n                throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\r\n            }\r\n\r\n            return currentRunnable().expect(actual);\r\n        };\r\n\r\n        this.beforeEach = function(beforeEachFunction, timeout) {\r\n            currentDeclarationSuite.beforeEach({\r\n                fn: beforeEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.beforeAll = function(beforeAllFunction, timeout) {\r\n            currentDeclarationSuite.beforeAll({\r\n                fn: beforeAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterEach = function(afterEachFunction, timeout) {\r\n            currentDeclarationSuite.afterEach({\r\n                fn: afterEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterAll = function(afterAllFunction, timeout) {\r\n            currentDeclarationSuite.afterAll({\r\n                fn: afterAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.pending = function(message) {\r\n            var fullMessage = j$.Spec.pendingSpecExceptionMessage;\r\n            if(message) {\r\n                fullMessage += message;\r\n            }\r\n            throw fullMessage;\r\n        };\r\n\r\n        this.fail = function(error) {\r\n            var message = 'Failed';\r\n            if (error) {\r\n                message += ': ';\r\n                message += error.message || error;\r\n            }\r\n\r\n            currentRunnable().addExpectationResult(false, {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                message: message,\r\n                error: error && error.message ? error : null\r\n            });\r\n        };\r\n    }\r\n\r\n    return Env;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.Env.[function]","oldFunction":"function(j$) {\r\n    function Env(options) {\r\n        options = options || {};\r\n\r\n        var self = this;\r\n        var global = options.global || j$.getGlobal();\r\n\r\n        var totalSpecsDefined = 0;\r\n\r\n        var catchExceptions = true;\r\n\r\n        var realSetTimeout = j$.getGlobal().setTimeout;\r\n        var realClearTimeout = j$.getGlobal().clearTimeout;\r\n        this.clock = new j$.Clock(global, new j$.DelayedFunctionScheduler(), new j$.MockDate(global));\r\n\r\n        var runnableLookupTable = {};\r\n        var runnableResources = {};\r\n\r\n        var currentSpec = null;\r\n        var currentlyExecutingSuites = [];\r\n        var currentDeclarationSuite = null;\r\n\r\n        var currentSuite = function() {\r\n            return currentlyExecutingSuites[currentlyExecutingSuites.length - 1];\r\n        };\r\n\r\n        var currentRunnable = function() {\r\n            return currentSpec || currentSuite();\r\n        };\r\n\r\n        var reporter = new j$.ReportDispatcher([\r\n            'jasmineStarted',\r\n            'jasmineDone',\r\n            'suiteStarted',\r\n            'suiteDone',\r\n            'specStarted',\r\n            'specDone'\r\n        ]);\r\n\r\n        this.specFilter = function() {\r\n            return true;\r\n        };\r\n\r\n        this.addCustomEqualityTester = function(tester) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Custom Equalities must be added in a before function or a spec');\r\n            }\r\n            runnableResources[currentRunnable().id].customEqualityTesters.push(tester);\r\n        };\r\n\r\n        this.addMatchers = function(matchersToAdd) {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Matchers must be added in a before function or a spec');\r\n            }\r\n            var customMatchers = runnableResources[currentRunnable().id].customMatchers;\r\n            for (var matcherName in matchersToAdd) {\r\n                customMatchers[matcherName] = matchersToAdd[matcherName];\r\n            }\r\n        };\r\n\r\n        j$.Expectation.addCoreMatchers(j$.matchers);\r\n\r\n        var nextSpecId = 0;\r\n        var getNextSpecId = function() {\r\n            return 'spec' + nextSpecId++;\r\n        };\r\n\r\n        var nextSuiteId = 0;\r\n        var getNextSuiteId = function() {\r\n            return 'suite' + nextSuiteId++;\r\n        };\r\n\r\n        var expectationFactory = function(actual, spec) {\r\n            return j$.Expectation.Factory({\r\n                util: j$.matchersUtil,\r\n                customEqualityTesters: runnableResources[spec.id].customEqualityTesters,\r\n                customMatchers: runnableResources[spec.id].customMatchers,\r\n                actual: actual,\r\n                addExpectationResult: addExpectationResult\r\n            });\r\n\r\n            function addExpectationResult(passed, result) {\r\n                return spec.addExpectationResult(passed, result);\r\n            }\r\n        };\r\n\r\n        var defaultResourcesForRunnable = function(id, parentRunnableId) {\r\n            var resources = {spies: [], customEqualityTesters: [], customMatchers: {}};\r\n\r\n            if(runnableResources[parentRunnableId]){\r\n                resources.customEqualityTesters = j$.util.clone(runnableResources[parentRunnableId].customEqualityTesters);\r\n                resources.customMatchers = j$.util.clone(runnableResources[parentRunnableId].customMatchers);\r\n            }\r\n\r\n            runnableResources[id] = resources;\r\n        };\r\n\r\n        var clearResourcesForRunnable = function(id) {\r\n            spyRegistry.clearSpies();\r\n            delete runnableResources[id];\r\n        };\r\n\r\n        var beforeAndAfterFns = function(suite, runnablesExplictlySet) {\r\n            return function() {\r\n                var befores = [],\r\n                    afters = [],\r\n                    beforeAlls = [],\r\n                    afterAlls = [];\r\n\r\n                while(suite) {\r\n                    befores = befores.concat(suite.beforeFns);\r\n                    afters = afters.concat(suite.afterFns);\r\n\r\n                    if (runnablesExplictlySet()) {\r\n                        beforeAlls = beforeAlls.concat(suite.beforeAllFns);\r\n                        afterAlls = afterAlls.concat(suite.afterAllFns);\r\n                    }\r\n\r\n                    suite = suite.parentSuite;\r\n                }\r\n                return {\r\n                    befores: beforeAlls.reverse().concat(befores.reverse()),\r\n                    afters: afters.concat(afterAlls)\r\n                };\r\n            };\r\n        };\r\n\r\n        var getSpecName = function(spec, suite) {\r\n            return suite.getFullName() + ' ' + spec.description;\r\n        };\r\n\r\n        // TODO: we may just be able to pass in the fn instead of wrapping here\r\n        var buildExpectationResult = j$.buildExpectationResult,\r\n            exceptionFormatter = new j$.ExceptionFormatter(),\r\n            expectationResultFactory = function(attrs) {\r\n                attrs.messageFormatter = exceptionFormatter.message;\r\n                attrs.stackFormatter = exceptionFormatter.stack;\r\n\r\n                return buildExpectationResult(attrs);\r\n            };\r\n\r\n        // TODO: fix this naming, and here's where the value comes in\r\n        this.catchExceptions = function(value) {\r\n            catchExceptions = !!value;\r\n            return catchExceptions;\r\n        };\r\n\r\n        this.catchingExceptions = function() {\r\n            return catchExceptions;\r\n        };\r\n\r\n        var maximumSpecCallbackDepth = 20;\r\n        var currentSpecCallbackDepth = 0;\r\n\r\n        function clearStack(fn) {\r\n            currentSpecCallbackDepth++;\r\n            if (currentSpecCallbackDepth >= maximumSpecCallbackDepth) {\r\n                currentSpecCallbackDepth = 0;\r\n                realSetTimeout(fn, 0);\r\n            } else {\r\n                fn();\r\n            }\r\n        }\r\n\r\n        var catchException = function(e) {\r\n            return j$.Spec.isPendingSpecException(e) || catchExceptions;\r\n        };\r\n\r\n        var queueRunnerFactory = function(options) {\r\n            options.catchException = catchException;\r\n            options.clearStack = options.clearStack || clearStack;\r\n            options.timer = {setTimeout: realSetTimeout, clearTimeout: realClearTimeout};\r\n            options.fail = self.fail;\r\n\r\n            new j$.QueueRunner(options).execute();\r\n        };\r\n\r\n        var topSuite = new j$.Suite({\r\n            env: this,\r\n            id: getNextSuiteId(),\r\n            description: 'Jasmine__TopLevel__Suite',\r\n            queueRunner: queueRunnerFactory\r\n        });\r\n        runnableLookupTable[topSuite.id] = topSuite;\r\n        defaultResourcesForRunnable(topSuite.id);\r\n        currentDeclarationSuite = topSuite;\r\n\r\n        this.topSuite = function() {\r\n            return topSuite;\r\n        };\r\n\r\n        this.execute = function(runnablesToRun) {\r\n            if(runnablesToRun) {\r\n                runnablesExplictlySet = true;\r\n            } else if (focusedRunnables.length) {\r\n                runnablesExplictlySet = true;\r\n                runnablesToRun = focusedRunnables;\r\n            } else {\r\n                runnablesToRun = [topSuite.id];\r\n            }\r\n\r\n            var allFns = [];\r\n            for(var i = 0; i < runnablesToRun.length; i++) {\r\n                var runnable = runnableLookupTable[runnablesToRun[i]];\r\n                allFns.push((function(runnable) { return { fn: function(done) { runnable.execute(done); } }; })(runnable));\r\n            }\r\n\r\n            reporter.jasmineStarted({\r\n                totalSpecsDefined: totalSpecsDefined\r\n            });\r\n\r\n            queueRunnerFactory({queueableFns: allFns, onComplete: reporter.jasmineDone});\r\n        };\r\n\r\n        this.addReporter = function(reporterToAdd) {\r\n            reporter.addReporter(reporterToAdd);\r\n        };\r\n\r\n        var spyRegistry = new j$.SpyRegistry({currentSpies: function() {\r\n            if(!currentRunnable()) {\r\n                throw new Error('Spies must be created in a before function or a spec');\r\n            }\r\n            return runnableResources[currentRunnable().id].spies;\r\n        }});\r\n\r\n        this.spyOn = function() {\r\n            return spyRegistry.spyOn.apply(spyRegistry, arguments);\r\n        };\r\n\r\n        var suiteFactory = function(description) {\r\n            var suite = new j$.Suite({\r\n                env: self,\r\n                id: getNextSuiteId(),\r\n                description: description,\r\n                parentSuite: currentDeclarationSuite,\r\n                queueRunner: queueRunnerFactory,\r\n                onStart: suiteStarted,\r\n                expectationFactory: expectationFactory,\r\n                expectationResultFactory: expectationResultFactory,\r\n                runnablesExplictlySetGetter: runnablesExplictlySetGetter,\r\n                resultCallback: function(attrs) {\r\n                    if (!suite.disabled) {\r\n                        clearResourcesForRunnable(suite.id);\r\n                    }\r\n                    currentlyExecutingSuites.pop();\r\n                    reporter.suiteDone(attrs);\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[suite.id] = suite;\r\n            return suite;\r\n\r\n            function suiteStarted(suite) {\r\n                currentlyExecutingSuites.push(suite);\r\n                defaultResourcesForRunnable(suite.id, suite.parentSuite.id);\r\n                reporter.suiteStarted(suite.result);\r\n            }\r\n        };\r\n\r\n        this.describe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            addSpecsToSuite(suite, specDefinitions);\r\n            return suite;\r\n        };\r\n\r\n        this.xdescribe = function(description, specDefinitions) {\r\n            var suite = this.describe(description, specDefinitions);\r\n            suite.disable();\r\n            return suite;\r\n        };\r\n\r\n        var focusedRunnables = [];\r\n\r\n        this.fdescribe = function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            suite.isFocused = true;\r\n\r\n            focusedRunnables.push(suite.id);\r\n            unfocusAncestor();\r\n            addSpecsToSuite(suite, specDefinitions);\r\n\r\n            return suite;\r\n        };\r\n\r\n        function addSpecsToSuite(suite, specDefinitions) {\r\n            var parentSuite = currentDeclarationSuite;\r\n            parentSuite.addChild(suite);\r\n            currentDeclarationSuite = suite;\r\n\r\n            var declarationError = null;\r\n            try {\r\n                specDefinitions.call(suite);\r\n            } catch (e) {\r\n                declarationError = e;\r\n            }\r\n\r\n            if (declarationError) {\r\n                self.it('encountered a declaration exception', function() {\r\n                    throw declarationError;\r\n                });\r\n            }\r\n\r\n            currentDeclarationSuite = parentSuite;\r\n        }\r\n\r\n        function findFocusedAncestor(suite) {\r\n            while (suite) {\r\n                if (suite.isFocused) {\r\n                    return suite.id;\r\n                }\r\n                suite = suite.parentSuite;\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        function unfocusAncestor() {\r\n            var focusedAncestor = findFocusedAncestor(currentDeclarationSuite);\r\n            if (focusedAncestor) {\r\n                for (var i = 0; i < focusedRunnables.length; i++) {\r\n                    if (focusedRunnables[i] === focusedAncestor) {\r\n                        focusedRunnables.splice(i, 1);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        var runnablesExplictlySet = false;\r\n\r\n        var runnablesExplictlySetGetter = function(){\r\n            return runnablesExplictlySet;\r\n        };\r\n\r\n        var specFactory = function(description, fn, suite, timeout) {\r\n            totalSpecsDefined++;\r\n            var spec = new j$.Spec({\r\n                id: getNextSpecId(),\r\n                beforeAndAfterFns: beforeAndAfterFns(suite, runnablesExplictlySetGetter),\r\n                expectationFactory: expectationFactory,\r\n                resultCallback: specResultCallback,\r\n                getSpecName: function(spec) {\r\n                    return getSpecName(spec, suite);\r\n                },\r\n                onStart: specStarted,\r\n                description: description,\r\n                expectationResultFactory: expectationResultFactory,\r\n                queueRunnerFactory: queueRunnerFactory,\r\n                userContext: function() { return suite.clonedSharedUserContext(); },\r\n                queueableFn: {\r\n                    fn: fn,\r\n                    timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n                }\r\n            });\r\n\r\n            runnableLookupTable[spec.id] = spec;\r\n\r\n            if (!self.specFilter(spec)) {\r\n                spec.disable();\r\n            }\r\n\r\n            return spec;\r\n\r\n            function specResultCallback(result) {\r\n                clearResourcesForRunnable(spec.id);\r\n                currentSpec = null;\r\n                reporter.specDone(result);\r\n            }\r\n\r\n            function specStarted(spec) {\r\n                currentSpec = spec;\r\n                defaultResourcesForRunnable(spec.id, suite.id);\r\n                reporter.specStarted(spec.result);\r\n            }\r\n        };\r\n\r\n        this.it = function(description, fn, timeout) {\r\n            var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\r\n            currentDeclarationSuite.addChild(spec);\r\n            return spec;\r\n        };\r\n\r\n        this.xit = function() {\r\n            var spec = this.it.apply(this, arguments);\r\n            spec.pend();\r\n            return spec;\r\n        };\r\n\r\n        this.fit = function(){\r\n            var spec = this.it.apply(this, arguments);\r\n\r\n            focusedRunnables.push(spec.id);\r\n            unfocusAncestor();\r\n            return spec;\r\n        };\r\n\r\n        this.expect = function(actual) {\r\n            if (!currentRunnable()) {\r\n                throw new Error('\\'expect\\' was used when there was no current spec, this could be because an asynchronous test timed out');\r\n            }\r\n\r\n            return currentRunnable().expect(actual);\r\n        };\r\n\r\n        this.beforeEach = function(beforeEachFunction, timeout) {\r\n            currentDeclarationSuite.beforeEach({\r\n                fn: beforeEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.beforeAll = function(beforeAllFunction, timeout) {\r\n            currentDeclarationSuite.beforeAll({\r\n                fn: beforeAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterEach = function(afterEachFunction, timeout) {\r\n            currentDeclarationSuite.afterEach({\r\n                fn: afterEachFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.afterAll = function(afterAllFunction, timeout) {\r\n            currentDeclarationSuite.afterAll({\r\n                fn: afterAllFunction,\r\n                timeout: function() { return timeout || j$.DEFAULT_TIMEOUT_INTERVAL; }\r\n            });\r\n        };\r\n\r\n        this.pending = function(message) {\r\n            var fullMessage = j$.Spec.pendingSpecExceptionMessage;\r\n            if(message) {\r\n                fullMessage += message;\r\n            }\r\n            throw fullMessage;\r\n        };\r\n\r\n        this.fail = function(error) {\r\n            var message = 'Failed';\r\n            if (error) {\r\n                message += ': ';\r\n                message += error.message || error;\r\n            }\r\n\r\n            currentRunnable().addExpectationResult(false, {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                message: message,\r\n                error: error && error.message ? error : null\r\n            });\r\n        };\r\n    }\r\n\r\n    return Env;\r\n}","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.Env.[function].[arg0]","key":"TreeProcessor","newType":"(arg0: void) => void","isAny":false,"isClass":false,"containerType":"// Seen as: j$\ninterface interface_802 {\n    Clock: (arg0: void, arg1: void, arg2: void) => void;\n    DEFAULT_TIMEOUT_INTERVAL: any;\n    DelayedFunctionScheduler: () => void;\n    ExceptionFormatter: () => void;\n    Expectation: interface_800;\n    MockDate: (arg0: void) => void;\n    Order: (arg0: void) => void;\n    QueueRunner: (arg0: void) => void;\n    ReportDispatcher: (arg0: void) => void;\n    Spec: interface_540;\n    SpyRegistry: (arg0: void) => void;\n    Suite: (arg0: void) => void;\n    TreeProcessor: (arg0: void) => void;\n    buildExpectationResult: (arg0: void) => void;\n    getGlobal: () => void;\n    matchers: any;\n    matchersUtil: any;\n    util: {clone: (arg0: void) => void};\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.toThrowError.[function]","newFunction":"function(j$) {\r\n\r\n    var getErrorMsg =  j$.formatErrorMsg('<toThrowError>', 'expect(function() {<expectation>}).toThrowError(<ErrorConstructor>, <message>)');\r\n\r\n    function toThrowError () {\r\n        return {\r\n            compare: function(actual) {\r\n                var threw = false,\r\n                    pass = {pass: true},\r\n                    fail = {pass: false},\r\n                    thrown;\r\n\r\n                if (typeof actual != 'function') {\r\n                    throw new Error(getErrorMsg('Actual is not a Function'));\r\n                }\r\n\r\n                var errorMatcher = getMatcher.apply(null, arguments);\r\n\r\n                try {\r\n                    actual();\r\n                } catch (e) {\r\n                    threw = true;\r\n                    thrown = e;\r\n                }\r\n\r\n                if (!threw) {\r\n                    fail.message = 'Expected function to throw an Error.';\r\n                    return fail;\r\n                }\r\n\r\n                if (!(thrown instanceof Error)) {\r\n                    fail.message = function() { return 'Expected function to throw an Error, but it threw ' + j$.pp(thrown) + '.'; };\r\n                    return fail;\r\n                }\r\n\r\n                if (errorMatcher.hasNoSpecifics()) {\r\n                    pass.message = 'Expected function not to throw an Error, but it threw ' + j$.fnNameFor(thrown) + '.';\r\n                    return pass;\r\n                }\r\n\r\n                if (errorMatcher.matches(thrown)) {\r\n                    pass.message = function() {\r\n                        return 'Expected function not to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() + '.';\r\n                    };\r\n                    return pass;\r\n                } else {\r\n                    fail.message = function() {\r\n                        return 'Expected function to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() +\r\n                            ', but it threw ' + errorMatcher.thrownDescription(thrown) + '.';\r\n                    };\r\n                    return fail;\r\n                }\r\n            }\r\n        };\r\n\r\n        function getMatcher() {\r\n            var expected = null,\r\n                errorType = null;\r\n\r\n            if (arguments.length == 2) {\r\n                expected = arguments[1];\r\n                if (isAnErrorType(expected)) {\r\n                    errorType = expected;\r\n                    expected = null;\r\n                }\r\n            } else if (arguments.length > 2) {\r\n                errorType = arguments[1];\r\n                expected = arguments[2];\r\n                if (!isAnErrorType(errorType)) {\r\n                    throw new Error(getErrorMsg('Expected error type is not an Error.'));\r\n                }\r\n            }\r\n\r\n            if (expected && !isStringOrRegExp(expected)) {\r\n                if (errorType) {\r\n                    throw new Error(getErrorMsg('Expected error message is not a string or RegExp.'));\r\n                } else {\r\n                    throw new Error(getErrorMsg('Expected is not an Error, string, or RegExp.'));\r\n                }\r\n            }\r\n\r\n            function messageMatch(message) {\r\n                if (typeof expected == 'string') {\r\n                    return expected == message;\r\n                } else {\r\n                    return expected.test(message);\r\n                }\r\n            }\r\n\r\n            return {\r\n                errorTypeDescription: errorType ? j$.fnNameFor(errorType) : 'an exception',\r\n                thrownDescription: function(thrown) {\r\n                    var thrownName = errorType ? j$.fnNameFor(thrown.constructor) : 'an exception',\r\n                        thrownMessage = '';\r\n\r\n                    if (expected) {\r\n                        thrownMessage = ' with message ' + j$.pp(thrown.message);\r\n                    }\r\n\r\n                    return thrownName + thrownMessage;\r\n                },\r\n                messageDescription: function() {\r\n                    if (expected === null) {\r\n                        return '';\r\n                    } else if (expected instanceof RegExp) {\r\n                        return ' with a message matching ' + j$.pp(expected);\r\n                    } else {\r\n                        return ' with message ' + j$.pp(expected);\r\n                    }\r\n                },\r\n                hasNoSpecifics: function() {\r\n                    return expected === null && errorType === null;\r\n                },\r\n                matches: function(error) {\r\n                    return (errorType === null || error instanceof errorType) &&\r\n                        (expected === null || messageMatch(error.message));\r\n                }\r\n            };\r\n        }\r\n\r\n        function isStringOrRegExp(potential) {\r\n            return potential instanceof RegExp || (typeof potential == 'string');\r\n        }\r\n\r\n        function isAnErrorType(type) {\r\n            if (typeof type !== 'function') {\r\n                return false;\r\n            }\r\n\r\n            var Surrogate = function() {};\r\n            Surrogate.prototype = type.prototype;\r\n            return (new Surrogate()) instanceof Error;\r\n        }\r\n    }\r\n\r\n    return toThrowError;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.toThrowError.[function]","oldFunction":"function(j$) {\r\n    function toThrowError (util) {\r\n        return {\r\n            compare: function(actual) {\r\n                var threw = false,\r\n                    pass = {pass: true},\r\n                    fail = {pass: false},\r\n                    thrown;\r\n\r\n                if (typeof actual != 'function') {\r\n                    throw new Error('Actual is not a Function');\r\n                }\r\n\r\n                var errorMatcher = getMatcher.apply(null, arguments);\r\n\r\n                try {\r\n                    actual();\r\n                } catch (e) {\r\n                    threw = true;\r\n                    thrown = e;\r\n                }\r\n\r\n                if (!threw) {\r\n                    fail.message = 'Expected function to throw an Error.';\r\n                    return fail;\r\n                }\r\n\r\n                if (!(thrown instanceof Error)) {\r\n                    fail.message = function() { return 'Expected function to throw an Error, but it threw ' + j$.pp(thrown) + '.'; };\r\n                    return fail;\r\n                }\r\n\r\n                if (errorMatcher.hasNoSpecifics()) {\r\n                    pass.message = 'Expected function not to throw an Error, but it threw ' + j$.fnNameFor(thrown) + '.';\r\n                    return pass;\r\n                }\r\n\r\n                if (errorMatcher.matches(thrown)) {\r\n                    pass.message = function() {\r\n                        return 'Expected function not to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() + '.';\r\n                    };\r\n                    return pass;\r\n                } else {\r\n                    fail.message = function() {\r\n                        return 'Expected function to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() +\r\n                            ', but it threw ' + errorMatcher.thrownDescription(thrown) + '.';\r\n                    };\r\n                    return fail;\r\n                }\r\n            }\r\n        };\r\n\r\n        function getMatcher() {\r\n            var expected = null,\r\n                errorType = null;\r\n\r\n            if (arguments.length == 2) {\r\n                expected = arguments[1];\r\n                if (isAnErrorType(expected)) {\r\n                    errorType = expected;\r\n                    expected = null;\r\n                }\r\n            } else if (arguments.length > 2) {\r\n                errorType = arguments[1];\r\n                expected = arguments[2];\r\n                if (!isAnErrorType(errorType)) {\r\n                    throw new Error('Expected error type is not an Error.');\r\n                }\r\n            }\r\n\r\n            if (expected && !isStringOrRegExp(expected)) {\r\n                if (errorType) {\r\n                    throw new Error('Expected error message is not a string or RegExp.');\r\n                } else {\r\n                    throw new Error('Expected is not an Error, string, or RegExp.');\r\n                }\r\n            }\r\n\r\n            function messageMatch(message) {\r\n                if (typeof expected == 'string') {\r\n                    return expected == message;\r\n                } else {\r\n                    return expected.test(message);\r\n                }\r\n            }\r\n\r\n            return {\r\n                errorTypeDescription: errorType ? j$.fnNameFor(errorType) : 'an exception',\r\n                thrownDescription: function(thrown) {\r\n                    var thrownName = errorType ? j$.fnNameFor(thrown.constructor) : 'an exception',\r\n                        thrownMessage = '';\r\n\r\n                    if (expected) {\r\n                        thrownMessage = ' with message ' + j$.pp(thrown.message);\r\n                    }\r\n\r\n                    return thrownName + thrownMessage;\r\n                },\r\n                messageDescription: function() {\r\n                    if (expected === null) {\r\n                        return '';\r\n                    } else if (expected instanceof RegExp) {\r\n                        return ' with a message matching ' + j$.pp(expected);\r\n                    } else {\r\n                        return ' with message ' + j$.pp(expected);\r\n                    }\r\n                },\r\n                hasNoSpecifics: function() {\r\n                    return expected === null && errorType === null;\r\n                },\r\n                matches: function(error) {\r\n                    return (errorType === null || error.constructor === errorType) &&\r\n                        (expected === null || messageMatch(error.message));\r\n                }\r\n            };\r\n        }\r\n\r\n        function isStringOrRegExp(potential) {\r\n            return potential instanceof RegExp || (typeof potential == 'string');\r\n        }\r\n\r\n        function isAnErrorType(type) {\r\n            if (typeof type !== 'function') {\r\n                return false;\r\n            }\r\n\r\n            var Surrogate = function() {};\r\n            Surrogate.prototype = type.prototype;\r\n            return (new Surrogate()) instanceof Error;\r\n        }\r\n    }\r\n\r\n    return toThrowError;\r\n}","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.toThrowError.[function].[arg0]","key":"formatErrorMsg","newType":"(arg0: void, arg1: void) => void","isAny":false,"isClass":false,"containerType":"// Seen as: j$\ninterface interface_903 {\n    fnNameFor: (arg0: void) => void;\n    formatErrorMsg: (arg0: void, arg1: void) => void;\n    pp: (arg0: void) => void;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.toThrowError.[function]","newFunction":"function(j$) {\r\n\r\n    var getErrorMsg =  j$.formatErrorMsg('<toThrowError>', 'expect(function() {<expectation>}).toThrowError(<ErrorConstructor>, <message>)');\r\n\r\n    function toThrowError () {\r\n        return {\r\n            compare: function(actual) {\r\n                var threw = false,\r\n                    pass = {pass: true},\r\n                    fail = {pass: false},\r\n                    thrown;\r\n\r\n                if (typeof actual != 'function') {\r\n                    throw new Error(getErrorMsg('Actual is not a Function'));\r\n                }\r\n\r\n                var errorMatcher = getMatcher.apply(null, arguments);\r\n\r\n                try {\r\n                    actual();\r\n                } catch (e) {\r\n                    threw = true;\r\n                    thrown = e;\r\n                }\r\n\r\n                if (!threw) {\r\n                    fail.message = 'Expected function to throw an Error.';\r\n                    return fail;\r\n                }\r\n\r\n                if (!(thrown instanceof Error)) {\r\n                    fail.message = function() { return 'Expected function to throw an Error, but it threw ' + j$.pp(thrown) + '.'; };\r\n                    return fail;\r\n                }\r\n\r\n                if (errorMatcher.hasNoSpecifics()) {\r\n                    pass.message = 'Expected function not to throw an Error, but it threw ' + j$.fnNameFor(thrown) + '.';\r\n                    return pass;\r\n                }\r\n\r\n                if (errorMatcher.matches(thrown)) {\r\n                    pass.message = function() {\r\n                        return 'Expected function not to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() + '.';\r\n                    };\r\n                    return pass;\r\n                } else {\r\n                    fail.message = function() {\r\n                        return 'Expected function to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() +\r\n                            ', but it threw ' + errorMatcher.thrownDescription(thrown) + '.';\r\n                    };\r\n                    return fail;\r\n                }\r\n            }\r\n        };\r\n\r\n        function getMatcher() {\r\n            var expected = null,\r\n                errorType = null;\r\n\r\n            if (arguments.length == 2) {\r\n                expected = arguments[1];\r\n                if (isAnErrorType(expected)) {\r\n                    errorType = expected;\r\n                    expected = null;\r\n                }\r\n            } else if (arguments.length > 2) {\r\n                errorType = arguments[1];\r\n                expected = arguments[2];\r\n                if (!isAnErrorType(errorType)) {\r\n                    throw new Error(getErrorMsg('Expected error type is not an Error.'));\r\n                }\r\n            }\r\n\r\n            if (expected && !isStringOrRegExp(expected)) {\r\n                if (errorType) {\r\n                    throw new Error(getErrorMsg('Expected error message is not a string or RegExp.'));\r\n                } else {\r\n                    throw new Error(getErrorMsg('Expected is not an Error, string, or RegExp.'));\r\n                }\r\n            }\r\n\r\n            function messageMatch(message) {\r\n                if (typeof expected == 'string') {\r\n                    return expected == message;\r\n                } else {\r\n                    return expected.test(message);\r\n                }\r\n            }\r\n\r\n            return {\r\n                errorTypeDescription: errorType ? j$.fnNameFor(errorType) : 'an exception',\r\n                thrownDescription: function(thrown) {\r\n                    var thrownName = errorType ? j$.fnNameFor(thrown.constructor) : 'an exception',\r\n                        thrownMessage = '';\r\n\r\n                    if (expected) {\r\n                        thrownMessage = ' with message ' + j$.pp(thrown.message);\r\n                    }\r\n\r\n                    return thrownName + thrownMessage;\r\n                },\r\n                messageDescription: function() {\r\n                    if (expected === null) {\r\n                        return '';\r\n                    } else if (expected instanceof RegExp) {\r\n                        return ' with a message matching ' + j$.pp(expected);\r\n                    } else {\r\n                        return ' with message ' + j$.pp(expected);\r\n                    }\r\n                },\r\n                hasNoSpecifics: function() {\r\n                    return expected === null && errorType === null;\r\n                },\r\n                matches: function(error) {\r\n                    return (errorType === null || error instanceof errorType) &&\r\n                        (expected === null || messageMatch(error.message));\r\n                }\r\n            };\r\n        }\r\n\r\n        function isStringOrRegExp(potential) {\r\n            return potential instanceof RegExp || (typeof potential == 'string');\r\n        }\r\n\r\n        function isAnErrorType(type) {\r\n            if (typeof type !== 'function') {\r\n                return false;\r\n            }\r\n\r\n            var Surrogate = function() {};\r\n            Surrogate.prototype = type.prototype;\r\n            return (new Surrogate()) instanceof Error;\r\n        }\r\n    }\r\n\r\n    return toThrowError;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.toThrowError.[function]","oldFunction":"function(j$) {\r\n    function toThrowError (util) {\r\n        return {\r\n            compare: function(actual) {\r\n                var threw = false,\r\n                    pass = {pass: true},\r\n                    fail = {pass: false},\r\n                    thrown;\r\n\r\n                if (typeof actual != 'function') {\r\n                    throw new Error('Actual is not a Function');\r\n                }\r\n\r\n                var errorMatcher = getMatcher.apply(null, arguments);\r\n\r\n                try {\r\n                    actual();\r\n                } catch (e) {\r\n                    threw = true;\r\n                    thrown = e;\r\n                }\r\n\r\n                if (!threw) {\r\n                    fail.message = 'Expected function to throw an Error.';\r\n                    return fail;\r\n                }\r\n\r\n                if (!(thrown instanceof Error)) {\r\n                    fail.message = function() { return 'Expected function to throw an Error, but it threw ' + j$.pp(thrown) + '.'; };\r\n                    return fail;\r\n                }\r\n\r\n                if (errorMatcher.hasNoSpecifics()) {\r\n                    pass.message = 'Expected function not to throw an Error, but it threw ' + j$.fnNameFor(thrown) + '.';\r\n                    return pass;\r\n                }\r\n\r\n                if (errorMatcher.matches(thrown)) {\r\n                    pass.message = function() {\r\n                        return 'Expected function not to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() + '.';\r\n                    };\r\n                    return pass;\r\n                } else {\r\n                    fail.message = function() {\r\n                        return 'Expected function to throw ' + errorMatcher.errorTypeDescription + errorMatcher.messageDescription() +\r\n                            ', but it threw ' + errorMatcher.thrownDescription(thrown) + '.';\r\n                    };\r\n                    return fail;\r\n                }\r\n            }\r\n        };\r\n\r\n        function getMatcher() {\r\n            var expected = null,\r\n                errorType = null;\r\n\r\n            if (arguments.length == 2) {\r\n                expected = arguments[1];\r\n                if (isAnErrorType(expected)) {\r\n                    errorType = expected;\r\n                    expected = null;\r\n                }\r\n            } else if (arguments.length > 2) {\r\n                errorType = arguments[1];\r\n                expected = arguments[2];\r\n                if (!isAnErrorType(errorType)) {\r\n                    throw new Error('Expected error type is not an Error.');\r\n                }\r\n            }\r\n\r\n            if (expected && !isStringOrRegExp(expected)) {\r\n                if (errorType) {\r\n                    throw new Error('Expected error message is not a string or RegExp.');\r\n                } else {\r\n                    throw new Error('Expected is not an Error, string, or RegExp.');\r\n                }\r\n            }\r\n\r\n            function messageMatch(message) {\r\n                if (typeof expected == 'string') {\r\n                    return expected == message;\r\n                } else {\r\n                    return expected.test(message);\r\n                }\r\n            }\r\n\r\n            return {\r\n                errorTypeDescription: errorType ? j$.fnNameFor(errorType) : 'an exception',\r\n                thrownDescription: function(thrown) {\r\n                    var thrownName = errorType ? j$.fnNameFor(thrown.constructor) : 'an exception',\r\n                        thrownMessage = '';\r\n\r\n                    if (expected) {\r\n                        thrownMessage = ' with message ' + j$.pp(thrown.message);\r\n                    }\r\n\r\n                    return thrownName + thrownMessage;\r\n                },\r\n                messageDescription: function() {\r\n                    if (expected === null) {\r\n                        return '';\r\n                    } else if (expected instanceof RegExp) {\r\n                        return ' with a message matching ' + j$.pp(expected);\r\n                    } else {\r\n                        return ' with message ' + j$.pp(expected);\r\n                    }\r\n                },\r\n                hasNoSpecifics: function() {\r\n                    return expected === null && errorType === null;\r\n                },\r\n                matches: function(error) {\r\n                    return (errorType === null || error.constructor === errorType) &&\r\n                        (expected === null || messageMatch(error.message));\r\n                }\r\n            };\r\n        }\r\n\r\n        function isStringOrRegExp(potential) {\r\n            return potential instanceof RegExp || (typeof potential == 'string');\r\n        }\r\n\r\n        function isAnErrorType(type) {\r\n            if (typeof type !== 'function') {\r\n                return false;\r\n            }\r\n\r\n            var Surrogate = function() {};\r\n            Surrogate.prototype = type.prototype;\r\n            return (new Surrogate()) instanceof Error;\r\n        }\r\n    }\r\n\r\n    return toThrowError;\r\n}","oldJSDoc":null,"type":"changedArgCount","typePath":"window.jasmineRequire.toThrowError.[function].[return]","isClass":false,"newType":"() => interface_904","newTypeDescription":"function","oldType":"(util: any) => interface_855","oldArgCount":1,"newArgCount":0,"containerType":"(j$: interface_903) => () => interface_904","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.core.[function]","newFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.errors = jRequire.errors();\r\n        j$.formatErrorMsg = jRequire.formatErrorMsg();\r\n        j$.Any = jRequire.Any(j$);\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker(j$);\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite(j$);\r\n        j$.Timer = jRequire.Timer();\r\n        j$.TreeProcessor = jRequire.TreeProcessor();\r\n        j$.version = jRequire.version();\r\n        j$.Order = jRequire.Order();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.core.[function]","oldFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.Any = jRequire.Any();\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker();\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite();\r\n        j$.Timer = jRequire.Timer();\r\n        j$.version = jRequire.version();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.core.[function].[arg0]","key":"TreeProcessor","newType":"() => void","isAny":false,"isClass":false,"containerType":"// Seen as: jRequire\ninterface interface_864 {\n    Any: (arg0: void) => void;\n    Anything: (arg0: void) => void;\n    ArrayContaining: (arg0: void) => void;\n    CallTracker: (arg0: void) => void;\n    Clock: () => void;\n    DelayedFunctionScheduler: () => void;\n    Env: (arg0: void) => void;\n    ExceptionFormatter: () => void;\n    Expectation: () => void;\n    JsApiReporter: () => void;\n    MockDate: () => void;\n    ObjectContaining: (arg0: void) => void;\n    Order: () => void;\n    QueueRunner: (arg0: void) => void;\n    ReportDispatcher: () => void;\n    Spec: (arg0: void) => void;\n    SpyRegistry: (arg0: void) => void;\n    SpyStrategy: () => void;\n    StringMatching: (arg0: void) => void;\n    Suite: (arg0: void) => void;\n    Timer: () => void;\n    TreeProcessor: () => void;\n    base: (arg0: void, arg1: void) => void;\n    buildExpectationResult: () => void;\n    errors: () => void;\n    formatErrorMsg: () => void;\n    matchersUtil: (arg0: void) => void;\n    pp: (arg0: void) => void;\n    requireMatchers: (arg0: void, arg1: void) => void;\n    util: () => void;\n    version: () => void;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.core.[function]","newFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.errors = jRequire.errors();\r\n        j$.formatErrorMsg = jRequire.formatErrorMsg();\r\n        j$.Any = jRequire.Any(j$);\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker(j$);\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite(j$);\r\n        j$.Timer = jRequire.Timer();\r\n        j$.TreeProcessor = jRequire.TreeProcessor();\r\n        j$.version = jRequire.version();\r\n        j$.Order = jRequire.Order();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.core.[function]","oldFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.Any = jRequire.Any();\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker();\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite();\r\n        j$.Timer = jRequire.Timer();\r\n        j$.version = jRequire.version();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.core.[function].[arg0]","key":"Order","newType":"() => void","isAny":false,"isClass":false,"containerType":"// Seen as: jRequire\ninterface interface_864 {\n    Any: (arg0: void) => void;\n    Anything: (arg0: void) => void;\n    ArrayContaining: (arg0: void) => void;\n    CallTracker: (arg0: void) => void;\n    Clock: () => void;\n    DelayedFunctionScheduler: () => void;\n    Env: (arg0: void) => void;\n    ExceptionFormatter: () => void;\n    Expectation: () => void;\n    JsApiReporter: () => void;\n    MockDate: () => void;\n    ObjectContaining: (arg0: void) => void;\n    Order: () => void;\n    QueueRunner: (arg0: void) => void;\n    ReportDispatcher: () => void;\n    Spec: (arg0: void) => void;\n    SpyRegistry: (arg0: void) => void;\n    SpyStrategy: () => void;\n    StringMatching: (arg0: void) => void;\n    Suite: (arg0: void) => void;\n    Timer: () => void;\n    TreeProcessor: () => void;\n    base: (arg0: void, arg1: void) => void;\n    buildExpectationResult: () => void;\n    errors: () => void;\n    formatErrorMsg: () => void;\n    matchersUtil: (arg0: void) => void;\n    pp: (arg0: void) => void;\n    requireMatchers: (arg0: void, arg1: void) => void;\n    util: () => void;\n    version: () => void;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.core.[function]","newFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.errors = jRequire.errors();\r\n        j$.formatErrorMsg = jRequire.formatErrorMsg();\r\n        j$.Any = jRequire.Any(j$);\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker(j$);\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite(j$);\r\n        j$.Timer = jRequire.Timer();\r\n        j$.TreeProcessor = jRequire.TreeProcessor();\r\n        j$.version = jRequire.version();\r\n        j$.Order = jRequire.Order();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.core.[function]","oldFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.Any = jRequire.Any();\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker();\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite();\r\n        j$.Timer = jRequire.Timer();\r\n        j$.version = jRequire.version();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.core.[function].[arg0]","key":"formatErrorMsg","newType":"() => void","isAny":false,"isClass":false,"containerType":"// Seen as: jRequire\ninterface interface_864 {\n    Any: (arg0: void) => void;\n    Anything: (arg0: void) => void;\n    ArrayContaining: (arg0: void) => void;\n    CallTracker: (arg0: void) => void;\n    Clock: () => void;\n    DelayedFunctionScheduler: () => void;\n    Env: (arg0: void) => void;\n    ExceptionFormatter: () => void;\n    Expectation: () => void;\n    JsApiReporter: () => void;\n    MockDate: () => void;\n    ObjectContaining: (arg0: void) => void;\n    Order: () => void;\n    QueueRunner: (arg0: void) => void;\n    ReportDispatcher: () => void;\n    Spec: (arg0: void) => void;\n    SpyRegistry: (arg0: void) => void;\n    SpyStrategy: () => void;\n    StringMatching: (arg0: void) => void;\n    Suite: (arg0: void) => void;\n    Timer: () => void;\n    TreeProcessor: () => void;\n    base: (arg0: void, arg1: void) => void;\n    buildExpectationResult: () => void;\n    errors: () => void;\n    formatErrorMsg: () => void;\n    matchersUtil: (arg0: void) => void;\n    pp: (arg0: void) => void;\n    requireMatchers: (arg0: void, arg1: void) => void;\n    util: () => void;\n    version: () => void;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.core.[function]","newFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.errors = jRequire.errors();\r\n        j$.formatErrorMsg = jRequire.formatErrorMsg();\r\n        j$.Any = jRequire.Any(j$);\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker(j$);\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite(j$);\r\n        j$.Timer = jRequire.Timer();\r\n        j$.TreeProcessor = jRequire.TreeProcessor();\r\n        j$.version = jRequire.version();\r\n        j$.Order = jRequire.Order();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.core.[function]","oldFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.Any = jRequire.Any();\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker();\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite();\r\n        j$.Timer = jRequire.Timer();\r\n        j$.version = jRequire.version();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.core.[function].[arg0]","key":"errors","newType":"() => void","isAny":false,"isClass":false,"containerType":"// Seen as: jRequire\ninterface interface_864 {\n    Any: (arg0: void) => void;\n    Anything: (arg0: void) => void;\n    ArrayContaining: (arg0: void) => void;\n    CallTracker: (arg0: void) => void;\n    Clock: () => void;\n    DelayedFunctionScheduler: () => void;\n    Env: (arg0: void) => void;\n    ExceptionFormatter: () => void;\n    Expectation: () => void;\n    JsApiReporter: () => void;\n    MockDate: () => void;\n    ObjectContaining: (arg0: void) => void;\n    Order: () => void;\n    QueueRunner: (arg0: void) => void;\n    ReportDispatcher: () => void;\n    Spec: (arg0: void) => void;\n    SpyRegistry: (arg0: void) => void;\n    SpyStrategy: () => void;\n    StringMatching: (arg0: void) => void;\n    Suite: (arg0: void) => void;\n    Timer: () => void;\n    TreeProcessor: () => void;\n    base: (arg0: void, arg1: void) => void;\n    buildExpectationResult: () => void;\n    errors: () => void;\n    formatErrorMsg: () => void;\n    matchersUtil: (arg0: void) => void;\n    pp: (arg0: void) => void;\n    requireMatchers: (arg0: void, arg1: void) => void;\n    util: () => void;\n    version: () => void;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.toMatch.[function]","newFunction":"function(j$) {\r\n\r\n    var getErrorMsg = j$.formatErrorMsg('<toMatch>', 'expect(<expectation>).toMatch(<string> || <regexp>)');\r\n\r\n    function toMatch() {\r\n        return {\r\n            compare: function(actual, expected) {\r\n                if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {\r\n                    throw new Error(getErrorMsg('Expected is not a String or a RegExp'));\r\n                }\r\n\r\n                var regexp = new RegExp(expected);\r\n\r\n                return {\r\n                    pass: regexp.test(actual)\r\n                };\r\n            }\r\n        };\r\n    }\r\n\r\n    return toMatch;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.toMatch.[function]","oldFunction":"function(j$) {\r\n\r\n    function toMatch() {\r\n        return {\r\n            compare: function(actual, expected) {\r\n                if (!j$.isString_(expected) && !j$.isA_('RegExp', expected)) {\r\n                    throw new Error('Expected is not a String or a RegExp');\r\n                }\r\n\r\n                var regexp = new RegExp(expected);\r\n\r\n                return {\r\n                    pass: regexp.test(actual)\r\n                };\r\n            }\r\n        };\r\n    }\r\n\r\n    return toMatch;\r\n}","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.toMatch.[function].[arg0]","key":"formatErrorMsg","newType":"(arg0: void, arg1: void) => void","isAny":false,"isClass":false,"containerType":"// Seen as: j$\ninterface interface_899 {\n    formatErrorMsg: (arg0: void, arg1: void) => void;\n    isA_: (arg0: void, arg1: void) => void;\n    isString_: (arg0: void) => void;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.SpyRegistry.[function]","newFunction":"function(j$) {\r\n\r\n    var getErrorMsg = j$.formatErrorMsg('<spyOn>', 'spyOn(<object>, <methodName>)');\r\n\r\n    function SpyRegistry(options) {\r\n        options = options || {};\r\n        var currentSpies = options.currentSpies || function() { return []; };\r\n\r\n        this.allowRespy = function(allow){\r\n            this.respy = allow;\r\n        };\r\n\r\n        this.spyOn = function(obj, methodName) {\r\n\r\n            if (j$.util.isUndefined(obj)) {\r\n                throw new Error(getErrorMsg('could not find an object to spy upon for ' + methodName + '()'));\r\n            }\r\n\r\n            if (j$.util.isUndefined(methodName)) {\r\n                throw new Error(getErrorMsg('No method name supplied'));\r\n            }\r\n\r\n            if (j$.util.isUndefined(obj[methodName])) {\r\n                throw new Error(getErrorMsg(methodName + '() method does not exist'));\r\n            }\r\n\r\n            if (obj[methodName] && j$.isSpy(obj[methodName])  ) {\r\n                if ( !!this.respy ){\r\n                    return obj[methodName];\r\n                }else {\r\n                    throw new Error(getErrorMsg(methodName + ' has already been spied upon'));\r\n                }\r\n            }\r\n\r\n            var descriptor;\r\n            try {\r\n                descriptor = Object.getOwnPropertyDescriptor(obj, methodName);\r\n            } catch(e) {\r\n                // IE 8 doesn't support `definePropery` on non-DOM nodes\r\n            }\r\n\r\n            if (descriptor && !(descriptor.writable || descriptor.set)) {\r\n                throw new Error(getErrorMsg(methodName + ' is not declared writable or has no setter'));\r\n            }\r\n\r\n            var originalMethod = obj[methodName],\r\n                spiedMethod = j$.createSpy(methodName, originalMethod),\r\n                restoreStrategy;\r\n\r\n            if (Object.prototype.hasOwnProperty.call(obj, methodName)) {\r\n                restoreStrategy = function() {\r\n                    obj[methodName] = originalMethod;\r\n                };\r\n            } else {\r\n                restoreStrategy = function() {\r\n                    delete obj[methodName];\r\n                };\r\n            }\r\n\r\n            currentSpies().push({\r\n                restoreObjectToOriginalState: restoreStrategy\r\n            });\r\n\r\n            obj[methodName] = spiedMethod;\r\n\r\n            return spiedMethod;\r\n        };\r\n\r\n        this.clearSpies = function() {\r\n            var spies = currentSpies();\r\n            for (var i = spies.length - 1; i >= 0; i--) {\r\n                var spyEntry = spies[i];\r\n                spyEntry.restoreObjectToOriginalState();\r\n            }\r\n        };\r\n    }\r\n\r\n    return SpyRegistry;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.SpyRegistry.[function]","oldFunction":"function(j$) {\r\n\r\n    function SpyRegistry(options) {\r\n        options = options || {};\r\n        var currentSpies = options.currentSpies || function() { return []; };\r\n\r\n        this.spyOn = function(obj, methodName) {\r\n            if (j$.util.isUndefined(obj)) {\r\n                throw new Error('spyOn could not find an object to spy upon for ' + methodName + '()');\r\n            }\r\n\r\n            if (j$.util.isUndefined(methodName)) {\r\n                throw new Error('No method name supplied');\r\n            }\r\n\r\n            if (j$.util.isUndefined(obj[methodName])) {\r\n                throw new Error(methodName + '() method does not exist');\r\n            }\r\n\r\n            if (obj[methodName] && j$.isSpy(obj[methodName])) {\r\n                //TODO?: should this return the current spy? Downside: may cause user confusion about spy state\r\n                throw new Error(methodName + ' has already been spied upon');\r\n            }\r\n\r\n            var spy = j$.createSpy(methodName, obj[methodName]);\r\n\r\n            currentSpies().push({\r\n                spy: spy,\r\n                baseObj: obj,\r\n                methodName: methodName,\r\n                originalValue: obj[methodName]\r\n            });\r\n\r\n            obj[methodName] = spy;\r\n\r\n            return spy;\r\n        };\r\n\r\n        this.clearSpies = function() {\r\n            var spies = currentSpies();\r\n            for (var i = 0; i < spies.length; i++) {\r\n                var spyEntry = spies[i];\r\n                spyEntry.baseObj[spyEntry.methodName] = spyEntry.originalValue;\r\n            }\r\n        };\r\n    }\r\n\r\n    return SpyRegistry;\r\n}","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.SpyRegistry.[function].[arg0]","key":"formatErrorMsg","newType":"(arg0: void, arg1: void) => void","isAny":false,"isClass":false,"containerType":"// Seen as: j$\ninterface interface_819 {\n    createSpy: (arg0: void, arg1: void) => void;\n    formatErrorMsg: (arg0: void, arg1: void) => void;\n    isSpy: (arg0: void) => void;\n    util: {isUndefined: (arg0: void) => void};\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.toHaveBeenCalled.[function]","newFunction":"function(j$) {\r\n\r\n    var getErrorMsg = j$.formatErrorMsg('<toHaveBeenCalled>', 'expect(<spyObj>).toHaveBeenCalled()');\r\n\r\n    function toHaveBeenCalled() {\r\n        return {\r\n            compare: function(actual) {\r\n                var result = {};\r\n\r\n                if (!j$.isSpy(actual)) {\r\n                    throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));\r\n                }\r\n\r\n                if (arguments.length > 1) {\r\n                    throw new Error(getErrorMsg('Does not take arguments, use toHaveBeenCalledWith'));\r\n                }\r\n\r\n                result.pass = actual.calls.any();\r\n\r\n                result.message = result.pass ?\r\n                'Expected spy ' + actual.and.identity() + ' not to have been called.' :\r\n                'Expected spy ' + actual.and.identity() + ' to have been called.';\r\n\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n\r\n    return toHaveBeenCalled;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.toHaveBeenCalled.[function]","oldFunction":"function(j$) {\r\n\r\n    function toHaveBeenCalled() {\r\n        return {\r\n            compare: function(actual) {\r\n                var result = {};\r\n\r\n                if (!j$.isSpy(actual)) {\r\n                    throw new Error('Expected a spy, but got ' + j$.pp(actual) + '.');\r\n                }\r\n\r\n                if (arguments.length > 1) {\r\n                    throw new Error('toHaveBeenCalled does not take arguments, use toHaveBeenCalledWith');\r\n                }\r\n\r\n                result.pass = actual.calls.any();\r\n\r\n                result.message = result.pass ?\r\n                'Expected spy ' + actual.and.identity() + ' not to have been called.' :\r\n                'Expected spy ' + actual.and.identity() + ' to have been called.';\r\n\r\n                return result;\r\n            }\r\n        };\r\n    }\r\n\r\n    return toHaveBeenCalled;\r\n}","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.toHaveBeenCalled.[function].[arg0]","key":"formatErrorMsg","newType":"(arg0: void, arg1: void) => void","isAny":false,"isClass":false,"containerType":"// Seen as: j$\ninterface interface_890 {\n    formatErrorMsg: (arg0: void, arg1: void) => void;\n    isSpy: (arg0: void) => void;\n    pp: (arg0: void) => void;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.Spec.[function]","newFunction":"function(j$) {\r\n    function Spec(attrs) {\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.id = attrs.id;\r\n        this.description = attrs.description || '';\r\n        this.queueableFn = attrs.queueableFn;\r\n        this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n        this.userContext = attrs.userContext || function() { return {}; };\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n        this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n        this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n        this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        if (!this.queueableFn.fn) {\r\n            this.pend();\r\n        }\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: [],\r\n            passedExpectations: [],\r\n            pendingReason: ''\r\n        };\r\n    }\r\n\r\n    Spec.prototype.addExpectationResult = function(passed, data, isError) {\r\n        var expectationResult = this.expectationResultFactory(data);\r\n        if (passed) {\r\n            this.result.passedExpectations.push(expectationResult);\r\n        } else {\r\n            this.result.failedExpectations.push(expectationResult);\r\n\r\n            if (this.throwOnExpectationFailure && !isError) {\r\n                throw new j$.errors.ExpectationFailed();\r\n            }\r\n        }\r\n    };\r\n\r\n    Spec.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Spec.prototype.execute = function(onComplete, enabled) {\r\n        var self = this;\r\n\r\n        this.onStart(this);\r\n\r\n        if (!this.isExecutable() || this.markedPending || enabled === false) {\r\n            complete(enabled);\r\n            return;\r\n        }\r\n\r\n        var fns = this.beforeAndAfterFns();\r\n        var allFns = fns.befores.concat(this.queueableFn).concat(fns.afters);\r\n\r\n        this.queueRunnerFactory({\r\n            queueableFns: allFns,\r\n            onException: function() { self.onException.apply(self, arguments); },\r\n            onComplete: complete,\r\n            userContext: this.userContext()\r\n        });\r\n\r\n        function complete(enabledAgain) {\r\n            self.result.status = self.status(enabledAgain);\r\n            self.resultCallback(self.result);\r\n\r\n            if (onComplete) {\r\n                onComplete();\r\n            }\r\n        }\r\n    };\r\n\r\n    Spec.prototype.onException = function onException(e) {\r\n        if (Spec.isPendingSpecException(e)) {\r\n            this.pend(extractCustomPendingMessage(e));\r\n            return;\r\n        }\r\n\r\n        if (e instanceof j$.errors.ExpectationFailed) {\r\n            return;\r\n        }\r\n\r\n        this.addExpectationResult(false, {\r\n            matcherName: '',\r\n            passed: false,\r\n            expected: '',\r\n            actual: '',\r\n            error: e\r\n        }, true);\r\n    };\r\n\r\n    Spec.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Spec.prototype.pend = function(message) {\r\n        this.markedPending = true;\r\n        if (message) {\r\n            this.result.pendingReason = message;\r\n        }\r\n    };\r\n\r\n    Spec.prototype.getResult = function() {\r\n        this.result.status = this.status();\r\n        return this.result;\r\n    };\r\n\r\n    Spec.prototype.status = function(enabled) {\r\n        if (this.disabled || enabled === false) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.markedPending) {\r\n            return 'pending';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'passed';\r\n        }\r\n    };\r\n\r\n    Spec.prototype.isExecutable = function() {\r\n        return !this.disabled;\r\n    };\r\n\r\n    Spec.prototype.getFullName = function() {\r\n        return this.getSpecName(this);\r\n    };\r\n\r\n    var extractCustomPendingMessage = function(e) {\r\n        var fullMessage = e.toString(),\r\n            boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),\r\n            boilerplateEnd = boilerplateStart + Spec.pendingSpecExceptionMessage.length;\r\n\r\n        return fullMessage.substr(boilerplateEnd);\r\n    };\r\n\r\n    Spec.pendingSpecExceptionMessage = '=> marked Pending';\r\n\r\n    Spec.isPendingSpecException = function(e) {\r\n        return !!(e && e.toString && e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1);\r\n    };\r\n\r\n    return Spec;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.Spec.[function]","oldFunction":"function(j$) {\r\n    function Spec(attrs) {\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.id = attrs.id;\r\n        this.description = attrs.description || '';\r\n        this.queueableFn = attrs.queueableFn;\r\n        this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n        this.userContext = attrs.userContext || function() { return {}; };\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n        this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n        this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n        this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n\r\n        if (!this.queueableFn.fn) {\r\n            this.pend();\r\n        }\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: [],\r\n            passedExpectations: [],\r\n            pendingReason: ''\r\n        };\r\n    }\r\n\r\n    Spec.prototype.addExpectationResult = function(passed, data) {\r\n        var expectationResult = this.expectationResultFactory(data);\r\n        if (passed) {\r\n            this.result.passedExpectations.push(expectationResult);\r\n        } else {\r\n            this.result.failedExpectations.push(expectationResult);\r\n        }\r\n    };\r\n\r\n    Spec.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Spec.prototype.execute = function(onComplete) {\r\n        var self = this;\r\n\r\n        this.onStart(this);\r\n\r\n        if (this.markedPending || this.disabled) {\r\n            complete();\r\n            return;\r\n        }\r\n\r\n        var fns = this.beforeAndAfterFns();\r\n        var allFns = fns.befores.concat(this.queueableFn).concat(fns.afters);\r\n\r\n        this.queueRunnerFactory({\r\n            queueableFns: allFns,\r\n            onException: function() { self.onException.apply(self, arguments); },\r\n            onComplete: complete,\r\n            userContext: this.userContext()\r\n        });\r\n\r\n        function complete() {\r\n            self.result.status = self.status();\r\n            self.resultCallback(self.result);\r\n\r\n            if (onComplete) {\r\n                onComplete();\r\n            }\r\n        }\r\n    };\r\n\r\n    Spec.prototype.onException = function onException(e) {\r\n        if (Spec.isPendingSpecException(e)) {\r\n            this.pend(extractCustomPendingMessage(e));\r\n            return;\r\n        }\r\n\r\n        this.addExpectationResult(false, {\r\n            matcherName: '',\r\n            passed: false,\r\n            expected: '',\r\n            actual: '',\r\n            error: e\r\n        });\r\n    };\r\n\r\n    Spec.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Spec.prototype.pend = function(message) {\r\n        this.markedPending = true;\r\n        if (message) {\r\n            this.result.pendingReason = message;\r\n        }\r\n    };\r\n\r\n    Spec.prototype.status = function() {\r\n        if (this.disabled) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.markedPending) {\r\n            return 'pending';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'passed';\r\n        }\r\n    };\r\n\r\n    Spec.prototype.isExecutable = function() {\r\n        return !this.disabled && !this.markedPending;\r\n    };\r\n\r\n    Spec.prototype.getFullName = function() {\r\n        return this.getSpecName(this);\r\n    };\r\n\r\n    var extractCustomPendingMessage = function(e) {\r\n        var fullMessage = e.toString(),\r\n            boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),\r\n            boilerplateEnd = boilerplateStart + Spec.pendingSpecExceptionMessage.length;\r\n\r\n        return fullMessage.substr(boilerplateEnd);\r\n    };\r\n\r\n    Spec.pendingSpecExceptionMessage = '=> marked Pending';\r\n\r\n    Spec.isPendingSpecException = function(e) {\r\n        return !!(e && e.toString && e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1);\r\n    };\r\n\r\n    return Spec;\r\n}","oldJSDoc":null,"type":"changedType","typePath":"window.jasmineRequire.Spec.[function].[arg0]","newType":"{\n    errors: {ExpectationFailed: () => void}\n}\n","oldType":"any","containerType":"(j$: {errors: {ExpectationFailed: () => void}}) => interface_553","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.core.[function]","newFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.errors = jRequire.errors();\r\n        j$.formatErrorMsg = jRequire.formatErrorMsg();\r\n        j$.Any = jRequire.Any(j$);\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker(j$);\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite(j$);\r\n        j$.Timer = jRequire.Timer();\r\n        j$.TreeProcessor = jRequire.TreeProcessor();\r\n        j$.version = jRequire.version();\r\n        j$.Order = jRequire.Order();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.core.[function]","oldFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.Any = jRequire.Any();\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker();\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite();\r\n        j$.Timer = jRequire.Timer();\r\n        j$.version = jRequire.version();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.core.[function].[return]","key":"TreeProcessor","newType":null,"isAny":true,"isClass":false,"containerType":"// Seen as: j$\ninterface interface_869 {\n    Any: any;\n    Anything: any;\n    ArrayContaining: any;\n    CallTracker: any;\n    Clock: any;\n    DelayedFunctionScheduler: any;\n    Env: any;\n    ExceptionFormatter: any;\n    Expectation: any;\n    JsApiReporter: any;\n    MockDate: any;\n    ObjectContaining: any;\n    Order: any;\n    QueueRunner: any;\n    ReportDispatcher: any;\n    Spec: any;\n    SpyRegistry: any;\n    SpyStrategy: any;\n    StringMatching: any;\n    Suite: any;\n    Timer: any;\n    TreeProcessor: any;\n    buildExpectationResult: any;\n    errors: any;\n    formatErrorMsg: any;\n    matchers: any;\n    matchersUtil: any;\n    pp: any;\n    util: any;\n    version: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.core.[function]","newFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.errors = jRequire.errors();\r\n        j$.formatErrorMsg = jRequire.formatErrorMsg();\r\n        j$.Any = jRequire.Any(j$);\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker(j$);\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite(j$);\r\n        j$.Timer = jRequire.Timer();\r\n        j$.TreeProcessor = jRequire.TreeProcessor();\r\n        j$.version = jRequire.version();\r\n        j$.Order = jRequire.Order();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.core.[function]","oldFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.Any = jRequire.Any();\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker();\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite();\r\n        j$.Timer = jRequire.Timer();\r\n        j$.version = jRequire.version();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.core.[function].[return]","key":"Order","newType":null,"isAny":true,"isClass":false,"containerType":"// Seen as: j$\ninterface interface_869 {\n    Any: any;\n    Anything: any;\n    ArrayContaining: any;\n    CallTracker: any;\n    Clock: any;\n    DelayedFunctionScheduler: any;\n    Env: any;\n    ExceptionFormatter: any;\n    Expectation: any;\n    JsApiReporter: any;\n    MockDate: any;\n    ObjectContaining: any;\n    Order: any;\n    QueueRunner: any;\n    ReportDispatcher: any;\n    Spec: any;\n    SpyRegistry: any;\n    SpyStrategy: any;\n    StringMatching: any;\n    Suite: any;\n    Timer: any;\n    TreeProcessor: any;\n    buildExpectationResult: any;\n    errors: any;\n    formatErrorMsg: any;\n    matchers: any;\n    matchersUtil: any;\n    pp: any;\n    util: any;\n    version: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.core.[function]","newFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.errors = jRequire.errors();\r\n        j$.formatErrorMsg = jRequire.formatErrorMsg();\r\n        j$.Any = jRequire.Any(j$);\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker(j$);\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite(j$);\r\n        j$.Timer = jRequire.Timer();\r\n        j$.TreeProcessor = jRequire.TreeProcessor();\r\n        j$.version = jRequire.version();\r\n        j$.Order = jRequire.Order();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.core.[function]","oldFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.Any = jRequire.Any();\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker();\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite();\r\n        j$.Timer = jRequire.Timer();\r\n        j$.version = jRequire.version();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.core.[function].[return]","key":"formatErrorMsg","newType":null,"isAny":true,"isClass":false,"containerType":"// Seen as: j$\ninterface interface_869 {\n    Any: any;\n    Anything: any;\n    ArrayContaining: any;\n    CallTracker: any;\n    Clock: any;\n    DelayedFunctionScheduler: any;\n    Env: any;\n    ExceptionFormatter: any;\n    Expectation: any;\n    JsApiReporter: any;\n    MockDate: any;\n    ObjectContaining: any;\n    Order: any;\n    QueueRunner: any;\n    ReportDispatcher: any;\n    Spec: any;\n    SpyRegistry: any;\n    SpyStrategy: any;\n    StringMatching: any;\n    Suite: any;\n    Timer: any;\n    TreeProcessor: any;\n    buildExpectationResult: any;\n    errors: any;\n    formatErrorMsg: any;\n    matchers: any;\n    matchersUtil: any;\n    pp: any;\n    util: any;\n    version: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.core.[function]","newFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.errors = jRequire.errors();\r\n        j$.formatErrorMsg = jRequire.formatErrorMsg();\r\n        j$.Any = jRequire.Any(j$);\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker(j$);\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite(j$);\r\n        j$.Timer = jRequire.Timer();\r\n        j$.TreeProcessor = jRequire.TreeProcessor();\r\n        j$.version = jRequire.version();\r\n        j$.Order = jRequire.Order();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.core.[function]","oldFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.Any = jRequire.Any();\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker();\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite();\r\n        j$.Timer = jRequire.Timer();\r\n        j$.version = jRequire.version();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.core.[function].[return]","key":"errors","newType":null,"isAny":true,"isClass":false,"containerType":"// Seen as: j$\ninterface interface_869 {\n    Any: any;\n    Anything: any;\n    ArrayContaining: any;\n    CallTracker: any;\n    Clock: any;\n    DelayedFunctionScheduler: any;\n    Env: any;\n    ExceptionFormatter: any;\n    Expectation: any;\n    JsApiReporter: any;\n    MockDate: any;\n    ObjectContaining: any;\n    Order: any;\n    QueueRunner: any;\n    ReportDispatcher: any;\n    Spec: any;\n    SpyRegistry: any;\n    SpyStrategy: any;\n    StringMatching: any;\n    Suite: any;\n    Timer: any;\n    TreeProcessor: any;\n    buildExpectationResult: any;\n    errors: any;\n    formatErrorMsg: any;\n    matchers: any;\n    matchersUtil: any;\n    pp: any;\n    util: any;\n    version: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor].[function].[arg0]","newFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor].[function].[arg0]","oldFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.Suite.[constructor].[function].[arg0]","key":"clearStack","isClass":false,"containerType":"// Seen as: attrs\ninterface interface_731 {\n    description: string;\n    env: jasmine.Env;\n    expectationFactory: (actual: any, spec: jasmine.Suite) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationResultFactory: (attrs: interface_707) => interface_709;\n    id: string;\n    parentSuite: jasmine.Suite | interface_728;\n    throwOnExpectationFailure: boolean;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor].[function].[arg0]","newFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor].[function].[arg0]","oldFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.Suite.[constructor].[function].[arg0]","key":"onStart","isClass":false,"containerType":"// Seen as: attrs\ninterface interface_731 {\n    description: string;\n    env: jasmine.Env;\n    expectationFactory: (actual: any, spec: jasmine.Suite) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationResultFactory: (attrs: interface_707) => interface_709;\n    id: string;\n    parentSuite: jasmine.Suite | interface_728;\n    throwOnExpectationFailure: boolean;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor].[function].[arg0]","newFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor].[function].[arg0]","oldFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.Suite.[constructor].[function].[arg0]","key":"runnablesExplictlySetGetter","isClass":false,"containerType":"// Seen as: attrs\ninterface interface_731 {\n    description: string;\n    env: jasmine.Env;\n    expectationFactory: (actual: any, spec: jasmine.Suite) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationResultFactory: (attrs: interface_707) => interface_709;\n    id: string;\n    parentSuite: jasmine.Suite | interface_728;\n    throwOnExpectationFailure: boolean;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor].[function].[arg0]","newFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor].[function].[arg0]","oldFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.Suite.[constructor].[function].[arg0]","key":"queueRunner","isClass":false,"containerType":"// Seen as: attrs\ninterface interface_731 {\n    description: string;\n    env: jasmine.Env;\n    expectationFactory: (actual: any, spec: jasmine.Suite) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationResultFactory: (attrs: interface_707) => interface_709;\n    id: string;\n    parentSuite: jasmine.Suite | interface_728;\n    throwOnExpectationFailure: boolean;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor].[function].[arg0]","newFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor].[function].[arg0]","oldFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.Suite.[constructor].[function].[arg0]","key":"resultCallback","isClass":false,"containerType":"// Seen as: attrs\ninterface interface_731 {\n    description: string;\n    env: jasmine.Env;\n    expectationFactory: (actual: any, spec: jasmine.Suite) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationResultFactory: (attrs: interface_707) => interface_709;\n    id: string;\n    parentSuite: jasmine.Suite | interface_728;\n    throwOnExpectationFailure: boolean;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor].[function].[arg0]","newFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor].[function].[arg0]","oldFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Suite.[constructor].[function].[arg0]","key":"throwOnExpectationFailure","newType":"boolean","isAny":false,"isClass":false,"containerType":"// Seen as: attrs\ninterface interface_731 {\n    description: string;\n    env: jasmine.Env;\n    expectationFactory: (actual: any, spec: jasmine.Suite) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationResultFactory: (attrs: interface_707) => interface_709;\n    id: string;\n    parentSuite: jasmine.Suite | interface_728;\n    throwOnExpectationFailure: boolean;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Clock.[constructor].[function]","newFunction":"function Clock(global, delayedFunctionSchedulerFactory, mockDate) {\r\n        var self = this,\r\n            realTimingFunctions = {\r\n                setTimeout: global.setTimeout,\r\n                clearTimeout: global.clearTimeout,\r\n                setInterval: global.setInterval,\r\n                clearInterval: global.clearInterval\r\n            },\r\n            fakeTimingFunctions = {\r\n                setTimeout: setTimeout,\r\n                clearTimeout: clearTimeout,\r\n                setInterval: setInterval,\r\n                clearInterval: clearInterval\r\n            },\r\n            installed = false,\r\n            delayedFunctionScheduler,\r\n            timer;\r\n\r\n\r\n        self.install = function() {\r\n            if(!originalTimingFunctionsIntact()) {\r\n                throw new Error('Jasmine Clock was unable to install over custom global timer functions. Is the clock already installed?');\r\n            }\r\n            replace(global, fakeTimingFunctions);\r\n            timer = fakeTimingFunctions;\r\n            delayedFunctionScheduler = delayedFunctionSchedulerFactory();\r\n            installed = true;\r\n\r\n            return self;\r\n        };\r\n\r\n        self.uninstall = function() {\r\n            delayedFunctionScheduler = null;\r\n            mockDate.uninstall();\r\n            replace(global, realTimingFunctions);\r\n\r\n            timer = realTimingFunctions;\r\n            installed = false;\r\n        };\r\n\r\n        self.withMock = function(closure) {\r\n            this.install();\r\n            try {\r\n                closure();\r\n            } finally {\r\n                this.uninstall();\r\n            }\r\n        };\r\n\r\n        self.mockDate = function(initialDate) {\r\n            mockDate.install(initialDate);\r\n        };\r\n\r\n        self.setTimeout = function(fn, delay, params) {\r\n            if (legacyIE()) {\r\n                if (arguments.length > 2) {\r\n                    throw new Error('IE < 9 cannot support extra params to setTimeout without a polyfill');\r\n                }\r\n                return timer.setTimeout(fn, delay);\r\n            }\r\n            return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);\r\n        };\r\n\r\n        self.setInterval = function(fn, delay, params) {\r\n            if (legacyIE()) {\r\n                if (arguments.length > 2) {\r\n                    throw new Error('IE < 9 cannot support extra params to setInterval without a polyfill');\r\n                }\r\n                return timer.setInterval(fn, delay);\r\n            }\r\n            return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);\r\n        };\r\n\r\n        self.clearTimeout = function(id) {\r\n            return Function.prototype.call.apply(timer.clearTimeout, [global, id]);\r\n        };\r\n\r\n        self.clearInterval = function(id) {\r\n            return Function.prototype.call.apply(timer.clearInterval, [global, id]);\r\n        };\r\n\r\n        self.tick = function(millis) {\r\n            if (installed) {\r\n                delayedFunctionScheduler.tick(millis, function(millis) { mockDate.tick(millis); });\r\n            } else {\r\n                throw new Error('Mock clock is not installed, use jasmine.clock().install()');\r\n            }\r\n        };\r\n\r\n        return self;\r\n\r\n        function originalTimingFunctionsIntact() {\r\n            return global.setTimeout === realTimingFunctions.setTimeout &&\r\n                global.clearTimeout === realTimingFunctions.clearTimeout &&\r\n                global.setInterval === realTimingFunctions.setInterval &&\r\n                global.clearInterval === realTimingFunctions.clearInterval;\r\n        }\r\n\r\n        function legacyIE() {\r\n            //if these methods are polyfilled, apply will be present\r\n            return !(realTimingFunctions.setTimeout || realTimingFunctions.setInterval).apply;\r\n        }\r\n\r\n        function replace(dest, source) {\r\n            for (var prop in source) {\r\n                dest[prop] = source[prop];\r\n            }\r\n        }\r\n\r\n        function setTimeout(fn, delay) {\r\n            return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));\r\n        }\r\n\r\n        function clearTimeout(id) {\r\n            return delayedFunctionScheduler.removeFunctionWithId(id);\r\n        }\r\n\r\n        function setInterval(fn, interval) {\r\n            return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);\r\n        }\r\n\r\n        function clearInterval(id) {\r\n            return delayedFunctionScheduler.removeFunctionWithId(id);\r\n        }\r\n\r\n        function argSlice(argsObj, n) {\r\n            return Array.prototype.slice.call(argsObj, n);\r\n        }\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Clock.[constructor].[function]","oldFunction":"function Clock(global, delayedFunctionScheduler, mockDate) {\r\n        var self = this,\r\n            realTimingFunctions = {\r\n                setTimeout: global.setTimeout,\r\n                clearTimeout: global.clearTimeout,\r\n                setInterval: global.setInterval,\r\n                clearInterval: global.clearInterval\r\n            },\r\n            fakeTimingFunctions = {\r\n                setTimeout: setTimeout,\r\n                clearTimeout: clearTimeout,\r\n                setInterval: setInterval,\r\n                clearInterval: clearInterval\r\n            },\r\n            installed = false,\r\n            timer;\r\n\r\n\r\n        self.install = function() {\r\n            replace(global, fakeTimingFunctions);\r\n            timer = fakeTimingFunctions;\r\n            installed = true;\r\n\r\n            return self;\r\n        };\r\n\r\n        self.uninstall = function() {\r\n            delayedFunctionScheduler.reset();\r\n            mockDate.uninstall();\r\n            replace(global, realTimingFunctions);\r\n\r\n            timer = realTimingFunctions;\r\n            installed = false;\r\n        };\r\n\r\n        self.mockDate = function(initialDate) {\r\n            mockDate.install(initialDate);\r\n        };\r\n\r\n        self.setTimeout = function(fn, delay, params) {\r\n            if (legacyIE()) {\r\n                if (arguments.length > 2) {\r\n                    throw new Error('IE < 9 cannot support extra params to setTimeout without a polyfill');\r\n                }\r\n                return timer.setTimeout(fn, delay);\r\n            }\r\n            return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);\r\n        };\r\n\r\n        self.setInterval = function(fn, delay, params) {\r\n            if (legacyIE()) {\r\n                if (arguments.length > 2) {\r\n                    throw new Error('IE < 9 cannot support extra params to setInterval without a polyfill');\r\n                }\r\n                return timer.setInterval(fn, delay);\r\n            }\r\n            return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);\r\n        };\r\n\r\n        self.clearTimeout = function(id) {\r\n            return Function.prototype.call.apply(timer.clearTimeout, [global, id]);\r\n        };\r\n\r\n        self.clearInterval = function(id) {\r\n            return Function.prototype.call.apply(timer.clearInterval, [global, id]);\r\n        };\r\n\r\n        self.tick = function(millis) {\r\n            if (installed) {\r\n                mockDate.tick(millis);\r\n                delayedFunctionScheduler.tick(millis);\r\n            } else {\r\n                throw new Error('Mock clock is not installed, use jasmine.clock().install()');\r\n            }\r\n        };\r\n\r\n        return self;\r\n\r\n        function legacyIE() {\r\n            //if these methods are polyfilled, apply will be present\r\n            return !(realTimingFunctions.setTimeout || realTimingFunctions.setInterval).apply;\r\n        }\r\n\r\n        function replace(dest, source) {\r\n            for (var prop in source) {\r\n                dest[prop] = source[prop];\r\n            }\r\n        }\r\n\r\n        function setTimeout(fn, delay) {\r\n            return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));\r\n        }\r\n\r\n        function clearTimeout(id) {\r\n            return delayedFunctionScheduler.removeFunctionWithId(id);\r\n        }\r\n\r\n        function setInterval(fn, interval) {\r\n            return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);\r\n        }\r\n\r\n        function clearInterval(id) {\r\n            return delayedFunctionScheduler.removeFunctionWithId(id);\r\n        }\r\n\r\n        function argSlice(argsObj, n) {\r\n            return Array.prototype.slice.call(argsObj, n);\r\n        }\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.Clock.[constructor].[function].[arg1]","newType":"() => jasmine.DelayedFunctionScheduler","oldType":"jasmine.DelayedFunctionScheduler","containerType":"class Clock1 {\n    constructor (global: Window | interface_470, delayedFunctionSchedulerFactory: () => jasmine.DelayedFunctionScheduler, mockDate: jasmine.MockDate);\n    clearInterval: (id: Window) => any;\n    clearTimeout: (id: Window) => any;\n    install: () => jasmine.Clock;\n    mockDate: (initialDate: {getTime: () => void}) => void;\n    setInterval: (fn: any, delay: any, params: any) => any;\n    setTimeout: (fn: any, delay: any, params: any) => any;\n    tick: (millis: any) => void;\n    uninstall: () => void;\n    withMock: (closure: () => void) => void;\n}\n","containerDescription":"class jasmine.Clock"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.util.argsToArray.[function]","newFunction":"function(args) {\r\n        var arrayOfArgs = [];\r\n        for (var i = 0; i < args.length; i++) {\r\n            arrayOfArgs.push(args[i]);\r\n        }\r\n        return arrayOfArgs;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.util.argsToArray.[function]","oldFunction":"function(args) {\r\n        var arrayOfArgs = [];\r\n        for (var i = 0; i < args.length; i++) {\r\n            arrayOfArgs.push(args[i]);\r\n        }\r\n        return arrayOfArgs;\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.util.argsToArray.[function].[arg0]","newType":"any[]","oldType":"// Seen as: args\ninterface interface_648 {\n    [index: number]: any;\n    length: number;\n}\n\n","containerType":"(args: any[]) => Array<any>","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.buildExpectationResult.[function]","newFunction":"function buildExpectationResult(options) {\r\n        var messageFormatter = options.messageFormatter || function() {},\r\n            stackFormatter = options.stackFormatter || function() {};\r\n\r\n        var result = {\r\n            matcherName: options.matcherName,\r\n            message: message(),\r\n            stack: stack(),\r\n            passed: options.passed\r\n        };\r\n\r\n        if(!result.passed) {\r\n            result.expected = options.expected;\r\n            result.actual = options.actual;\r\n        }\r\n\r\n        return result;\r\n\r\n        function message() {\r\n            if (options.passed) {\r\n                return 'Passed.';\r\n            } else if (options.message) {\r\n                return options.message;\r\n            } else if (options.error) {\r\n                return messageFormatter(options.error);\r\n            }\r\n            return '';\r\n        }\r\n\r\n        function stack() {\r\n            if (options.passed) {\r\n                return '';\r\n            }\r\n\r\n            var error = options.error;\r\n            if (!error) {\r\n                try {\r\n                    throw new Error(message());\r\n                } catch (e) {\r\n                    error = e;\r\n                }\r\n            }\r\n            return stackFormatter(error);\r\n        }\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.buildExpectationResult.[function]","oldFunction":"function buildExpectationResult(options) {\r\n        var messageFormatter = options.messageFormatter || function() {},\r\n            stackFormatter = options.stackFormatter || function() {};\r\n\r\n        var result = {\r\n            matcherName: options.matcherName,\r\n            message: message(),\r\n            stack: stack(),\r\n            passed: options.passed\r\n        };\r\n\r\n        if(!result.passed) {\r\n            result.expected = options.expected;\r\n            result.actual = options.actual;\r\n        }\r\n\r\n        return result;\r\n\r\n        function message() {\r\n            if (options.passed) {\r\n                return 'Passed.';\r\n            } else if (options.message) {\r\n                return options.message;\r\n            } else if (options.error) {\r\n                return messageFormatter(options.error);\r\n            }\r\n            return '';\r\n        }\r\n\r\n        function stack() {\r\n            if (options.passed) {\r\n                return '';\r\n            }\r\n\r\n            var error = options.error;\r\n            if (!error) {\r\n                try {\r\n                    throw new Error(message());\r\n                } catch (e) {\r\n                    error = e;\r\n                }\r\n            }\r\n            return stackFormatter(error);\r\n        }\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.buildExpectationResult.[function].[arg0].actual","newType":"string","oldType":"any","containerType":"// Seen as: attrs, options\ninterface interface_745 {\n    actual: string;\n    error: any;\n    expected: string;\n    matcherName: string;\n    message: any;\n    messageFormatter: (error: interface_682) => string;\n    passed: boolean;\n    stackFormatter: (error: {stack: any}) => any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.buildExpectationResult.[function]","newFunction":"function buildExpectationResult(options) {\r\n        var messageFormatter = options.messageFormatter || function() {},\r\n            stackFormatter = options.stackFormatter || function() {};\r\n\r\n        var result = {\r\n            matcherName: options.matcherName,\r\n            message: message(),\r\n            stack: stack(),\r\n            passed: options.passed\r\n        };\r\n\r\n        if(!result.passed) {\r\n            result.expected = options.expected;\r\n            result.actual = options.actual;\r\n        }\r\n\r\n        return result;\r\n\r\n        function message() {\r\n            if (options.passed) {\r\n                return 'Passed.';\r\n            } else if (options.message) {\r\n                return options.message;\r\n            } else if (options.error) {\r\n                return messageFormatter(options.error);\r\n            }\r\n            return '';\r\n        }\r\n\r\n        function stack() {\r\n            if (options.passed) {\r\n                return '';\r\n            }\r\n\r\n            var error = options.error;\r\n            if (!error) {\r\n                try {\r\n                    throw new Error(message());\r\n                } catch (e) {\r\n                    error = e;\r\n                }\r\n            }\r\n            return stackFormatter(error);\r\n        }\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.buildExpectationResult.[function]","oldFunction":"function buildExpectationResult(options) {\r\n        var messageFormatter = options.messageFormatter || function() {},\r\n            stackFormatter = options.stackFormatter || function() {};\r\n\r\n        var result = {\r\n            matcherName: options.matcherName,\r\n            message: message(),\r\n            stack: stack(),\r\n            passed: options.passed\r\n        };\r\n\r\n        if(!result.passed) {\r\n            result.expected = options.expected;\r\n            result.actual = options.actual;\r\n        }\r\n\r\n        return result;\r\n\r\n        function message() {\r\n            if (options.passed) {\r\n                return 'Passed.';\r\n            } else if (options.message) {\r\n                return options.message;\r\n            } else if (options.error) {\r\n                return messageFormatter(options.error);\r\n            }\r\n            return '';\r\n        }\r\n\r\n        function stack() {\r\n            if (options.passed) {\r\n                return '';\r\n            }\r\n\r\n            var error = options.error;\r\n            if (!error) {\r\n                try {\r\n                    throw new Error(message());\r\n                } catch (e) {\r\n                    error = e;\r\n                }\r\n            }\r\n            return stackFormatter(error);\r\n        }\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.buildExpectationResult.[function].[arg0].matcherName","newType":"string","oldType":"any","containerType":"// Seen as: attrs, options\ninterface interface_745 {\n    actual: string;\n    error: any;\n    expected: string;\n    matcherName: string;\n    message: any;\n    messageFormatter: (error: interface_682) => string;\n    passed: boolean;\n    stackFormatter: (error: {stack: any}) => any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.buildExpectationResult.[function]","newFunction":"function buildExpectationResult(options) {\r\n        var messageFormatter = options.messageFormatter || function() {},\r\n            stackFormatter = options.stackFormatter || function() {};\r\n\r\n        var result = {\r\n            matcherName: options.matcherName,\r\n            message: message(),\r\n            stack: stack(),\r\n            passed: options.passed\r\n        };\r\n\r\n        if(!result.passed) {\r\n            result.expected = options.expected;\r\n            result.actual = options.actual;\r\n        }\r\n\r\n        return result;\r\n\r\n        function message() {\r\n            if (options.passed) {\r\n                return 'Passed.';\r\n            } else if (options.message) {\r\n                return options.message;\r\n            } else if (options.error) {\r\n                return messageFormatter(options.error);\r\n            }\r\n            return '';\r\n        }\r\n\r\n        function stack() {\r\n            if (options.passed) {\r\n                return '';\r\n            }\r\n\r\n            var error = options.error;\r\n            if (!error) {\r\n                try {\r\n                    throw new Error(message());\r\n                } catch (e) {\r\n                    error = e;\r\n                }\r\n            }\r\n            return stackFormatter(error);\r\n        }\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.buildExpectationResult.[function]","oldFunction":"function buildExpectationResult(options) {\r\n        var messageFormatter = options.messageFormatter || function() {},\r\n            stackFormatter = options.stackFormatter || function() {};\r\n\r\n        var result = {\r\n            matcherName: options.matcherName,\r\n            message: message(),\r\n            stack: stack(),\r\n            passed: options.passed\r\n        };\r\n\r\n        if(!result.passed) {\r\n            result.expected = options.expected;\r\n            result.actual = options.actual;\r\n        }\r\n\r\n        return result;\r\n\r\n        function message() {\r\n            if (options.passed) {\r\n                return 'Passed.';\r\n            } else if (options.message) {\r\n                return options.message;\r\n            } else if (options.error) {\r\n                return messageFormatter(options.error);\r\n            }\r\n            return '';\r\n        }\r\n\r\n        function stack() {\r\n            if (options.passed) {\r\n                return '';\r\n            }\r\n\r\n            var error = options.error;\r\n            if (!error) {\r\n                try {\r\n                    throw new Error(message());\r\n                } catch (e) {\r\n                    error = e;\r\n                }\r\n            }\r\n            return stackFormatter(error);\r\n        }\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.buildExpectationResult.[function].[arg0].passed","newType":"boolean","oldType":"any","containerType":"// Seen as: attrs, options\ninterface interface_745 {\n    actual: string;\n    error: any;\n    expected: string;\n    matcherName: string;\n    message: any;\n    messageFormatter: (error: interface_682) => string;\n    passed: boolean;\n    stackFormatter: (error: {stack: any}) => any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.isSpy.[function]","newFunction":"function(putativeSpy) {\r\n        if (!putativeSpy) {\r\n            return false;\r\n        }\r\n        return putativeSpy.and instanceof j$.SpyStrategy &&\r\n            putativeSpy.calls instanceof j$.CallTracker;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.isSpy.[function]","oldFunction":"function(putativeSpy) {\r\n        if (!putativeSpy) {\r\n            return false;\r\n        }\r\n        return putativeSpy.and instanceof j$.SpyStrategy &&\r\n            putativeSpy.calls instanceof j$.CallTracker;\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.isSpy.[function].[arg0].calls","key":"count","newType":null,"isAny":true,"isClass":false,"containerType":"{\n    allArgs: void, \n    any: void, \n    count: void\n}\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Expectation.addCoreMatchers.[function].[arg0].toHaveBeenCalledTimes","newFunction":"function toHaveBeenCalledTimes() {\r\n        return {\r\n            compare: function(actual, expected) {\r\n                if (!j$.isSpy(actual)) {\r\n                    throw new Error(getErrorMsg('Expected a spy, but got ' + j$.pp(actual) + '.'));\r\n                }\r\n\r\n                var args = Array.prototype.slice.call(arguments, 0),\r\n                    result = { pass: false };\r\n\r\n                if (!j$.isNumber_(expected)){\r\n                    throw new Error(getErrorMsg('The expected times failed is a required argument and must be a number.'));\r\n                }\r\n\r\n                actual = args[0];\r\n                var calls = actual.calls.count();\r\n                var timesMessage = expected === 1 ? 'once' : expected + ' times';\r\n                result.pass = calls === expected;\r\n                result.message = result.pass ?\r\n                'Expected spy ' + actual.and.identity() + ' not to have been called ' + timesMessage + '. It was called ' +  calls + ' times.' :\r\n                'Expected spy ' + actual.and.identity() + ' to have been called ' + timesMessage + '. It was called ' +  calls + ' times.';\r\n                return result;\r\n            }\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Expectation.addCoreMatchers.[function]","oldFunction":"function(matchers) {\r\n        var prototype = Expectation.prototype;\r\n        for (var matcherName in matchers) {\r\n            var matcher = matchers[matcherName];\r\n            prototype[matcherName] = prototype.wrapCompare(matcherName, matcher);\r\n        }\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Expectation.addCoreMatchers.[function].[arg0]","key":"toHaveBeenCalledTimes","newType":"() => interface_774","isAny":false,"isClass":false,"containerType":"interface interface_691 {\n    toBe: typeof jasmine.matchers.toBe;\n    toBeCloseTo: typeof jasmine.matchers.toBeCloseTo;\n    toBeDefined: typeof jasmine.matchers.toBeDefined;\n    toBeFalsy: typeof jasmine.matchers.toBeFalsy;\n    toBeGreaterThan: typeof jasmine.matchers.toBeGreaterThan;\n    toBeGreaterThanOrEqual: typeof jasmine.matchers.toBeGreaterThanOrEqual;\n    toBeLessThan: typeof jasmine.matchers.toBeLessThan;\n    toBeLessThanOrEqual: typeof jasmine.matchers.toBeLessThanOrEqual;\n    toBeNaN: typeof jasmine.matchers.toBeNaN;\n    toBeNull: typeof jasmine.matchers.toBeNull;\n    toBeTruthy: typeof jasmine.matchers.toBeTruthy;\n    toBeUndefined: typeof jasmine.matchers.toBeUndefined;\n    toContain: typeof jasmine.matchers.toContain;\n    toEqual: typeof jasmine.matchers.toEqual;\n    toHaveBeenCalled: typeof jasmine.matchers.toHaveBeenCalled;\n    toHaveBeenCalledTimes: typeof jasmine.matchers.toHaveBeenCalledTimes;\n    toHaveBeenCalledWith: typeof jasmine.matchers.toHaveBeenCalledWith;\n    toMatch: typeof jasmine.matchers.toMatch;\n    toThrow: typeof jasmine.matchers.toThrow;\n    toThrowError: typeof jasmine.matchers.toThrowError;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Expectation.addCoreMatchers.[function].[arg0].toBeGreaterThanOrEqual","newFunction":"function toBeGreaterThanOrEqual() {\r\n        return {\r\n            compare: function(actual, expected) {\r\n                return {\r\n                    pass: actual >= expected\r\n                };\r\n            }\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Expectation.addCoreMatchers.[function]","oldFunction":"function(matchers) {\r\n        var prototype = Expectation.prototype;\r\n        for (var matcherName in matchers) {\r\n            var matcher = matchers[matcherName];\r\n            prototype[matcherName] = prototype.wrapCompare(matcherName, matcher);\r\n        }\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Expectation.addCoreMatchers.[function].[arg0]","key":"toBeGreaterThanOrEqual","newType":"() => interface_759","isAny":false,"isClass":false,"containerType":"interface interface_691 {\n    toBe: typeof jasmine.matchers.toBe;\n    toBeCloseTo: typeof jasmine.matchers.toBeCloseTo;\n    toBeDefined: typeof jasmine.matchers.toBeDefined;\n    toBeFalsy: typeof jasmine.matchers.toBeFalsy;\n    toBeGreaterThan: typeof jasmine.matchers.toBeGreaterThan;\n    toBeGreaterThanOrEqual: typeof jasmine.matchers.toBeGreaterThanOrEqual;\n    toBeLessThan: typeof jasmine.matchers.toBeLessThan;\n    toBeLessThanOrEqual: typeof jasmine.matchers.toBeLessThanOrEqual;\n    toBeNaN: typeof jasmine.matchers.toBeNaN;\n    toBeNull: typeof jasmine.matchers.toBeNull;\n    toBeTruthy: typeof jasmine.matchers.toBeTruthy;\n    toBeUndefined: typeof jasmine.matchers.toBeUndefined;\n    toContain: typeof jasmine.matchers.toContain;\n    toEqual: typeof jasmine.matchers.toEqual;\n    toHaveBeenCalled: typeof jasmine.matchers.toHaveBeenCalled;\n    toHaveBeenCalledTimes: typeof jasmine.matchers.toHaveBeenCalledTimes;\n    toHaveBeenCalledWith: typeof jasmine.matchers.toHaveBeenCalledWith;\n    toMatch: typeof jasmine.matchers.toMatch;\n    toThrow: typeof jasmine.matchers.toThrow;\n    toThrowError: typeof jasmine.matchers.toThrowError;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Expectation.addCoreMatchers.[function].[arg0].toBeLessThanOrEqual","newFunction":"function toBeLessThanOrEqual() {\r\n        return {\r\n\r\n            compare: function(actual, expected) {\r\n                return {\r\n                    pass: actual <= expected\r\n                };\r\n            }\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Expectation.addCoreMatchers.[function]","oldFunction":"function(matchers) {\r\n        var prototype = Expectation.prototype;\r\n        for (var matcherName in matchers) {\r\n            var matcher = matchers[matcherName];\r\n            prototype[matcherName] = prototype.wrapCompare(matcherName, matcher);\r\n        }\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Expectation.addCoreMatchers.[function].[arg0]","key":"toBeLessThanOrEqual","newType":"() => interface_762","isAny":false,"isClass":false,"containerType":"interface interface_691 {\n    toBe: typeof jasmine.matchers.toBe;\n    toBeCloseTo: typeof jasmine.matchers.toBeCloseTo;\n    toBeDefined: typeof jasmine.matchers.toBeDefined;\n    toBeFalsy: typeof jasmine.matchers.toBeFalsy;\n    toBeGreaterThan: typeof jasmine.matchers.toBeGreaterThan;\n    toBeGreaterThanOrEqual: typeof jasmine.matchers.toBeGreaterThanOrEqual;\n    toBeLessThan: typeof jasmine.matchers.toBeLessThan;\n    toBeLessThanOrEqual: typeof jasmine.matchers.toBeLessThanOrEqual;\n    toBeNaN: typeof jasmine.matchers.toBeNaN;\n    toBeNull: typeof jasmine.matchers.toBeNull;\n    toBeTruthy: typeof jasmine.matchers.toBeTruthy;\n    toBeUndefined: typeof jasmine.matchers.toBeUndefined;\n    toContain: typeof jasmine.matchers.toContain;\n    toEqual: typeof jasmine.matchers.toEqual;\n    toHaveBeenCalled: typeof jasmine.matchers.toHaveBeenCalled;\n    toHaveBeenCalledTimes: typeof jasmine.matchers.toHaveBeenCalledTimes;\n    toHaveBeenCalledWith: typeof jasmine.matchers.toHaveBeenCalledWith;\n    toMatch: typeof jasmine.matchers.toMatch;\n    toThrow: typeof jasmine.matchers.toThrow;\n    toThrowError: typeof jasmine.matchers.toThrowError;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.matchersUtil.equals.[function]","newFunction":"function(a, b, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            return eq(a, b, [], [], customTesters);\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.matchersUtil.equals.[function]","oldFunction":"function(a, b, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            return eq(a, b, [], [], customTesters);\r\n        }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.matchersUtil.equals.[function].[arg1]","newType":"string | interface_413","oldType":"string | interface_760","containerType":"(a: string | interface_413, b: string | interface_413, customTesters: Array<function_784>) => boolean","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.buildExpectationResult.[function]","newFunction":"function buildExpectationResult(options) {\r\n        var messageFormatter = options.messageFormatter || function() {},\r\n            stackFormatter = options.stackFormatter || function() {};\r\n\r\n        var result = {\r\n            matcherName: options.matcherName,\r\n            message: message(),\r\n            stack: stack(),\r\n            passed: options.passed\r\n        };\r\n\r\n        if(!result.passed) {\r\n            result.expected = options.expected;\r\n            result.actual = options.actual;\r\n        }\r\n\r\n        return result;\r\n\r\n        function message() {\r\n            if (options.passed) {\r\n                return 'Passed.';\r\n            } else if (options.message) {\r\n                return options.message;\r\n            } else if (options.error) {\r\n                return messageFormatter(options.error);\r\n            }\r\n            return '';\r\n        }\r\n\r\n        function stack() {\r\n            if (options.passed) {\r\n                return '';\r\n            }\r\n\r\n            var error = options.error;\r\n            if (!error) {\r\n                try {\r\n                    throw new Error(message());\r\n                } catch (e) {\r\n                    error = e;\r\n                }\r\n            }\r\n            return stackFormatter(error);\r\n        }\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.buildExpectationResult.[function]","oldFunction":"function buildExpectationResult(options) {\r\n        var messageFormatter = options.messageFormatter || function() {},\r\n            stackFormatter = options.stackFormatter || function() {};\r\n\r\n        var result = {\r\n            matcherName: options.matcherName,\r\n            message: message(),\r\n            stack: stack(),\r\n            passed: options.passed\r\n        };\r\n\r\n        if(!result.passed) {\r\n            result.expected = options.expected;\r\n            result.actual = options.actual;\r\n        }\r\n\r\n        return result;\r\n\r\n        function message() {\r\n            if (options.passed) {\r\n                return 'Passed.';\r\n            } else if (options.message) {\r\n                return options.message;\r\n            } else if (options.error) {\r\n                return messageFormatter(options.error);\r\n            }\r\n            return '';\r\n        }\r\n\r\n        function stack() {\r\n            if (options.passed) {\r\n                return '';\r\n            }\r\n\r\n            var error = options.error;\r\n            if (!error) {\r\n                try {\r\n                    throw new Error(message());\r\n                } catch (e) {\r\n                    error = e;\r\n                }\r\n            }\r\n            return stackFormatter(error);\r\n        }\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.buildExpectationResult.[function].[return].passed","newType":"boolean","oldType":"any","containerType":"// Seen as: result\ninterface interface_709 {\n    actual: string;\n    expected: string;\n    matcherName: string;\n    message: string;\n    passed: boolean;\n    stack: string;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Spec.[constructor].[function].[arg0]","newFunction":"function Spec(attrs) {\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.id = attrs.id;\r\n        this.description = attrs.description || '';\r\n        this.queueableFn = attrs.queueableFn;\r\n        this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n        this.userContext = attrs.userContext || function() { return {}; };\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n        this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n        this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n        this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        if (!this.queueableFn.fn) {\r\n            this.pend();\r\n        }\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: [],\r\n            passedExpectations: [],\r\n            pendingReason: ''\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Spec.[constructor].[function].[arg0]","oldFunction":"function Spec(attrs) {\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.id = attrs.id;\r\n        this.description = attrs.description || '';\r\n        this.queueableFn = attrs.queueableFn;\r\n        this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n        this.userContext = attrs.userContext || function() { return {}; };\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n        this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n        this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n        this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n\r\n        if (!this.queueableFn.fn) {\r\n            this.pend();\r\n        }\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: [],\r\n            passedExpectations: [],\r\n            pendingReason: ''\r\n        };\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Spec.[constructor].[function].[arg0]","key":"throwOnExpectationFailure","newType":"boolean","isAny":false,"isClass":false,"containerType":"// Seen as: attrs\ninterface interface_715 {\n    beforeAndAfterFns: () => {afters: Array<any>, befores: Array<any>};\n    catchingExceptions: any;\n    description: string;\n    expectationFactory: (actual: any, spec: jasmine.Suite) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationResultFactory: (attrs: interface_707) => interface_709;\n    getSpecName: (spec: void) => string;\n    id: string | number;\n    onStart: (spec: void) => void;\n    queueRunnerFactory: (options: interface_713) => void;\n    queueableFn: {fn: () => void, timeout: () => number};\n    resultCallback: (result: void) => void;\n    throwOnExpectationFailure: boolean;\n    userContext: () => any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.util.arrayContains.[function]","newFunction":"function(array, search) {\r\n        var i = array.length;\r\n        while (i--) {\r\n            if (array[i] === search) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.util.arrayContains.[function]","oldFunction":"function(array, search) {\r\n        var i = array.length;\r\n        while (i--) {\r\n            if (array[i] === search) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.util.arrayContains.[function].[arg1]","key":"test","isClass":false,"containerType":"// Seen as: value\ninterface interface_747 {\n    and: {identity: void};\n    jasmineToString: void;\n    nodeType: any;\n    toString: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.util.arrayContains.[function]","newFunction":"function(array, search) {\r\n        var i = array.length;\r\n        while (i--) {\r\n            if (array[i] === search) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.util.arrayContains.[function]","oldFunction":"function(array, search) {\r\n        var i = array.length;\r\n        while (i--) {\r\n            if (array[i] === search) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.util.arrayContains.[function].[arg1]","key":"calls","isClass":false,"containerType":"// Seen as: value\ninterface interface_747 {\n    and: {identity: void};\n    jasmineToString: void;\n    nodeType: any;\n    toString: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.core.[function]","newFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.errors = jRequire.errors();\r\n        j$.formatErrorMsg = jRequire.formatErrorMsg();\r\n        j$.Any = jRequire.Any(j$);\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker(j$);\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite(j$);\r\n        j$.Timer = jRequire.Timer();\r\n        j$.TreeProcessor = jRequire.TreeProcessor();\r\n        j$.version = jRequire.version();\r\n        j$.Order = jRequire.Order();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.core.[function]","oldFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.Any = jRequire.Any();\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker();\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite();\r\n        j$.Timer = jRequire.Timer();\r\n        j$.version = jRequire.version();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","oldJSDoc":null,"type":"changedArgCount","typePath":"window.jasmineRequire.core.[function].[arg0].Any","isClass":false,"newType":"(arg0: void) => void","newTypeDescription":"function","oldType":"() => void","oldArgCount":0,"newArgCount":1,"containerType":"// Seen as: jRequire\ninterface interface_864 {\n    Any: (arg0: void) => void;\n    Anything: (arg0: void) => void;\n    ArrayContaining: (arg0: void) => void;\n    CallTracker: (arg0: void) => void;\n    Clock: () => void;\n    DelayedFunctionScheduler: () => void;\n    Env: (arg0: void) => void;\n    ExceptionFormatter: () => void;\n    Expectation: () => void;\n    JsApiReporter: () => void;\n    MockDate: () => void;\n    ObjectContaining: (arg0: void) => void;\n    Order: () => void;\n    QueueRunner: (arg0: void) => void;\n    ReportDispatcher: () => void;\n    Spec: (arg0: void) => void;\n    SpyRegistry: (arg0: void) => void;\n    SpyStrategy: () => void;\n    StringMatching: (arg0: void) => void;\n    Suite: (arg0: void) => void;\n    Timer: () => void;\n    TreeProcessor: () => void;\n    base: (arg0: void, arg1: void) => void;\n    buildExpectationResult: () => void;\n    errors: () => void;\n    formatErrorMsg: () => void;\n    matchersUtil: (arg0: void) => void;\n    pp: (arg0: void) => void;\n    requireMatchers: (arg0: void, arg1: void) => void;\n    util: () => void;\n    version: () => void;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.core.[function]","newFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.errors = jRequire.errors();\r\n        j$.formatErrorMsg = jRequire.formatErrorMsg();\r\n        j$.Any = jRequire.Any(j$);\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker(j$);\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite(j$);\r\n        j$.Timer = jRequire.Timer();\r\n        j$.TreeProcessor = jRequire.TreeProcessor();\r\n        j$.version = jRequire.version();\r\n        j$.Order = jRequire.Order();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.core.[function]","oldFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.Any = jRequire.Any();\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker();\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite();\r\n        j$.Timer = jRequire.Timer();\r\n        j$.version = jRequire.version();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","oldJSDoc":null,"type":"changedArgCount","typePath":"window.jasmineRequire.core.[function].[arg0].Suite","isClass":false,"newType":"(arg0: void) => void","newTypeDescription":"function","oldType":"() => void","oldArgCount":0,"newArgCount":1,"containerType":"// Seen as: jRequire\ninterface interface_864 {\n    Any: (arg0: void) => void;\n    Anything: (arg0: void) => void;\n    ArrayContaining: (arg0: void) => void;\n    CallTracker: (arg0: void) => void;\n    Clock: () => void;\n    DelayedFunctionScheduler: () => void;\n    Env: (arg0: void) => void;\n    ExceptionFormatter: () => void;\n    Expectation: () => void;\n    JsApiReporter: () => void;\n    MockDate: () => void;\n    ObjectContaining: (arg0: void) => void;\n    Order: () => void;\n    QueueRunner: (arg0: void) => void;\n    ReportDispatcher: () => void;\n    Spec: (arg0: void) => void;\n    SpyRegistry: (arg0: void) => void;\n    SpyStrategy: () => void;\n    StringMatching: (arg0: void) => void;\n    Suite: (arg0: void) => void;\n    Timer: () => void;\n    TreeProcessor: () => void;\n    base: (arg0: void, arg1: void) => void;\n    buildExpectationResult: () => void;\n    errors: () => void;\n    formatErrorMsg: () => void;\n    matchersUtil: (arg0: void) => void;\n    pp: (arg0: void) => void;\n    requireMatchers: (arg0: void, arg1: void) => void;\n    util: () => void;\n    version: () => void;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.core.[function]","newFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.errors = jRequire.errors();\r\n        j$.formatErrorMsg = jRequire.formatErrorMsg();\r\n        j$.Any = jRequire.Any(j$);\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker(j$);\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite(j$);\r\n        j$.Timer = jRequire.Timer();\r\n        j$.TreeProcessor = jRequire.TreeProcessor();\r\n        j$.version = jRequire.version();\r\n        j$.Order = jRequire.Order();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.core.[function]","oldFunction":"function(jRequire) {\r\n        var j$ = {};\r\n\r\n        jRequire.base(j$, jasmineGlobal);\r\n        j$.util = jRequire.util();\r\n        j$.Any = jRequire.Any();\r\n        j$.Anything = jRequire.Anything(j$);\r\n        j$.CallTracker = jRequire.CallTracker();\r\n        j$.MockDate = jRequire.MockDate();\r\n        j$.Clock = jRequire.Clock();\r\n        j$.DelayedFunctionScheduler = jRequire.DelayedFunctionScheduler();\r\n        j$.Env = jRequire.Env(j$);\r\n        j$.ExceptionFormatter = jRequire.ExceptionFormatter();\r\n        j$.Expectation = jRequire.Expectation();\r\n        j$.buildExpectationResult = jRequire.buildExpectationResult();\r\n        j$.JsApiReporter = jRequire.JsApiReporter();\r\n        j$.matchersUtil = jRequire.matchersUtil(j$);\r\n        j$.ObjectContaining = jRequire.ObjectContaining(j$);\r\n        j$.ArrayContaining = jRequire.ArrayContaining(j$);\r\n        j$.pp = jRequire.pp(j$);\r\n        j$.QueueRunner = jRequire.QueueRunner(j$);\r\n        j$.ReportDispatcher = jRequire.ReportDispatcher();\r\n        j$.Spec = jRequire.Spec(j$);\r\n        j$.SpyRegistry = jRequire.SpyRegistry(j$);\r\n        j$.SpyStrategy = jRequire.SpyStrategy();\r\n        j$.StringMatching = jRequire.StringMatching(j$);\r\n        j$.Suite = jRequire.Suite();\r\n        j$.Timer = jRequire.Timer();\r\n        j$.version = jRequire.version();\r\n\r\n        j$.matchers = jRequire.requireMatchers(jRequire, j$);\r\n\r\n        return j$;\r\n    }","oldJSDoc":null,"type":"changedArgCount","typePath":"window.jasmineRequire.core.[function].[arg0].CallTracker","isClass":false,"newType":"(arg0: void) => void","newTypeDescription":"function","oldType":"() => void","oldArgCount":0,"newArgCount":1,"containerType":"// Seen as: jRequire\ninterface interface_864 {\n    Any: (arg0: void) => void;\n    Anything: (arg0: void) => void;\n    ArrayContaining: (arg0: void) => void;\n    CallTracker: (arg0: void) => void;\n    Clock: () => void;\n    DelayedFunctionScheduler: () => void;\n    Env: (arg0: void) => void;\n    ExceptionFormatter: () => void;\n    Expectation: () => void;\n    JsApiReporter: () => void;\n    MockDate: () => void;\n    ObjectContaining: (arg0: void) => void;\n    Order: () => void;\n    QueueRunner: (arg0: void) => void;\n    ReportDispatcher: () => void;\n    Spec: (arg0: void) => void;\n    SpyRegistry: (arg0: void) => void;\n    SpyStrategy: () => void;\n    StringMatching: (arg0: void) => void;\n    Suite: (arg0: void) => void;\n    Timer: () => void;\n    TreeProcessor: () => void;\n    base: (arg0: void, arg1: void) => void;\n    buildExpectationResult: () => void;\n    errors: () => void;\n    formatErrorMsg: () => void;\n    matchersUtil: (arg0: void) => void;\n    pp: (arg0: void) => void;\n    requireMatchers: (arg0: void, arg1: void) => void;\n    util: () => void;\n    version: () => void;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.QueueRunner.[constructor].[function].[arg0]","newFunction":"function QueueRunner(attrs) {\r\n        this.queueableFns = attrs.queueableFns || [];\r\n        this.onComplete = attrs.onComplete || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.onException = attrs.onException || function() {};\r\n        this.catchException = attrs.catchException || function() { return true; };\r\n        this.userContext = attrs.userContext || {};\r\n        this.timeout = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};\r\n        this.fail = attrs.fail || function() {};\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.QueueRunner.[constructor].[function].[arg0]","oldFunction":"function QueueRunner(attrs) {\r\n        this.queueableFns = attrs.queueableFns || [];\r\n        this.onComplete = attrs.onComplete || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.onException = attrs.onException || function() {};\r\n        this.catchException = attrs.catchException || function() { return true; };\r\n        this.userContext = attrs.userContext || {};\r\n        this.timer = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};\r\n        this.fail = attrs.fail || function() {};\r\n    }","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.QueueRunner.[constructor].[function].[arg0]","key":"timer","isClass":false,"containerType":"// Seen as: attrs, options\ninterface interface_704 {\n    catchException: (e: {toString: () => void}) => boolean;\n    clearStack: (fn: () => void) => void;\n    fail: (error: {message: any}) => void;\n    onComplete: any;\n    onException: any;\n    queueableFns: any;\n    timeout: interface_702;\n    userContext: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.HtmlReporter.[constructor].[function].[arg0]","newFunction":"function HtmlReporter(options) {\r\n        var env = options.env || {},\r\n            getContainer = options.getContainer,\r\n            createElement = options.createElement,\r\n            createTextNode = options.createTextNode,\r\n            onRaiseExceptionsClick = options.onRaiseExceptionsClick || function() {},\r\n            onThrowExpectationsClick = options.onThrowExpectationsClick || function() {},\r\n            onRandomClick = options.onRandomClick || function() {},\r\n            addToExistingQueryString = options.addToExistingQueryString || defaultQueryString,\r\n            timer = options.timer || noopTimer,\r\n            results = [],\r\n            specsExecuted = 0,\r\n            failureCount = 0,\r\n            pendingSpecCount = 0,\r\n            htmlReporterMain,\r\n            symbols,\r\n            failedSuites = [];\r\n\r\n        this.initialize = function() {\r\n            clearPrior();\r\n            htmlReporterMain = createDom('div', {className: 'jasmine_html-reporter'},\r\n                createDom('div', {className: 'jasmine-banner'},\r\n                    createDom('a', {className: 'jasmine-title', href: 'http://jasmine.github.io/', target: '_blank'}),\r\n                    createDom('span', {className: 'jasmine-version'}, j$.version)\r\n                ),\r\n                createDom('ul', {className: 'jasmine-symbol-summary'}),\r\n                createDom('div', {className: 'jasmine-alert'}),\r\n                createDom('div', {className: 'jasmine-results'},\r\n                    createDom('div', {className: 'jasmine-failures'})\r\n                )\r\n            );\r\n            getContainer().appendChild(htmlReporterMain);\r\n        };\r\n\r\n        var totalSpecsDefined;\r\n        this.jasmineStarted = function(options) {\r\n            totalSpecsDefined = options.totalSpecsDefined || 0;\r\n            timer.start();\r\n        };\r\n\r\n        var summary = createDom('div', {className: 'jasmine-summary'});\r\n\r\n        var topResults = new j$.ResultsNode({}, '', null),\r\n            currentParent = topResults;\r\n\r\n        this.suiteStarted = function(result) {\r\n            currentParent.addChild(result, 'suite');\r\n            currentParent = currentParent.last();\r\n        };\r\n\r\n        this.suiteDone = function(result) {\r\n            if (result.status == 'failed') {\r\n                failedSuites.push(result);\r\n            }\r\n\r\n            if (currentParent == topResults) {\r\n                return;\r\n            }\r\n\r\n            currentParent = currentParent.parent;\r\n        };\r\n\r\n        this.specStarted = function(result) {\r\n            currentParent.addChild(result, 'spec');\r\n        };\r\n\r\n        var failures = [];\r\n        this.specDone = function(result) {\r\n            if(noExpectations(result) && typeof console !== 'undefined' && typeof console.error !== 'undefined') {\r\n                console.error('Spec \\'' + result.fullName + '\\' has no expectations.');\r\n            }\r\n\r\n            if (result.status != 'disabled') {\r\n                specsExecuted++;\r\n            }\r\n\r\n            if (!symbols){\r\n                symbols = find('.jasmine-symbol-summary');\r\n            }\r\n\r\n            symbols.appendChild(createDom('li', {\r\n                    className: noExpectations(result) ? 'jasmine-empty' : 'jasmine-' + result.status,\r\n                    id: 'spec_' + result.id,\r\n                    title: result.fullName\r\n                }\r\n            ));\r\n\r\n            if (result.status == 'failed') {\r\n                failureCount++;\r\n\r\n                var failure =\r\n                    createDom('div', {className: 'jasmine-spec-detail jasmine-failed'},\r\n                        createDom('div', {className: 'jasmine-description'},\r\n                            createDom('a', {title: result.fullName, href: specHref(result)}, result.fullName)\r\n                        ),\r\n                        createDom('div', {className: 'jasmine-messages'})\r\n                    );\r\n                var messages = failure.childNodes[1];\r\n\r\n                for (var i = 0; i < result.failedExpectations.length; i++) {\r\n                    var expectation = result.failedExpectations[i];\r\n                    messages.appendChild(createDom('div', {className: 'jasmine-result-message'}, expectation.message));\r\n                    messages.appendChild(createDom('div', {className: 'jasmine-stack-trace'}, expectation.stack));\r\n                }\r\n\r\n                failures.push(failure);\r\n            }\r\n\r\n            if (result.status == 'pending') {\r\n                pendingSpecCount++;\r\n            }\r\n        };\r\n\r\n        this.jasmineDone = function(doneResult) {\r\n            var banner = find('.jasmine-banner');\r\n            var alert = find('.jasmine-alert');\r\n            var order = doneResult && doneResult.order;\r\n            alert.appendChild(createDom('span', {className: 'jasmine-duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));\r\n\r\n            banner.appendChild(\r\n                createDom('div', { className: 'jasmine-run-options' },\r\n                    createDom('span', { className: 'jasmine-trigger' }, 'Options'),\r\n                    createDom('div', { className: 'jasmine-payload' },\r\n                        createDom('div', { className: 'jasmine-exceptions' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-raise',\r\n                                id: 'jasmine-raise-exceptions',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-raise-exceptions' }, 'raise exceptions')),\r\n                        createDom('div', { className: 'jasmine-throw-failures' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-throw',\r\n                                id: 'jasmine-throw-failures',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-throw-failures' }, 'stop spec on expectation failure')),\r\n                        createDom('div', { className: 'jasmine-random-order' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-random',\r\n                                id: 'jasmine-random-order',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-random-order' }, 'run tests in random order'))\r\n                    )\r\n                ));\r\n\r\n            var raiseCheckbox = find('#jasmine-raise-exceptions');\r\n\r\n            raiseCheckbox.checked = !env.catchingExceptions();\r\n            raiseCheckbox.onclick = onRaiseExceptionsClick;\r\n\r\n            var throwCheckbox = find('#jasmine-throw-failures');\r\n            throwCheckbox.checked = env.throwingExpectationFailures();\r\n            throwCheckbox.onclick = onThrowExpectationsClick;\r\n\r\n            var randomCheckbox = find('#jasmine-random-order');\r\n            randomCheckbox.checked = env.randomTests();\r\n            randomCheckbox.onclick = onRandomClick;\r\n\r\n            var optionsMenu = find('.jasmine-run-options'),\r\n                optionsTrigger = optionsMenu.querySelector('.jasmine-trigger'),\r\n                optionsPayload = optionsMenu.querySelector('.jasmine-payload'),\r\n                isOpen = /\\bjasmine-open\\b/;\r\n\r\n            optionsTrigger.onclick = function() {\r\n                if (isOpen.test(optionsPayload.className)) {\r\n                    optionsPayload.className = optionsPayload.className.replace(isOpen, '');\r\n                } else {\r\n                    optionsPayload.className += ' jasmine-open';\r\n                }\r\n            };\r\n\r\n            if (specsExecuted < totalSpecsDefined) {\r\n                var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';\r\n                var skippedLink = order && order.random ? '?random=true' : '?';\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-bar jasmine-skipped'},\r\n                        createDom('a', {href: skippedLink, title: 'Run all specs'}, skippedMessage)\r\n                    )\r\n                );\r\n            }\r\n            var statusBarMessage = '';\r\n            var statusBarClassName = 'jasmine-bar ';\r\n\r\n            if (totalSpecsDefined > 0) {\r\n                statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);\r\n                if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }\r\n                statusBarClassName += (failureCount > 0) ? 'jasmine-failed' : 'jasmine-passed';\r\n            } else {\r\n                statusBarClassName += 'jasmine-skipped';\r\n                statusBarMessage += 'No specs found';\r\n            }\r\n\r\n            var seedBar;\r\n            if (order && order.random) {\r\n                seedBar = createDom('span', {className: 'jasmine-seed-bar'},\r\n                    ', randomized with seed ',\r\n                    createDom('a', {title: 'randomized with seed ' + order.seed, href: seedHref(order.seed)}, order.seed)\r\n                );\r\n            }\r\n\r\n            alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage, seedBar));\r\n\r\n            var errorBarClassName = 'jasmine-bar jasmine-errored';\r\n            var errorBarMessagePrefix = 'AfterAll ';\r\n\r\n            for(var i = 0; i < failedSuites.length; i++) {\r\n                var failedSuite = failedSuites[i];\r\n                for(var j = 0; j < failedSuite.failedExpectations.length; j++) {\r\n                    alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessagePrefix + failedSuite.failedExpectations[j].message));\r\n                }\r\n            }\r\n\r\n            var globalFailures = (doneResult && doneResult.failedExpectations) || [];\r\n            for(i = 0; i < globalFailures.length; i++) {\r\n                var failure = globalFailures[i];\r\n                alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessagePrefix + failure.message));\r\n            }\r\n\r\n            var results = find('.jasmine-results');\r\n            results.appendChild(summary);\r\n\r\n            summaryList(topResults, summary);\r\n\r\n            function summaryList(resultsTree, domParent) {\r\n                var specListNode;\r\n                for (var i = 0; i < resultsTree.children.length; i++) {\r\n                    var resultNode = resultsTree.children[i];\r\n                    if (resultNode.type == 'suite') {\r\n                        var suiteListNode = createDom('ul', {className: 'jasmine-suite', id: 'suite-' + resultNode.result.id},\r\n                            createDom('li', {className: 'jasmine-suite-detail'},\r\n                                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)\r\n                            )\r\n                        );\r\n\r\n                        summaryList(resultNode, suiteListNode);\r\n                        domParent.appendChild(suiteListNode);\r\n                    }\r\n                    if (resultNode.type == 'spec') {\r\n                        if (domParent.getAttribute('class') != 'jasmine-specs') {\r\n                            specListNode = createDom('ul', {className: 'jasmine-specs'});\r\n                            domParent.appendChild(specListNode);\r\n                        }\r\n                        var specDescription = resultNode.result.description;\r\n                        if(noExpectations(resultNode.result)) {\r\n                            specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;\r\n                        }\r\n                        if(resultNode.result.status === 'pending' && resultNode.result.pendingReason !== '') {\r\n                            specDescription = specDescription + ' PENDING WITH MESSAGE: ' + resultNode.result.pendingReason;\r\n                        }\r\n                        specListNode.appendChild(\r\n                            createDom('li', {\r\n                                    className: 'jasmine-' + resultNode.result.status,\r\n                                    id: 'spec-' + resultNode.result.id\r\n                                },\r\n                                createDom('a', {href: specHref(resultNode.result)}, specDescription)\r\n                            )\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (failures.length) {\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-spec-list'},\r\n                        createDom('span', {}, 'Spec List | '),\r\n                        createDom('a', {className: 'jasmine-failures-menu', href: '#'}, 'Failures')));\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-failure-list'},\r\n                        createDom('a', {className: 'jasmine-spec-list-menu', href: '#'}, 'Spec List'),\r\n                        createDom('span', {}, ' | Failures ')));\r\n\r\n                find('.jasmine-failures-menu').onclick = function() {\r\n                    setMenuModeTo('jasmine-failure-list');\r\n                };\r\n                find('.jasmine-spec-list-menu').onclick = function() {\r\n                    setMenuModeTo('jasmine-spec-list');\r\n                };\r\n\r\n                setMenuModeTo('jasmine-failure-list');\r\n\r\n                var failureNode = find('.jasmine-failures');\r\n                for (i = 0; i < failures.length; i++) {\r\n                    failureNode.appendChild(failures[i]);\r\n                }\r\n            }\r\n        };\r\n\r\n        return this;\r\n\r\n        function find(selector) {\r\n            return getContainer().querySelector('.jasmine_html-reporter ' + selector);\r\n        }\r\n\r\n        function clearPrior() {\r\n            // return the reporter\r\n            var oldReporter = find('');\r\n\r\n            if(oldReporter) {\r\n                getContainer().removeChild(oldReporter);\r\n            }\r\n        }\r\n\r\n        function createDom(type, attrs, childrenVarArgs) {\r\n            var el = createElement(type);\r\n\r\n            for (var i = 2; i < arguments.length; i++) {\r\n                var child = arguments[i];\r\n\r\n                if (typeof child === 'string') {\r\n                    el.appendChild(createTextNode(child));\r\n                } else {\r\n                    if (child) {\r\n                        el.appendChild(child);\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (var attr in attrs) {\r\n                if (attr == 'className') {\r\n                    el[attr] = attrs[attr];\r\n                } else {\r\n                    el.setAttribute(attr, attrs[attr]);\r\n                }\r\n            }\r\n\r\n            return el;\r\n        }\r\n\r\n        function pluralize(singular, count) {\r\n            var word = (count == 1 ? singular : singular + 's');\r\n\r\n            return '' + count + ' ' + word;\r\n        }\r\n\r\n        function specHref(result) {\r\n            return addToExistingQueryString('spec', result.fullName);\r\n        }\r\n\r\n        function seedHref(seed) {\r\n            return addToExistingQueryString('seed', seed);\r\n        }\r\n\r\n        function defaultQueryString(key, value) {\r\n            return '?' + key + '=' + value;\r\n        }\r\n\r\n        function setMenuModeTo(mode) {\r\n            htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);\r\n        }\r\n\r\n        function noExpectations(result) {\r\n            return (result.failedExpectations.length + result.passedExpectations.length) === 0 &&\r\n                result.status === 'passed';\r\n        }\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.HtmlReporter.[constructor].[function].[arg0]","oldFunction":"function HtmlReporter(options) {\r\n        var env = options.env || {},\r\n            getContainer = options.getContainer,\r\n            createElement = options.createElement,\r\n            createTextNode = options.createTextNode,\r\n            onRaiseExceptionsClick = options.onRaiseExceptionsClick || function() {},\r\n            addToExistingQueryString = options.addToExistingQueryString || defaultQueryString,\r\n            timer = options.timer || noopTimer,\r\n            results = [],\r\n            specsExecuted = 0,\r\n            failureCount = 0,\r\n            pendingSpecCount = 0,\r\n            htmlReporterMain,\r\n            symbols,\r\n            failedSuites = [];\r\n\r\n        this.initialize = function() {\r\n            clearPrior();\r\n            htmlReporterMain = createDom('div', {className: 'jasmine_html-reporter'},\r\n                createDom('div', {className: 'banner'},\r\n                    createDom('a', {className: 'title', href: 'http://jasmine.github.io/', target: '_blank'}),\r\n                    createDom('span', {className: 'version'}, j$.version)\r\n                ),\r\n                createDom('ul', {className: 'symbol-summary'}),\r\n                createDom('div', {className: 'alert'}),\r\n                createDom('div', {className: 'results'},\r\n                    createDom('div', {className: 'failures'})\r\n                )\r\n            );\r\n            getContainer().appendChild(htmlReporterMain);\r\n\r\n            symbols = find('.symbol-summary');\r\n        };\r\n\r\n        var totalSpecsDefined;\r\n        this.jasmineStarted = function(options) {\r\n            totalSpecsDefined = options.totalSpecsDefined || 0;\r\n            timer.start();\r\n        };\r\n\r\n        var summary = createDom('div', {className: 'summary'});\r\n\r\n        var topResults = new j$.ResultsNode({}, '', null),\r\n            currentParent = topResults;\r\n\r\n        this.suiteStarted = function(result) {\r\n            currentParent.addChild(result, 'suite');\r\n            currentParent = currentParent.last();\r\n        };\r\n\r\n        this.suiteDone = function(result) {\r\n            if (result.status == 'failed') {\r\n                failedSuites.push(result);\r\n            }\r\n\r\n            if (currentParent == topResults) {\r\n                return;\r\n            }\r\n\r\n            currentParent = currentParent.parent;\r\n        };\r\n\r\n        this.specStarted = function(result) {\r\n            currentParent.addChild(result, 'spec');\r\n        };\r\n\r\n        var failures = [];\r\n        this.specDone = function(result) {\r\n            if(noExpectations(result) && typeof console !== 'undefined' && typeof console.error !== 'undefined') {\r\n                console.error('Spec \\'' + result.fullName + '\\' has no expectations.');\r\n            }\r\n\r\n            if (result.status != 'disabled') {\r\n                specsExecuted++;\r\n            }\r\n\r\n            symbols.appendChild(createDom('li', {\r\n                    className: noExpectations(result) ? 'empty' : result.status,\r\n                    id: 'spec_' + result.id,\r\n                    title: result.fullName\r\n                }\r\n            ));\r\n\r\n            if (result.status == 'failed') {\r\n                failureCount++;\r\n\r\n                var failure =\r\n                    createDom('div', {className: 'spec-detail failed'},\r\n                        createDom('div', {className: 'description'},\r\n                            createDom('a', {title: result.fullName, href: specHref(result)}, result.fullName)\r\n                        ),\r\n                        createDom('div', {className: 'messages'})\r\n                    );\r\n                var messages = failure.childNodes[1];\r\n\r\n                for (var i = 0; i < result.failedExpectations.length; i++) {\r\n                    var expectation = result.failedExpectations[i];\r\n                    messages.appendChild(createDom('div', {className: 'result-message'}, expectation.message));\r\n                    messages.appendChild(createDom('div', {className: 'stack-trace'}, expectation.stack));\r\n                }\r\n\r\n                failures.push(failure);\r\n            }\r\n\r\n            if (result.status == 'pending') {\r\n                pendingSpecCount++;\r\n            }\r\n        };\r\n\r\n        this.jasmineDone = function() {\r\n            var banner = find('.banner');\r\n            banner.appendChild(createDom('span', {className: 'duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));\r\n\r\n            var alert = find('.alert');\r\n\r\n            alert.appendChild(createDom('span', { className: 'exceptions' },\r\n                createDom('label', { className: 'label', 'for': 'raise-exceptions' }, 'raise exceptions'),\r\n                createDom('input', {\r\n                    className: 'raise',\r\n                    id: 'raise-exceptions',\r\n                    type: 'checkbox'\r\n                })\r\n            ));\r\n            var checkbox = find('#raise-exceptions');\r\n\r\n            checkbox.checked = !env.catchingExceptions();\r\n            checkbox.onclick = onRaiseExceptionsClick;\r\n\r\n            if (specsExecuted < totalSpecsDefined) {\r\n                var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'bar skipped'},\r\n                        createDom('a', {href: '?', title: 'Run all specs'}, skippedMessage)\r\n                    )\r\n                );\r\n            }\r\n            var statusBarMessage = '';\r\n            var statusBarClassName = 'bar ';\r\n\r\n            if (totalSpecsDefined > 0) {\r\n                statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);\r\n                if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }\r\n                statusBarClassName += (failureCount > 0) ? 'failed' : 'passed';\r\n            } else {\r\n                statusBarClassName += 'skipped';\r\n                statusBarMessage += 'No specs found';\r\n            }\r\n\r\n            alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage));\r\n\r\n            for(i = 0; i < failedSuites.length; i++) {\r\n                var failedSuite = failedSuites[i];\r\n                for(var j = 0; j < failedSuite.failedExpectations.length; j++) {\r\n                    var errorBarMessage = 'AfterAll ' + failedSuite.failedExpectations[j].message;\r\n                    var errorBarClassName = 'bar errored';\r\n                    alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessage));\r\n                }\r\n            }\r\n\r\n            var results = find('.results');\r\n            results.appendChild(summary);\r\n\r\n            summaryList(topResults, summary);\r\n\r\n            function summaryList(resultsTree, domParent) {\r\n                var specListNode;\r\n                for (var i = 0; i < resultsTree.children.length; i++) {\r\n                    var resultNode = resultsTree.children[i];\r\n                    if (resultNode.type == 'suite') {\r\n                        var suiteListNode = createDom('ul', {className: 'suite', id: 'suite-' + resultNode.result.id},\r\n                            createDom('li', {className: 'suite-detail'},\r\n                                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)\r\n                            )\r\n                        );\r\n\r\n                        summaryList(resultNode, suiteListNode);\r\n                        domParent.appendChild(suiteListNode);\r\n                    }\r\n                    if (resultNode.type == 'spec') {\r\n                        if (domParent.getAttribute('class') != 'specs') {\r\n                            specListNode = createDom('ul', {className: 'specs'});\r\n                            domParent.appendChild(specListNode);\r\n                        }\r\n                        var specDescription = resultNode.result.description;\r\n                        if(noExpectations(resultNode.result)) {\r\n                            specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;\r\n                        }\r\n                        if(resultNode.result.status === 'pending' && resultNode.result.pendingReason !== '') {\r\n                            specDescription = specDescription + ' PENDING WITH MESSAGE: ' + resultNode.result.pendingReason;\r\n                        }\r\n                        specListNode.appendChild(\r\n                            createDom('li', {\r\n                                    className: resultNode.result.status,\r\n                                    id: 'spec-' + resultNode.result.id\r\n                                },\r\n                                createDom('a', {href: specHref(resultNode.result)}, specDescription)\r\n                            )\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (failures.length) {\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'menu bar spec-list'},\r\n                        createDom('span', {}, 'Spec List | '),\r\n                        createDom('a', {className: 'failures-menu', href: '#'}, 'Failures')));\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'menu bar failure-list'},\r\n                        createDom('a', {className: 'spec-list-menu', href: '#'}, 'Spec List'),\r\n                        createDom('span', {}, ' | Failures ')));\r\n\r\n                find('.failures-menu').onclick = function() {\r\n                    setMenuModeTo('failure-list');\r\n                };\r\n                find('.spec-list-menu').onclick = function() {\r\n                    setMenuModeTo('spec-list');\r\n                };\r\n\r\n                setMenuModeTo('failure-list');\r\n\r\n                var failureNode = find('.failures');\r\n                for (var i = 0; i < failures.length; i++) {\r\n                    failureNode.appendChild(failures[i]);\r\n                }\r\n            }\r\n        };\r\n\r\n        return this;\r\n\r\n        function find(selector) {\r\n            return getContainer().querySelector('.jasmine_html-reporter ' + selector);\r\n        }\r\n\r\n        function clearPrior() {\r\n            // return the reporter\r\n            var oldReporter = find('');\r\n\r\n            if(oldReporter) {\r\n                getContainer().removeChild(oldReporter);\r\n            }\r\n        }\r\n\r\n        function createDom(type, attrs, childrenVarArgs) {\r\n            var el = createElement(type);\r\n\r\n            for (var i = 2; i < arguments.length; i++) {\r\n                var child = arguments[i];\r\n\r\n                if (typeof child === 'string') {\r\n                    el.appendChild(createTextNode(child));\r\n                } else {\r\n                    if (child) {\r\n                        el.appendChild(child);\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (var attr in attrs) {\r\n                if (attr == 'className') {\r\n                    el[attr] = attrs[attr];\r\n                } else {\r\n                    el.setAttribute(attr, attrs[attr]);\r\n                }\r\n            }\r\n\r\n            return el;\r\n        }\r\n\r\n        function pluralize(singular, count) {\r\n            var word = (count == 1 ? singular : singular + 's');\r\n\r\n            return '' + count + ' ' + word;\r\n        }\r\n\r\n        function specHref(result) {\r\n            return addToExistingQueryString('spec', result.fullName);\r\n        }\r\n\r\n        function defaultQueryString(key, value) {\r\n            return '?' + key + '=' + value;\r\n        }\r\n\r\n        function setMenuModeTo(mode) {\r\n            htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);\r\n        }\r\n\r\n        function noExpectations(result) {\r\n            return (result.failedExpectations.length + result.passedExpectations.length) === 0 &&\r\n                result.status === 'passed';\r\n        }\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.HtmlReporter.[constructor].[function].[arg0]","key":"onRandomClick","newType":null,"isAny":true,"isClass":false,"containerType":"// Seen as: options\ninterface interface_694 {\n    addToExistingQueryString: any;\n    createElement: (arg0: void) => void;\n    createTextNode: (arg0: void) => void;\n    env: any;\n    getContainer: () => void;\n    onRaiseExceptionsClick: any;\n    onRandomClick: any;\n    onThrowExpectationsClick: any;\n    timer: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.HtmlReporter.[constructor].[function].[arg0]","newFunction":"function HtmlReporter(options) {\r\n        var env = options.env || {},\r\n            getContainer = options.getContainer,\r\n            createElement = options.createElement,\r\n            createTextNode = options.createTextNode,\r\n            onRaiseExceptionsClick = options.onRaiseExceptionsClick || function() {},\r\n            onThrowExpectationsClick = options.onThrowExpectationsClick || function() {},\r\n            onRandomClick = options.onRandomClick || function() {},\r\n            addToExistingQueryString = options.addToExistingQueryString || defaultQueryString,\r\n            timer = options.timer || noopTimer,\r\n            results = [],\r\n            specsExecuted = 0,\r\n            failureCount = 0,\r\n            pendingSpecCount = 0,\r\n            htmlReporterMain,\r\n            symbols,\r\n            failedSuites = [];\r\n\r\n        this.initialize = function() {\r\n            clearPrior();\r\n            htmlReporterMain = createDom('div', {className: 'jasmine_html-reporter'},\r\n                createDom('div', {className: 'jasmine-banner'},\r\n                    createDom('a', {className: 'jasmine-title', href: 'http://jasmine.github.io/', target: '_blank'}),\r\n                    createDom('span', {className: 'jasmine-version'}, j$.version)\r\n                ),\r\n                createDom('ul', {className: 'jasmine-symbol-summary'}),\r\n                createDom('div', {className: 'jasmine-alert'}),\r\n                createDom('div', {className: 'jasmine-results'},\r\n                    createDom('div', {className: 'jasmine-failures'})\r\n                )\r\n            );\r\n            getContainer().appendChild(htmlReporterMain);\r\n        };\r\n\r\n        var totalSpecsDefined;\r\n        this.jasmineStarted = function(options) {\r\n            totalSpecsDefined = options.totalSpecsDefined || 0;\r\n            timer.start();\r\n        };\r\n\r\n        var summary = createDom('div', {className: 'jasmine-summary'});\r\n\r\n        var topResults = new j$.ResultsNode({}, '', null),\r\n            currentParent = topResults;\r\n\r\n        this.suiteStarted = function(result) {\r\n            currentParent.addChild(result, 'suite');\r\n            currentParent = currentParent.last();\r\n        };\r\n\r\n        this.suiteDone = function(result) {\r\n            if (result.status == 'failed') {\r\n                failedSuites.push(result);\r\n            }\r\n\r\n            if (currentParent == topResults) {\r\n                return;\r\n            }\r\n\r\n            currentParent = currentParent.parent;\r\n        };\r\n\r\n        this.specStarted = function(result) {\r\n            currentParent.addChild(result, 'spec');\r\n        };\r\n\r\n        var failures = [];\r\n        this.specDone = function(result) {\r\n            if(noExpectations(result) && typeof console !== 'undefined' && typeof console.error !== 'undefined') {\r\n                console.error('Spec \\'' + result.fullName + '\\' has no expectations.');\r\n            }\r\n\r\n            if (result.status != 'disabled') {\r\n                specsExecuted++;\r\n            }\r\n\r\n            if (!symbols){\r\n                symbols = find('.jasmine-symbol-summary');\r\n            }\r\n\r\n            symbols.appendChild(createDom('li', {\r\n                    className: noExpectations(result) ? 'jasmine-empty' : 'jasmine-' + result.status,\r\n                    id: 'spec_' + result.id,\r\n                    title: result.fullName\r\n                }\r\n            ));\r\n\r\n            if (result.status == 'failed') {\r\n                failureCount++;\r\n\r\n                var failure =\r\n                    createDom('div', {className: 'jasmine-spec-detail jasmine-failed'},\r\n                        createDom('div', {className: 'jasmine-description'},\r\n                            createDom('a', {title: result.fullName, href: specHref(result)}, result.fullName)\r\n                        ),\r\n                        createDom('div', {className: 'jasmine-messages'})\r\n                    );\r\n                var messages = failure.childNodes[1];\r\n\r\n                for (var i = 0; i < result.failedExpectations.length; i++) {\r\n                    var expectation = result.failedExpectations[i];\r\n                    messages.appendChild(createDom('div', {className: 'jasmine-result-message'}, expectation.message));\r\n                    messages.appendChild(createDom('div', {className: 'jasmine-stack-trace'}, expectation.stack));\r\n                }\r\n\r\n                failures.push(failure);\r\n            }\r\n\r\n            if (result.status == 'pending') {\r\n                pendingSpecCount++;\r\n            }\r\n        };\r\n\r\n        this.jasmineDone = function(doneResult) {\r\n            var banner = find('.jasmine-banner');\r\n            var alert = find('.jasmine-alert');\r\n            var order = doneResult && doneResult.order;\r\n            alert.appendChild(createDom('span', {className: 'jasmine-duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));\r\n\r\n            banner.appendChild(\r\n                createDom('div', { className: 'jasmine-run-options' },\r\n                    createDom('span', { className: 'jasmine-trigger' }, 'Options'),\r\n                    createDom('div', { className: 'jasmine-payload' },\r\n                        createDom('div', { className: 'jasmine-exceptions' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-raise',\r\n                                id: 'jasmine-raise-exceptions',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-raise-exceptions' }, 'raise exceptions')),\r\n                        createDom('div', { className: 'jasmine-throw-failures' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-throw',\r\n                                id: 'jasmine-throw-failures',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-throw-failures' }, 'stop spec on expectation failure')),\r\n                        createDom('div', { className: 'jasmine-random-order' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-random',\r\n                                id: 'jasmine-random-order',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-random-order' }, 'run tests in random order'))\r\n                    )\r\n                ));\r\n\r\n            var raiseCheckbox = find('#jasmine-raise-exceptions');\r\n\r\n            raiseCheckbox.checked = !env.catchingExceptions();\r\n            raiseCheckbox.onclick = onRaiseExceptionsClick;\r\n\r\n            var throwCheckbox = find('#jasmine-throw-failures');\r\n            throwCheckbox.checked = env.throwingExpectationFailures();\r\n            throwCheckbox.onclick = onThrowExpectationsClick;\r\n\r\n            var randomCheckbox = find('#jasmine-random-order');\r\n            randomCheckbox.checked = env.randomTests();\r\n            randomCheckbox.onclick = onRandomClick;\r\n\r\n            var optionsMenu = find('.jasmine-run-options'),\r\n                optionsTrigger = optionsMenu.querySelector('.jasmine-trigger'),\r\n                optionsPayload = optionsMenu.querySelector('.jasmine-payload'),\r\n                isOpen = /\\bjasmine-open\\b/;\r\n\r\n            optionsTrigger.onclick = function() {\r\n                if (isOpen.test(optionsPayload.className)) {\r\n                    optionsPayload.className = optionsPayload.className.replace(isOpen, '');\r\n                } else {\r\n                    optionsPayload.className += ' jasmine-open';\r\n                }\r\n            };\r\n\r\n            if (specsExecuted < totalSpecsDefined) {\r\n                var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';\r\n                var skippedLink = order && order.random ? '?random=true' : '?';\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-bar jasmine-skipped'},\r\n                        createDom('a', {href: skippedLink, title: 'Run all specs'}, skippedMessage)\r\n                    )\r\n                );\r\n            }\r\n            var statusBarMessage = '';\r\n            var statusBarClassName = 'jasmine-bar ';\r\n\r\n            if (totalSpecsDefined > 0) {\r\n                statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);\r\n                if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }\r\n                statusBarClassName += (failureCount > 0) ? 'jasmine-failed' : 'jasmine-passed';\r\n            } else {\r\n                statusBarClassName += 'jasmine-skipped';\r\n                statusBarMessage += 'No specs found';\r\n            }\r\n\r\n            var seedBar;\r\n            if (order && order.random) {\r\n                seedBar = createDom('span', {className: 'jasmine-seed-bar'},\r\n                    ', randomized with seed ',\r\n                    createDom('a', {title: 'randomized with seed ' + order.seed, href: seedHref(order.seed)}, order.seed)\r\n                );\r\n            }\r\n\r\n            alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage, seedBar));\r\n\r\n            var errorBarClassName = 'jasmine-bar jasmine-errored';\r\n            var errorBarMessagePrefix = 'AfterAll ';\r\n\r\n            for(var i = 0; i < failedSuites.length; i++) {\r\n                var failedSuite = failedSuites[i];\r\n                for(var j = 0; j < failedSuite.failedExpectations.length; j++) {\r\n                    alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessagePrefix + failedSuite.failedExpectations[j].message));\r\n                }\r\n            }\r\n\r\n            var globalFailures = (doneResult && doneResult.failedExpectations) || [];\r\n            for(i = 0; i < globalFailures.length; i++) {\r\n                var failure = globalFailures[i];\r\n                alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessagePrefix + failure.message));\r\n            }\r\n\r\n            var results = find('.jasmine-results');\r\n            results.appendChild(summary);\r\n\r\n            summaryList(topResults, summary);\r\n\r\n            function summaryList(resultsTree, domParent) {\r\n                var specListNode;\r\n                for (var i = 0; i < resultsTree.children.length; i++) {\r\n                    var resultNode = resultsTree.children[i];\r\n                    if (resultNode.type == 'suite') {\r\n                        var suiteListNode = createDom('ul', {className: 'jasmine-suite', id: 'suite-' + resultNode.result.id},\r\n                            createDom('li', {className: 'jasmine-suite-detail'},\r\n                                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)\r\n                            )\r\n                        );\r\n\r\n                        summaryList(resultNode, suiteListNode);\r\n                        domParent.appendChild(suiteListNode);\r\n                    }\r\n                    if (resultNode.type == 'spec') {\r\n                        if (domParent.getAttribute('class') != 'jasmine-specs') {\r\n                            specListNode = createDom('ul', {className: 'jasmine-specs'});\r\n                            domParent.appendChild(specListNode);\r\n                        }\r\n                        var specDescription = resultNode.result.description;\r\n                        if(noExpectations(resultNode.result)) {\r\n                            specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;\r\n                        }\r\n                        if(resultNode.result.status === 'pending' && resultNode.result.pendingReason !== '') {\r\n                            specDescription = specDescription + ' PENDING WITH MESSAGE: ' + resultNode.result.pendingReason;\r\n                        }\r\n                        specListNode.appendChild(\r\n                            createDom('li', {\r\n                                    className: 'jasmine-' + resultNode.result.status,\r\n                                    id: 'spec-' + resultNode.result.id\r\n                                },\r\n                                createDom('a', {href: specHref(resultNode.result)}, specDescription)\r\n                            )\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (failures.length) {\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-spec-list'},\r\n                        createDom('span', {}, 'Spec List | '),\r\n                        createDom('a', {className: 'jasmine-failures-menu', href: '#'}, 'Failures')));\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-failure-list'},\r\n                        createDom('a', {className: 'jasmine-spec-list-menu', href: '#'}, 'Spec List'),\r\n                        createDom('span', {}, ' | Failures ')));\r\n\r\n                find('.jasmine-failures-menu').onclick = function() {\r\n                    setMenuModeTo('jasmine-failure-list');\r\n                };\r\n                find('.jasmine-spec-list-menu').onclick = function() {\r\n                    setMenuModeTo('jasmine-spec-list');\r\n                };\r\n\r\n                setMenuModeTo('jasmine-failure-list');\r\n\r\n                var failureNode = find('.jasmine-failures');\r\n                for (i = 0; i < failures.length; i++) {\r\n                    failureNode.appendChild(failures[i]);\r\n                }\r\n            }\r\n        };\r\n\r\n        return this;\r\n\r\n        function find(selector) {\r\n            return getContainer().querySelector('.jasmine_html-reporter ' + selector);\r\n        }\r\n\r\n        function clearPrior() {\r\n            // return the reporter\r\n            var oldReporter = find('');\r\n\r\n            if(oldReporter) {\r\n                getContainer().removeChild(oldReporter);\r\n            }\r\n        }\r\n\r\n        function createDom(type, attrs, childrenVarArgs) {\r\n            var el = createElement(type);\r\n\r\n            for (var i = 2; i < arguments.length; i++) {\r\n                var child = arguments[i];\r\n\r\n                if (typeof child === 'string') {\r\n                    el.appendChild(createTextNode(child));\r\n                } else {\r\n                    if (child) {\r\n                        el.appendChild(child);\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (var attr in attrs) {\r\n                if (attr == 'className') {\r\n                    el[attr] = attrs[attr];\r\n                } else {\r\n                    el.setAttribute(attr, attrs[attr]);\r\n                }\r\n            }\r\n\r\n            return el;\r\n        }\r\n\r\n        function pluralize(singular, count) {\r\n            var word = (count == 1 ? singular : singular + 's');\r\n\r\n            return '' + count + ' ' + word;\r\n        }\r\n\r\n        function specHref(result) {\r\n            return addToExistingQueryString('spec', result.fullName);\r\n        }\r\n\r\n        function seedHref(seed) {\r\n            return addToExistingQueryString('seed', seed);\r\n        }\r\n\r\n        function defaultQueryString(key, value) {\r\n            return '?' + key + '=' + value;\r\n        }\r\n\r\n        function setMenuModeTo(mode) {\r\n            htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);\r\n        }\r\n\r\n        function noExpectations(result) {\r\n            return (result.failedExpectations.length + result.passedExpectations.length) === 0 &&\r\n                result.status === 'passed';\r\n        }\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.HtmlReporter.[constructor].[function].[arg0]","oldFunction":"function HtmlReporter(options) {\r\n        var env = options.env || {},\r\n            getContainer = options.getContainer,\r\n            createElement = options.createElement,\r\n            createTextNode = options.createTextNode,\r\n            onRaiseExceptionsClick = options.onRaiseExceptionsClick || function() {},\r\n            addToExistingQueryString = options.addToExistingQueryString || defaultQueryString,\r\n            timer = options.timer || noopTimer,\r\n            results = [],\r\n            specsExecuted = 0,\r\n            failureCount = 0,\r\n            pendingSpecCount = 0,\r\n            htmlReporterMain,\r\n            symbols,\r\n            failedSuites = [];\r\n\r\n        this.initialize = function() {\r\n            clearPrior();\r\n            htmlReporterMain = createDom('div', {className: 'jasmine_html-reporter'},\r\n                createDom('div', {className: 'banner'},\r\n                    createDom('a', {className: 'title', href: 'http://jasmine.github.io/', target: '_blank'}),\r\n                    createDom('span', {className: 'version'}, j$.version)\r\n                ),\r\n                createDom('ul', {className: 'symbol-summary'}),\r\n                createDom('div', {className: 'alert'}),\r\n                createDom('div', {className: 'results'},\r\n                    createDom('div', {className: 'failures'})\r\n                )\r\n            );\r\n            getContainer().appendChild(htmlReporterMain);\r\n\r\n            symbols = find('.symbol-summary');\r\n        };\r\n\r\n        var totalSpecsDefined;\r\n        this.jasmineStarted = function(options) {\r\n            totalSpecsDefined = options.totalSpecsDefined || 0;\r\n            timer.start();\r\n        };\r\n\r\n        var summary = createDom('div', {className: 'summary'});\r\n\r\n        var topResults = new j$.ResultsNode({}, '', null),\r\n            currentParent = topResults;\r\n\r\n        this.suiteStarted = function(result) {\r\n            currentParent.addChild(result, 'suite');\r\n            currentParent = currentParent.last();\r\n        };\r\n\r\n        this.suiteDone = function(result) {\r\n            if (result.status == 'failed') {\r\n                failedSuites.push(result);\r\n            }\r\n\r\n            if (currentParent == topResults) {\r\n                return;\r\n            }\r\n\r\n            currentParent = currentParent.parent;\r\n        };\r\n\r\n        this.specStarted = function(result) {\r\n            currentParent.addChild(result, 'spec');\r\n        };\r\n\r\n        var failures = [];\r\n        this.specDone = function(result) {\r\n            if(noExpectations(result) && typeof console !== 'undefined' && typeof console.error !== 'undefined') {\r\n                console.error('Spec \\'' + result.fullName + '\\' has no expectations.');\r\n            }\r\n\r\n            if (result.status != 'disabled') {\r\n                specsExecuted++;\r\n            }\r\n\r\n            symbols.appendChild(createDom('li', {\r\n                    className: noExpectations(result) ? 'empty' : result.status,\r\n                    id: 'spec_' + result.id,\r\n                    title: result.fullName\r\n                }\r\n            ));\r\n\r\n            if (result.status == 'failed') {\r\n                failureCount++;\r\n\r\n                var failure =\r\n                    createDom('div', {className: 'spec-detail failed'},\r\n                        createDom('div', {className: 'description'},\r\n                            createDom('a', {title: result.fullName, href: specHref(result)}, result.fullName)\r\n                        ),\r\n                        createDom('div', {className: 'messages'})\r\n                    );\r\n                var messages = failure.childNodes[1];\r\n\r\n                for (var i = 0; i < result.failedExpectations.length; i++) {\r\n                    var expectation = result.failedExpectations[i];\r\n                    messages.appendChild(createDom('div', {className: 'result-message'}, expectation.message));\r\n                    messages.appendChild(createDom('div', {className: 'stack-trace'}, expectation.stack));\r\n                }\r\n\r\n                failures.push(failure);\r\n            }\r\n\r\n            if (result.status == 'pending') {\r\n                pendingSpecCount++;\r\n            }\r\n        };\r\n\r\n        this.jasmineDone = function() {\r\n            var banner = find('.banner');\r\n            banner.appendChild(createDom('span', {className: 'duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));\r\n\r\n            var alert = find('.alert');\r\n\r\n            alert.appendChild(createDom('span', { className: 'exceptions' },\r\n                createDom('label', { className: 'label', 'for': 'raise-exceptions' }, 'raise exceptions'),\r\n                createDom('input', {\r\n                    className: 'raise',\r\n                    id: 'raise-exceptions',\r\n                    type: 'checkbox'\r\n                })\r\n            ));\r\n            var checkbox = find('#raise-exceptions');\r\n\r\n            checkbox.checked = !env.catchingExceptions();\r\n            checkbox.onclick = onRaiseExceptionsClick;\r\n\r\n            if (specsExecuted < totalSpecsDefined) {\r\n                var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'bar skipped'},\r\n                        createDom('a', {href: '?', title: 'Run all specs'}, skippedMessage)\r\n                    )\r\n                );\r\n            }\r\n            var statusBarMessage = '';\r\n            var statusBarClassName = 'bar ';\r\n\r\n            if (totalSpecsDefined > 0) {\r\n                statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);\r\n                if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }\r\n                statusBarClassName += (failureCount > 0) ? 'failed' : 'passed';\r\n            } else {\r\n                statusBarClassName += 'skipped';\r\n                statusBarMessage += 'No specs found';\r\n            }\r\n\r\n            alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage));\r\n\r\n            for(i = 0; i < failedSuites.length; i++) {\r\n                var failedSuite = failedSuites[i];\r\n                for(var j = 0; j < failedSuite.failedExpectations.length; j++) {\r\n                    var errorBarMessage = 'AfterAll ' + failedSuite.failedExpectations[j].message;\r\n                    var errorBarClassName = 'bar errored';\r\n                    alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessage));\r\n                }\r\n            }\r\n\r\n            var results = find('.results');\r\n            results.appendChild(summary);\r\n\r\n            summaryList(topResults, summary);\r\n\r\n            function summaryList(resultsTree, domParent) {\r\n                var specListNode;\r\n                for (var i = 0; i < resultsTree.children.length; i++) {\r\n                    var resultNode = resultsTree.children[i];\r\n                    if (resultNode.type == 'suite') {\r\n                        var suiteListNode = createDom('ul', {className: 'suite', id: 'suite-' + resultNode.result.id},\r\n                            createDom('li', {className: 'suite-detail'},\r\n                                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)\r\n                            )\r\n                        );\r\n\r\n                        summaryList(resultNode, suiteListNode);\r\n                        domParent.appendChild(suiteListNode);\r\n                    }\r\n                    if (resultNode.type == 'spec') {\r\n                        if (domParent.getAttribute('class') != 'specs') {\r\n                            specListNode = createDom('ul', {className: 'specs'});\r\n                            domParent.appendChild(specListNode);\r\n                        }\r\n                        var specDescription = resultNode.result.description;\r\n                        if(noExpectations(resultNode.result)) {\r\n                            specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;\r\n                        }\r\n                        if(resultNode.result.status === 'pending' && resultNode.result.pendingReason !== '') {\r\n                            specDescription = specDescription + ' PENDING WITH MESSAGE: ' + resultNode.result.pendingReason;\r\n                        }\r\n                        specListNode.appendChild(\r\n                            createDom('li', {\r\n                                    className: resultNode.result.status,\r\n                                    id: 'spec-' + resultNode.result.id\r\n                                },\r\n                                createDom('a', {href: specHref(resultNode.result)}, specDescription)\r\n                            )\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (failures.length) {\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'menu bar spec-list'},\r\n                        createDom('span', {}, 'Spec List | '),\r\n                        createDom('a', {className: 'failures-menu', href: '#'}, 'Failures')));\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'menu bar failure-list'},\r\n                        createDom('a', {className: 'spec-list-menu', href: '#'}, 'Spec List'),\r\n                        createDom('span', {}, ' | Failures ')));\r\n\r\n                find('.failures-menu').onclick = function() {\r\n                    setMenuModeTo('failure-list');\r\n                };\r\n                find('.spec-list-menu').onclick = function() {\r\n                    setMenuModeTo('spec-list');\r\n                };\r\n\r\n                setMenuModeTo('failure-list');\r\n\r\n                var failureNode = find('.failures');\r\n                for (var i = 0; i < failures.length; i++) {\r\n                    failureNode.appendChild(failures[i]);\r\n                }\r\n            }\r\n        };\r\n\r\n        return this;\r\n\r\n        function find(selector) {\r\n            return getContainer().querySelector('.jasmine_html-reporter ' + selector);\r\n        }\r\n\r\n        function clearPrior() {\r\n            // return the reporter\r\n            var oldReporter = find('');\r\n\r\n            if(oldReporter) {\r\n                getContainer().removeChild(oldReporter);\r\n            }\r\n        }\r\n\r\n        function createDom(type, attrs, childrenVarArgs) {\r\n            var el = createElement(type);\r\n\r\n            for (var i = 2; i < arguments.length; i++) {\r\n                var child = arguments[i];\r\n\r\n                if (typeof child === 'string') {\r\n                    el.appendChild(createTextNode(child));\r\n                } else {\r\n                    if (child) {\r\n                        el.appendChild(child);\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (var attr in attrs) {\r\n                if (attr == 'className') {\r\n                    el[attr] = attrs[attr];\r\n                } else {\r\n                    el.setAttribute(attr, attrs[attr]);\r\n                }\r\n            }\r\n\r\n            return el;\r\n        }\r\n\r\n        function pluralize(singular, count) {\r\n            var word = (count == 1 ? singular : singular + 's');\r\n\r\n            return '' + count + ' ' + word;\r\n        }\r\n\r\n        function specHref(result) {\r\n            return addToExistingQueryString('spec', result.fullName);\r\n        }\r\n\r\n        function defaultQueryString(key, value) {\r\n            return '?' + key + '=' + value;\r\n        }\r\n\r\n        function setMenuModeTo(mode) {\r\n            htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);\r\n        }\r\n\r\n        function noExpectations(result) {\r\n            return (result.failedExpectations.length + result.passedExpectations.length) === 0 &&\r\n                result.status === 'passed';\r\n        }\r\n    }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.HtmlReporter.[constructor].[function].[arg0]","key":"onThrowExpectationsClick","newType":null,"isAny":true,"isClass":false,"containerType":"// Seen as: options\ninterface interface_694 {\n    addToExistingQueryString: any;\n    createElement: (arg0: void) => void;\n    createTextNode: (arg0: void) => void;\n    env: any;\n    getContainer: () => void;\n    onRaiseExceptionsClick: any;\n    onRandomClick: any;\n    onThrowExpectationsClick: any;\n    timer: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor].[function].[arg0]","newFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor].[function].[arg0]","oldFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.Suite.[constructor].[function].[arg0].parentSuite","newType":"jasmine.Suite | interface_728","oldType":"jasmine.Suite","containerType":"// Seen as: attrs\ninterface interface_731 {\n    description: string;\n    env: jasmine.Env;\n    expectationFactory: (actual: any, spec: jasmine.Suite) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationResultFactory: (attrs: interface_707) => interface_709;\n    id: string;\n    parentSuite: jasmine.Suite | interface_728;\n    throwOnExpectationFailure: boolean;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.matchersUtil.contains.[function]","newFunction":"function(haystack, needle, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||\r\n                (!!haystack && !haystack.indexOf))\r\n            {\r\n                for (var i = 0; i < haystack.length; i++) {\r\n                    if (eq(haystack[i], needle, [], [], customTesters)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n\r\n            return !!haystack && haystack.indexOf(needle) >= 0;\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.matchersUtil.contains.[function]","oldFunction":"function(haystack, needle, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||\r\n                (!!haystack && !haystack.indexOf))\r\n            {\r\n                for (var i = 0; i < haystack.length; i++) {\r\n                    if (eq(haystack[i], needle, [], [], customTesters)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n\r\n            return !!haystack && haystack.indexOf(needle) >= 0;\r\n        }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.matchersUtil.contains.[function].[arg0].[indexer]","newType":"string | interface_401","oldType":"string | interface_858","containerType":"// Seen as: haystack\ninterface interface_398 {\n    [index: number]: string | interface_401;\n    indexOf: (arg0: void) => void;\n    length: number;\n}\n\n","containerDescription":"interface"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.QueueRunner.[constructor].[function].[arg0]","newFunction":"function QueueRunner(attrs) {\r\n        this.queueableFns = attrs.queueableFns || [];\r\n        this.onComplete = attrs.onComplete || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.onException = attrs.onException || function() {};\r\n        this.catchException = attrs.catchException || function() { return true; };\r\n        this.userContext = attrs.userContext || {};\r\n        this.timeout = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};\r\n        this.fail = attrs.fail || function() {};\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.QueueRunner.[constructor].[function].[arg0]","oldFunction":"function QueueRunner(attrs) {\r\n        this.queueableFns = attrs.queueableFns || [];\r\n        this.onComplete = attrs.onComplete || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.onException = attrs.onException || function() {};\r\n        this.catchException = attrs.catchException || function() { return true; };\r\n        this.userContext = attrs.userContext || {};\r\n        this.timer = attrs.timeout || {setTimeout: setTimeout, clearTimeout: clearTimeout};\r\n        this.fail = attrs.fail || function() {};\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.QueueRunner.[constructor].[function].[arg0].timeout","newType":"interface interface_702 {\n    clearTimeout: (handle: number) => void;\n    setTimeout: (handler: any, timeout: any, args: any) => number;\n}\n\n","oldType":"any","containerType":"// Seen as: attrs, options\ninterface interface_704 {\n    catchException: (e: {toString: () => void}) => boolean;\n    clearStack: (fn: () => void) => void;\n    fail: (error: {message: any}) => void;\n    onComplete: any;\n    onException: any;\n    queueableFns: any;\n    timeout: interface_702;\n    userContext: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Env.[constructor].[return].describe.[function]","newFunction":"function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            if (specDefinitions.length > 0) {\r\n                throw new Error('describe does not expect any arguments');\r\n            }\r\n            if (currentDeclarationSuite.markedPending) {\r\n                suite.pend();\r\n            }\r\n            addSpecsToSuite(suite, specDefinitions);\r\n            return suite;\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Env.[constructor].[return].describe.[function]","oldFunction":"function(description, specDefinitions) {\r\n            var suite = suiteFactory(description);\r\n            addSpecsToSuite(suite, specDefinitions);\r\n            return suite;\r\n        }","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmine.Env.[constructor].[return].describe.[function].[arg1]","key":"length","newType":"number","isAny":false,"isClass":false,"containerType":"{\n    call: (arg0: void) => void, \n    length: number\n}\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.SpyStrategy.[constructor].[return]","newFunction":"function SpyStrategy(options) {\r\n        options = options || {};\r\n\r\n        var identity = options.name || 'unknown',\r\n            originalFn = options.fn || function() {},\r\n            getSpy = options.getSpy || function() {},\r\n            plan = function() {};\r\n\r\n        this.identity = function() {\r\n            return identity;\r\n        };\r\n\r\n        this.exec = function() {\r\n            return plan.apply(this, arguments);\r\n        };\r\n\r\n        this.callThrough = function() {\r\n            plan = originalFn;\r\n            return getSpy();\r\n        };\r\n\r\n        this.returnValue = function(value) {\r\n            plan = function() {\r\n                return value;\r\n            };\r\n            return getSpy();\r\n        };\r\n\r\n        this.returnValues = function() {\r\n            var values = Array.prototype.slice.call(arguments);\r\n            plan = function () {\r\n                return values.shift();\r\n            };\r\n            return getSpy();\r\n        };\r\n\r\n        this.throwError = function(something) {\r\n            var error = (something instanceof Error) ? something : new Error(something);\r\n            plan = function() {\r\n                throw error;\r\n            };\r\n            return getSpy();\r\n        };\r\n\r\n        this.callFake = function(fn) {\r\n            if(!(fn instanceof Function)) {\r\n                throw new Error('Argument passed to callFake should be a function, got ' + fn);\r\n            }\r\n            plan = fn;\r\n            return getSpy();\r\n        };\r\n\r\n        this.stub = function(fn) {\r\n            plan = function() {};\r\n            return getSpy();\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.SpyStrategy.[constructor].[return]","oldFunction":"function SpyStrategy(options) {\r\n        options = options || {};\r\n\r\n        var identity = options.name || 'unknown',\r\n            originalFn = options.fn || function() {},\r\n            getSpy = options.getSpy || function() {},\r\n            plan = function() {};\r\n\r\n        this.identity = function() {\r\n            return identity;\r\n        };\r\n\r\n        this.exec = function() {\r\n            return plan.apply(this, arguments);\r\n        };\r\n\r\n        this.callThrough = function() {\r\n            plan = originalFn;\r\n            return getSpy();\r\n        };\r\n\r\n        this.returnValue = function(value) {\r\n            plan = function() {\r\n                return value;\r\n            };\r\n            return getSpy();\r\n        };\r\n\r\n        this.returnValues = function() {\r\n            var values = Array.prototype.slice.call(arguments);\r\n            plan = function () {\r\n                return values.shift();\r\n            };\r\n            return getSpy();\r\n        };\r\n\r\n        this.throwError = function(something) {\r\n            var error = (something instanceof Error) ? something : new Error(something);\r\n            plan = function() {\r\n                throw error;\r\n            };\r\n            return getSpy();\r\n        };\r\n\r\n        this.callFake = function(fn) {\r\n            plan = fn;\r\n            return getSpy();\r\n        };\r\n\r\n        this.stub = function(fn) {\r\n            plan = function() {};\r\n            return getSpy();\r\n        };\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.SpyStrategy.[constructor].[return].callFake.[function].[arg0]","newType":"string | number | ((arg0: void, arg1: void, arg2: void, arg3: void, arg4: void) => any)","oldType":"(arg0: void, arg1: void, arg2: void, arg3: void, arg4: void) => any","containerType":"(originalFn: string | number | ((arg0: void, arg1: void, arg2: void, arg3: void, arg4: void) => any)) => any","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor].[return].expect.[function]","newFunction":"function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor].[return].expect.[function]","oldFunction":"function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.Suite.[constructor].[return].expect.[function].[return]","newType":"jasmine.Expectation | {not: jasmine.Expectation}","oldType":"any","containerType":"(actual: any) => jasmine.Expectation | {not: jasmine.Expectation}","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.SpyRegistry.[constructor].[return].spyOn.[function]","newFunction":"function(obj, methodName) {\r\n\r\n            if (j$.util.isUndefined(obj)) {\r\n                throw new Error(getErrorMsg('could not find an object to spy upon for ' + methodName + '()'));\r\n            }\r\n\r\n            if (j$.util.isUndefined(methodName)) {\r\n                throw new Error(getErrorMsg('No method name supplied'));\r\n            }\r\n\r\n            if (j$.util.isUndefined(obj[methodName])) {\r\n                throw new Error(getErrorMsg(methodName + '() method does not exist'));\r\n            }\r\n\r\n            if (obj[methodName] && j$.isSpy(obj[methodName])  ) {\r\n                if ( !!this.respy ){\r\n                    return obj[methodName];\r\n                }else {\r\n                    throw new Error(getErrorMsg(methodName + ' has already been spied upon'));\r\n                }\r\n            }\r\n\r\n            var descriptor;\r\n            try {\r\n                descriptor = Object.getOwnPropertyDescriptor(obj, methodName);\r\n            } catch(e) {\r\n                // IE 8 doesn't support `definePropery` on non-DOM nodes\r\n            }\r\n\r\n            if (descriptor && !(descriptor.writable || descriptor.set)) {\r\n                throw new Error(getErrorMsg(methodName + ' is not declared writable or has no setter'));\r\n            }\r\n\r\n            var originalMethod = obj[methodName],\r\n                spiedMethod = j$.createSpy(methodName, originalMethod),\r\n                restoreStrategy;\r\n\r\n            if (Object.prototype.hasOwnProperty.call(obj, methodName)) {\r\n                restoreStrategy = function() {\r\n                    obj[methodName] = originalMethod;\r\n                };\r\n            } else {\r\n                restoreStrategy = function() {\r\n                    delete obj[methodName];\r\n                };\r\n            }\r\n\r\n            currentSpies().push({\r\n                restoreObjectToOriginalState: restoreStrategy\r\n            });\r\n\r\n            obj[methodName] = spiedMethod;\r\n\r\n            return spiedMethod;\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.SpyRegistry.[constructor].[return].spyOn.[function]","oldFunction":"function(obj, methodName) {\r\n            if (j$.util.isUndefined(obj)) {\r\n                throw new Error('spyOn could not find an object to spy upon for ' + methodName + '()');\r\n            }\r\n\r\n            if (j$.util.isUndefined(methodName)) {\r\n                throw new Error('No method name supplied');\r\n            }\r\n\r\n            if (j$.util.isUndefined(obj[methodName])) {\r\n                throw new Error(methodName + '() method does not exist');\r\n            }\r\n\r\n            if (obj[methodName] && j$.isSpy(obj[methodName])) {\r\n                //TODO?: should this return the current spy? Downside: may cause user confusion about spy state\r\n                throw new Error(methodName + ' has already been spied upon');\r\n            }\r\n\r\n            var spy = j$.createSpy(methodName, obj[methodName]);\r\n\r\n            currentSpies().push({\r\n                spy: spy,\r\n                baseObj: obj,\r\n                methodName: methodName,\r\n                originalValue: obj[methodName]\r\n            });\r\n\r\n            obj[methodName] = spy;\r\n\r\n            return spy;\r\n        }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.SpyRegistry.[constructor].[return].spyOn.[function].[arg1]","newType":"string","oldType":"string | number","containerType":"(obj: interface_628, methodName: string) => interface_490","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Env.[constructor].[return].fit.[function]","newFunction":"function(description, fn, timeout){\r\n            var spec = specFactory(description, fn, currentDeclarationSuite, timeout);\r\n            currentDeclarationSuite.addChild(spec);\r\n            focusedRunnables.push(spec.id);\r\n            unfocusAncestor();\r\n            return spec;\r\n        }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Env.[constructor].[return].fit.[function]","oldFunction":"function(){\r\n            var spec = this.it.apply(this, arguments);\r\n\r\n            focusedRunnables.push(spec.id);\r\n            unfocusAncestor();\r\n            return spec;\r\n        }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.Env.[constructor].[return].fit.[function].[return]","newType":"{disabled: boolean} | jasmine.Spec","oldType":"{\n    id: any\n}\n","containerType":"(description: any, fn: any, timeout: any) => {disabled: boolean} | jasmine.Spec","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.CallTracker.[constructor].[return]","newFunction":"function CallTracker() {\r\n        var calls = [];\r\n        var opts = {};\r\n\r\n        function argCloner(context) {\r\n            var clonedArgs = [];\r\n            var argsAsArray = j$.util.argsToArray(context.args);\r\n            for(var i = 0; i < argsAsArray.length; i++) {\r\n                if(Object.prototype.toString.apply(argsAsArray[i]).match(/^\\[object/)) {\r\n                    clonedArgs.push(j$.util.clone(argsAsArray[i]));\r\n                } else {\r\n                    clonedArgs.push(argsAsArray[i]);\r\n                }\r\n            }\r\n            context.args = clonedArgs;\r\n        }\r\n\r\n        this.track = function(context) {\r\n            if(opts.cloneArgs) {\r\n                argCloner(context);\r\n            }\r\n            calls.push(context);\r\n        };\r\n\r\n        this.any = function() {\r\n            return !!calls.length;\r\n        };\r\n\r\n        this.count = function() {\r\n            return calls.length;\r\n        };\r\n\r\n        this.argsFor = function(index) {\r\n            var call = calls[index];\r\n            return call ? call.args : [];\r\n        };\r\n\r\n        this.all = function() {\r\n            return calls;\r\n        };\r\n\r\n        this.allArgs = function() {\r\n            var callArgs = [];\r\n            for(var i = 0; i < calls.length; i++){\r\n                callArgs.push(calls[i].args);\r\n            }\r\n\r\n            return callArgs;\r\n        };\r\n\r\n        this.first = function() {\r\n            return calls[0];\r\n        };\r\n\r\n        this.mostRecent = function() {\r\n            return calls[calls.length - 1];\r\n        };\r\n\r\n        this.reset = function() {\r\n            calls = [];\r\n        };\r\n\r\n        this.saveArgumentsByValue = function() {\r\n            opts.cloneArgs = true;\r\n        };\r\n\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.CallTracker.[constructor].[return]","oldFunction":"function CallTracker() {\r\n        var calls = [];\r\n\r\n        this.track = function(context) {\r\n            calls.push(context);\r\n        };\r\n\r\n        this.any = function() {\r\n            return !!calls.length;\r\n        };\r\n\r\n        this.count = function() {\r\n            return calls.length;\r\n        };\r\n\r\n        this.argsFor = function(index) {\r\n            var call = calls[index];\r\n            return call ? call.args : [];\r\n        };\r\n\r\n        this.all = function() {\r\n            return calls;\r\n        };\r\n\r\n        this.allArgs = function() {\r\n            var callArgs = [];\r\n            for(var i = 0; i < calls.length; i++){\r\n                callArgs.push(calls[i].args);\r\n            }\r\n\r\n            return callArgs;\r\n        };\r\n\r\n        this.first = function() {\r\n            return calls[0];\r\n        };\r\n\r\n        this.mostRecent = function() {\r\n            return calls[calls.length - 1];\r\n        };\r\n\r\n        this.reset = function() {\r\n            calls = [];\r\n        };\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.CallTracker.[constructor].[return].track.[function].[arg0]","newType":"{\n    args: any[]\n}\n","oldType":"any","containerType":"(context: {args: any[]}) => void","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.Suite.[function].[return]","newFunction":"function(j$) {\r\n    function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }\r\n\r\n    Suite.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Suite.prototype.getFullName = function() {\r\n        var fullName = [];\r\n        for (var parentSuite = this; parentSuite; parentSuite = parentSuite.parentSuite) {\r\n            if (parentSuite.parentSuite) {\r\n                fullName.unshift(parentSuite.description);\r\n            }\r\n        }\r\n        return fullName.join(' ');\r\n    };\r\n\r\n    Suite.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Suite.prototype.pend = function(message) {\r\n        this.markedPending = true;\r\n    };\r\n\r\n    Suite.prototype.beforeEach = function(fn) {\r\n        this.beforeFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.beforeAll = function(fn) {\r\n        this.beforeAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.afterEach = function(fn) {\r\n        this.afterFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.afterAll = function(fn) {\r\n        this.afterAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.addChild = function(child) {\r\n        this.children.push(child);\r\n    };\r\n\r\n    Suite.prototype.status = function() {\r\n        if (this.disabled) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.markedPending) {\r\n            return 'pending';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'finished';\r\n        }\r\n    };\r\n\r\n    Suite.prototype.isExecutable = function() {\r\n        return !this.disabled;\r\n    };\r\n\r\n    Suite.prototype.canBeReentered = function() {\r\n        return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;\r\n    };\r\n\r\n    Suite.prototype.getResult = function() {\r\n        this.result.status = this.status();\r\n        return this.result;\r\n    };\r\n\r\n    Suite.prototype.sharedUserContext = function() {\r\n        if (!this.sharedContext) {\r\n            this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\r\n        }\r\n\r\n        return this.sharedContext;\r\n    };\r\n\r\n    Suite.prototype.clonedSharedUserContext = function() {\r\n        return clone(this.sharedUserContext());\r\n    };\r\n\r\n    Suite.prototype.onException = function() {\r\n        if (arguments[0] instanceof j$.errors.ExpectationFailed) {\r\n            return;\r\n        }\r\n\r\n        if(isAfterAll(this.children)) {\r\n            var data = {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                error: arguments[0]\r\n            };\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.onException.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    Suite.prototype.addExpectationResult = function () {\r\n        if(isAfterAll(this.children) && isFailure(arguments)){\r\n            var data = arguments[1];\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n            if(this.throwOnExpectationFailure) {\r\n                throw new j$.errors.ExpectationFailed();\r\n            }\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                try {\r\n                    child.addExpectationResult.apply(child, arguments);\r\n                } catch(e) {\r\n                    // keep going\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    function isAfterAll(children) {\r\n        return children && children[0].result.status;\r\n    }\r\n\r\n    function isFailure(args) {\r\n        return !args[0];\r\n    }\r\n\r\n    function clone(obj) {\r\n        var clonedObj = {};\r\n        for (var prop in obj) {\r\n            if (obj.hasOwnProperty(prop)) {\r\n                clonedObj[prop] = obj[prop];\r\n            }\r\n        }\r\n\r\n        return clonedObj;\r\n    }\r\n\r\n    return Suite;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.Suite.[function].[return]","oldFunction":"function() {\r\n    function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }\r\n\r\n    Suite.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Suite.prototype.getFullName = function() {\r\n        var fullName = this.description;\r\n        for (var parentSuite = this.parentSuite; parentSuite; parentSuite = parentSuite.parentSuite) {\r\n            if (parentSuite.parentSuite) {\r\n                fullName = parentSuite.description + ' ' + fullName;\r\n            }\r\n        }\r\n        return fullName;\r\n    };\r\n\r\n    Suite.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Suite.prototype.beforeEach = function(fn) {\r\n        this.beforeFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.beforeAll = function(fn) {\r\n        this.beforeAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.afterEach = function(fn) {\r\n        this.afterFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.afterAll = function(fn) {\r\n        this.afterAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.addChild = function(child) {\r\n        this.children.push(child);\r\n    };\r\n\r\n    Suite.prototype.status = function() {\r\n        if (this.disabled) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'finished';\r\n        }\r\n    };\r\n\r\n    Suite.prototype.execute = function(onComplete) {\r\n        var self = this;\r\n\r\n        this.onStart(this);\r\n\r\n        if (this.disabled) {\r\n            complete();\r\n            return;\r\n        }\r\n\r\n        var allFns = [];\r\n\r\n        for (var i = 0; i < this.children.length; i++) {\r\n            allFns.push(wrapChildAsAsync(this.children[i]));\r\n        }\r\n\r\n        if (this.isExecutable()) {\r\n            allFns = this.beforeAllFns.concat(allFns);\r\n            allFns = allFns.concat(this.afterAllFns);\r\n        }\r\n\r\n        this.queueRunner({\r\n            queueableFns: allFns,\r\n            onComplete: complete,\r\n            userContext: this.sharedUserContext(),\r\n            onException: function() { self.onException.apply(self, arguments); }\r\n        });\r\n\r\n        function complete() {\r\n            self.result.status = self.status();\r\n            self.resultCallback(self.result);\r\n\r\n            if (onComplete) {\r\n                onComplete();\r\n            }\r\n        }\r\n\r\n        function wrapChildAsAsync(child) {\r\n            return { fn: function(done) { child.execute(done); } };\r\n        }\r\n    };\r\n\r\n    Suite.prototype.isExecutable = function() {\r\n        var runnablesExplicitlySet = this.runnablesExplictlySetGetter();\r\n        return !runnablesExplicitlySet && hasExecutableChild(this.children);\r\n    };\r\n\r\n    Suite.prototype.sharedUserContext = function() {\r\n        if (!this.sharedContext) {\r\n            this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\r\n        }\r\n\r\n        return this.sharedContext;\r\n    };\r\n\r\n    Suite.prototype.clonedSharedUserContext = function() {\r\n        return clone(this.sharedUserContext());\r\n    };\r\n\r\n    Suite.prototype.onException = function() {\r\n        if(isAfterAll(this.children)) {\r\n            var data = {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                error: arguments[0]\r\n            };\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.onException.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    Suite.prototype.addExpectationResult = function () {\r\n        if(isAfterAll(this.children) && isFailure(arguments)){\r\n            var data = arguments[1];\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.addExpectationResult.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    function isAfterAll(children) {\r\n        return children && children[0].result.status;\r\n    }\r\n\r\n    function isFailure(args) {\r\n        return !args[0];\r\n    }\r\n\r\n    function hasExecutableChild(children) {\r\n        var foundActive = false;\r\n        for (var i = 0; i < children.length; i++) {\r\n            if (children[i].isExecutable()) {\r\n                foundActive = true;\r\n                break;\r\n            }\r\n        }\r\n        return foundActive;\r\n    }\r\n\r\n    function clone(obj) {\r\n        var clonedObj = {};\r\n        for (var prop in obj) {\r\n            if (obj.hasOwnProperty(prop)) {\r\n                clonedObj[prop] = obj[prop];\r\n            }\r\n        }\r\n\r\n        return clonedObj;\r\n    }\r\n\r\n    return Suite;\r\n}","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmineRequire.Suite.[function].[return].[function].[arg0]","key":"clearStack","isClass":false,"containerType":"// Seen as: attrs\ninterface interface_823 {\n    description: any;\n    env: any;\n    expectationFactory: any;\n    expectationResultFactory: any;\n    id: any;\n    parentSuite: any;\n    throwOnExpectationFailure: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.Suite.[function].[return]","newFunction":"function(j$) {\r\n    function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }\r\n\r\n    Suite.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Suite.prototype.getFullName = function() {\r\n        var fullName = [];\r\n        for (var parentSuite = this; parentSuite; parentSuite = parentSuite.parentSuite) {\r\n            if (parentSuite.parentSuite) {\r\n                fullName.unshift(parentSuite.description);\r\n            }\r\n        }\r\n        return fullName.join(' ');\r\n    };\r\n\r\n    Suite.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Suite.prototype.pend = function(message) {\r\n        this.markedPending = true;\r\n    };\r\n\r\n    Suite.prototype.beforeEach = function(fn) {\r\n        this.beforeFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.beforeAll = function(fn) {\r\n        this.beforeAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.afterEach = function(fn) {\r\n        this.afterFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.afterAll = function(fn) {\r\n        this.afterAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.addChild = function(child) {\r\n        this.children.push(child);\r\n    };\r\n\r\n    Suite.prototype.status = function() {\r\n        if (this.disabled) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.markedPending) {\r\n            return 'pending';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'finished';\r\n        }\r\n    };\r\n\r\n    Suite.prototype.isExecutable = function() {\r\n        return !this.disabled;\r\n    };\r\n\r\n    Suite.prototype.canBeReentered = function() {\r\n        return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;\r\n    };\r\n\r\n    Suite.prototype.getResult = function() {\r\n        this.result.status = this.status();\r\n        return this.result;\r\n    };\r\n\r\n    Suite.prototype.sharedUserContext = function() {\r\n        if (!this.sharedContext) {\r\n            this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\r\n        }\r\n\r\n        return this.sharedContext;\r\n    };\r\n\r\n    Suite.prototype.clonedSharedUserContext = function() {\r\n        return clone(this.sharedUserContext());\r\n    };\r\n\r\n    Suite.prototype.onException = function() {\r\n        if (arguments[0] instanceof j$.errors.ExpectationFailed) {\r\n            return;\r\n        }\r\n\r\n        if(isAfterAll(this.children)) {\r\n            var data = {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                error: arguments[0]\r\n            };\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.onException.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    Suite.prototype.addExpectationResult = function () {\r\n        if(isAfterAll(this.children) && isFailure(arguments)){\r\n            var data = arguments[1];\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n            if(this.throwOnExpectationFailure) {\r\n                throw new j$.errors.ExpectationFailed();\r\n            }\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                try {\r\n                    child.addExpectationResult.apply(child, arguments);\r\n                } catch(e) {\r\n                    // keep going\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    function isAfterAll(children) {\r\n        return children && children[0].result.status;\r\n    }\r\n\r\n    function isFailure(args) {\r\n        return !args[0];\r\n    }\r\n\r\n    function clone(obj) {\r\n        var clonedObj = {};\r\n        for (var prop in obj) {\r\n            if (obj.hasOwnProperty(prop)) {\r\n                clonedObj[prop] = obj[prop];\r\n            }\r\n        }\r\n\r\n        return clonedObj;\r\n    }\r\n\r\n    return Suite;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.Suite.[function].[return]","oldFunction":"function() {\r\n    function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }\r\n\r\n    Suite.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Suite.prototype.getFullName = function() {\r\n        var fullName = this.description;\r\n        for (var parentSuite = this.parentSuite; parentSuite; parentSuite = parentSuite.parentSuite) {\r\n            if (parentSuite.parentSuite) {\r\n                fullName = parentSuite.description + ' ' + fullName;\r\n            }\r\n        }\r\n        return fullName;\r\n    };\r\n\r\n    Suite.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Suite.prototype.beforeEach = function(fn) {\r\n        this.beforeFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.beforeAll = function(fn) {\r\n        this.beforeAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.afterEach = function(fn) {\r\n        this.afterFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.afterAll = function(fn) {\r\n        this.afterAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.addChild = function(child) {\r\n        this.children.push(child);\r\n    };\r\n\r\n    Suite.prototype.status = function() {\r\n        if (this.disabled) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'finished';\r\n        }\r\n    };\r\n\r\n    Suite.prototype.execute = function(onComplete) {\r\n        var self = this;\r\n\r\n        this.onStart(this);\r\n\r\n        if (this.disabled) {\r\n            complete();\r\n            return;\r\n        }\r\n\r\n        var allFns = [];\r\n\r\n        for (var i = 0; i < this.children.length; i++) {\r\n            allFns.push(wrapChildAsAsync(this.children[i]));\r\n        }\r\n\r\n        if (this.isExecutable()) {\r\n            allFns = this.beforeAllFns.concat(allFns);\r\n            allFns = allFns.concat(this.afterAllFns);\r\n        }\r\n\r\n        this.queueRunner({\r\n            queueableFns: allFns,\r\n            onComplete: complete,\r\n            userContext: this.sharedUserContext(),\r\n            onException: function() { self.onException.apply(self, arguments); }\r\n        });\r\n\r\n        function complete() {\r\n            self.result.status = self.status();\r\n            self.resultCallback(self.result);\r\n\r\n            if (onComplete) {\r\n                onComplete();\r\n            }\r\n        }\r\n\r\n        function wrapChildAsAsync(child) {\r\n            return { fn: function(done) { child.execute(done); } };\r\n        }\r\n    };\r\n\r\n    Suite.prototype.isExecutable = function() {\r\n        var runnablesExplicitlySet = this.runnablesExplictlySetGetter();\r\n        return !runnablesExplicitlySet && hasExecutableChild(this.children);\r\n    };\r\n\r\n    Suite.prototype.sharedUserContext = function() {\r\n        if (!this.sharedContext) {\r\n            this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\r\n        }\r\n\r\n        return this.sharedContext;\r\n    };\r\n\r\n    Suite.prototype.clonedSharedUserContext = function() {\r\n        return clone(this.sharedUserContext());\r\n    };\r\n\r\n    Suite.prototype.onException = function() {\r\n        if(isAfterAll(this.children)) {\r\n            var data = {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                error: arguments[0]\r\n            };\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.onException.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    Suite.prototype.addExpectationResult = function () {\r\n        if(isAfterAll(this.children) && isFailure(arguments)){\r\n            var data = arguments[1];\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.addExpectationResult.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    function isAfterAll(children) {\r\n        return children && children[0].result.status;\r\n    }\r\n\r\n    function isFailure(args) {\r\n        return !args[0];\r\n    }\r\n\r\n    function hasExecutableChild(children) {\r\n        var foundActive = false;\r\n        for (var i = 0; i < children.length; i++) {\r\n            if (children[i].isExecutable()) {\r\n                foundActive = true;\r\n                break;\r\n            }\r\n        }\r\n        return foundActive;\r\n    }\r\n\r\n    function clone(obj) {\r\n        var clonedObj = {};\r\n        for (var prop in obj) {\r\n            if (obj.hasOwnProperty(prop)) {\r\n                clonedObj[prop] = obj[prop];\r\n            }\r\n        }\r\n\r\n        return clonedObj;\r\n    }\r\n\r\n    return Suite;\r\n}","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmineRequire.Suite.[function].[return].[function].[arg0]","key":"onStart","isClass":false,"containerType":"// Seen as: attrs\ninterface interface_823 {\n    description: any;\n    env: any;\n    expectationFactory: any;\n    expectationResultFactory: any;\n    id: any;\n    parentSuite: any;\n    throwOnExpectationFailure: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.Suite.[function].[return]","newFunction":"function(j$) {\r\n    function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }\r\n\r\n    Suite.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Suite.prototype.getFullName = function() {\r\n        var fullName = [];\r\n        for (var parentSuite = this; parentSuite; parentSuite = parentSuite.parentSuite) {\r\n            if (parentSuite.parentSuite) {\r\n                fullName.unshift(parentSuite.description);\r\n            }\r\n        }\r\n        return fullName.join(' ');\r\n    };\r\n\r\n    Suite.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Suite.prototype.pend = function(message) {\r\n        this.markedPending = true;\r\n    };\r\n\r\n    Suite.prototype.beforeEach = function(fn) {\r\n        this.beforeFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.beforeAll = function(fn) {\r\n        this.beforeAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.afterEach = function(fn) {\r\n        this.afterFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.afterAll = function(fn) {\r\n        this.afterAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.addChild = function(child) {\r\n        this.children.push(child);\r\n    };\r\n\r\n    Suite.prototype.status = function() {\r\n        if (this.disabled) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.markedPending) {\r\n            return 'pending';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'finished';\r\n        }\r\n    };\r\n\r\n    Suite.prototype.isExecutable = function() {\r\n        return !this.disabled;\r\n    };\r\n\r\n    Suite.prototype.canBeReentered = function() {\r\n        return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;\r\n    };\r\n\r\n    Suite.prototype.getResult = function() {\r\n        this.result.status = this.status();\r\n        return this.result;\r\n    };\r\n\r\n    Suite.prototype.sharedUserContext = function() {\r\n        if (!this.sharedContext) {\r\n            this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\r\n        }\r\n\r\n        return this.sharedContext;\r\n    };\r\n\r\n    Suite.prototype.clonedSharedUserContext = function() {\r\n        return clone(this.sharedUserContext());\r\n    };\r\n\r\n    Suite.prototype.onException = function() {\r\n        if (arguments[0] instanceof j$.errors.ExpectationFailed) {\r\n            return;\r\n        }\r\n\r\n        if(isAfterAll(this.children)) {\r\n            var data = {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                error: arguments[0]\r\n            };\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.onException.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    Suite.prototype.addExpectationResult = function () {\r\n        if(isAfterAll(this.children) && isFailure(arguments)){\r\n            var data = arguments[1];\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n            if(this.throwOnExpectationFailure) {\r\n                throw new j$.errors.ExpectationFailed();\r\n            }\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                try {\r\n                    child.addExpectationResult.apply(child, arguments);\r\n                } catch(e) {\r\n                    // keep going\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    function isAfterAll(children) {\r\n        return children && children[0].result.status;\r\n    }\r\n\r\n    function isFailure(args) {\r\n        return !args[0];\r\n    }\r\n\r\n    function clone(obj) {\r\n        var clonedObj = {};\r\n        for (var prop in obj) {\r\n            if (obj.hasOwnProperty(prop)) {\r\n                clonedObj[prop] = obj[prop];\r\n            }\r\n        }\r\n\r\n        return clonedObj;\r\n    }\r\n\r\n    return Suite;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.Suite.[function].[return]","oldFunction":"function() {\r\n    function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }\r\n\r\n    Suite.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Suite.prototype.getFullName = function() {\r\n        var fullName = this.description;\r\n        for (var parentSuite = this.parentSuite; parentSuite; parentSuite = parentSuite.parentSuite) {\r\n            if (parentSuite.parentSuite) {\r\n                fullName = parentSuite.description + ' ' + fullName;\r\n            }\r\n        }\r\n        return fullName;\r\n    };\r\n\r\n    Suite.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Suite.prototype.beforeEach = function(fn) {\r\n        this.beforeFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.beforeAll = function(fn) {\r\n        this.beforeAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.afterEach = function(fn) {\r\n        this.afterFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.afterAll = function(fn) {\r\n        this.afterAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.addChild = function(child) {\r\n        this.children.push(child);\r\n    };\r\n\r\n    Suite.prototype.status = function() {\r\n        if (this.disabled) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'finished';\r\n        }\r\n    };\r\n\r\n    Suite.prototype.execute = function(onComplete) {\r\n        var self = this;\r\n\r\n        this.onStart(this);\r\n\r\n        if (this.disabled) {\r\n            complete();\r\n            return;\r\n        }\r\n\r\n        var allFns = [];\r\n\r\n        for (var i = 0; i < this.children.length; i++) {\r\n            allFns.push(wrapChildAsAsync(this.children[i]));\r\n        }\r\n\r\n        if (this.isExecutable()) {\r\n            allFns = this.beforeAllFns.concat(allFns);\r\n            allFns = allFns.concat(this.afterAllFns);\r\n        }\r\n\r\n        this.queueRunner({\r\n            queueableFns: allFns,\r\n            onComplete: complete,\r\n            userContext: this.sharedUserContext(),\r\n            onException: function() { self.onException.apply(self, arguments); }\r\n        });\r\n\r\n        function complete() {\r\n            self.result.status = self.status();\r\n            self.resultCallback(self.result);\r\n\r\n            if (onComplete) {\r\n                onComplete();\r\n            }\r\n        }\r\n\r\n        function wrapChildAsAsync(child) {\r\n            return { fn: function(done) { child.execute(done); } };\r\n        }\r\n    };\r\n\r\n    Suite.prototype.isExecutable = function() {\r\n        var runnablesExplicitlySet = this.runnablesExplictlySetGetter();\r\n        return !runnablesExplicitlySet && hasExecutableChild(this.children);\r\n    };\r\n\r\n    Suite.prototype.sharedUserContext = function() {\r\n        if (!this.sharedContext) {\r\n            this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\r\n        }\r\n\r\n        return this.sharedContext;\r\n    };\r\n\r\n    Suite.prototype.clonedSharedUserContext = function() {\r\n        return clone(this.sharedUserContext());\r\n    };\r\n\r\n    Suite.prototype.onException = function() {\r\n        if(isAfterAll(this.children)) {\r\n            var data = {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                error: arguments[0]\r\n            };\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.onException.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    Suite.prototype.addExpectationResult = function () {\r\n        if(isAfterAll(this.children) && isFailure(arguments)){\r\n            var data = arguments[1];\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.addExpectationResult.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    function isAfterAll(children) {\r\n        return children && children[0].result.status;\r\n    }\r\n\r\n    function isFailure(args) {\r\n        return !args[0];\r\n    }\r\n\r\n    function hasExecutableChild(children) {\r\n        var foundActive = false;\r\n        for (var i = 0; i < children.length; i++) {\r\n            if (children[i].isExecutable()) {\r\n                foundActive = true;\r\n                break;\r\n            }\r\n        }\r\n        return foundActive;\r\n    }\r\n\r\n    function clone(obj) {\r\n        var clonedObj = {};\r\n        for (var prop in obj) {\r\n            if (obj.hasOwnProperty(prop)) {\r\n                clonedObj[prop] = obj[prop];\r\n            }\r\n        }\r\n\r\n        return clonedObj;\r\n    }\r\n\r\n    return Suite;\r\n}","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmineRequire.Suite.[function].[return].[function].[arg0]","key":"runnablesExplictlySetGetter","isClass":false,"containerType":"// Seen as: attrs\ninterface interface_823 {\n    description: any;\n    env: any;\n    expectationFactory: any;\n    expectationResultFactory: any;\n    id: any;\n    parentSuite: any;\n    throwOnExpectationFailure: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.Suite.[function].[return]","newFunction":"function(j$) {\r\n    function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }\r\n\r\n    Suite.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Suite.prototype.getFullName = function() {\r\n        var fullName = [];\r\n        for (var parentSuite = this; parentSuite; parentSuite = parentSuite.parentSuite) {\r\n            if (parentSuite.parentSuite) {\r\n                fullName.unshift(parentSuite.description);\r\n            }\r\n        }\r\n        return fullName.join(' ');\r\n    };\r\n\r\n    Suite.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Suite.prototype.pend = function(message) {\r\n        this.markedPending = true;\r\n    };\r\n\r\n    Suite.prototype.beforeEach = function(fn) {\r\n        this.beforeFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.beforeAll = function(fn) {\r\n        this.beforeAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.afterEach = function(fn) {\r\n        this.afterFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.afterAll = function(fn) {\r\n        this.afterAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.addChild = function(child) {\r\n        this.children.push(child);\r\n    };\r\n\r\n    Suite.prototype.status = function() {\r\n        if (this.disabled) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.markedPending) {\r\n            return 'pending';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'finished';\r\n        }\r\n    };\r\n\r\n    Suite.prototype.isExecutable = function() {\r\n        return !this.disabled;\r\n    };\r\n\r\n    Suite.prototype.canBeReentered = function() {\r\n        return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;\r\n    };\r\n\r\n    Suite.prototype.getResult = function() {\r\n        this.result.status = this.status();\r\n        return this.result;\r\n    };\r\n\r\n    Suite.prototype.sharedUserContext = function() {\r\n        if (!this.sharedContext) {\r\n            this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\r\n        }\r\n\r\n        return this.sharedContext;\r\n    };\r\n\r\n    Suite.prototype.clonedSharedUserContext = function() {\r\n        return clone(this.sharedUserContext());\r\n    };\r\n\r\n    Suite.prototype.onException = function() {\r\n        if (arguments[0] instanceof j$.errors.ExpectationFailed) {\r\n            return;\r\n        }\r\n\r\n        if(isAfterAll(this.children)) {\r\n            var data = {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                error: arguments[0]\r\n            };\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.onException.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    Suite.prototype.addExpectationResult = function () {\r\n        if(isAfterAll(this.children) && isFailure(arguments)){\r\n            var data = arguments[1];\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n            if(this.throwOnExpectationFailure) {\r\n                throw new j$.errors.ExpectationFailed();\r\n            }\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                try {\r\n                    child.addExpectationResult.apply(child, arguments);\r\n                } catch(e) {\r\n                    // keep going\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    function isAfterAll(children) {\r\n        return children && children[0].result.status;\r\n    }\r\n\r\n    function isFailure(args) {\r\n        return !args[0];\r\n    }\r\n\r\n    function clone(obj) {\r\n        var clonedObj = {};\r\n        for (var prop in obj) {\r\n            if (obj.hasOwnProperty(prop)) {\r\n                clonedObj[prop] = obj[prop];\r\n            }\r\n        }\r\n\r\n        return clonedObj;\r\n    }\r\n\r\n    return Suite;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.Suite.[function].[return]","oldFunction":"function() {\r\n    function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }\r\n\r\n    Suite.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Suite.prototype.getFullName = function() {\r\n        var fullName = this.description;\r\n        for (var parentSuite = this.parentSuite; parentSuite; parentSuite = parentSuite.parentSuite) {\r\n            if (parentSuite.parentSuite) {\r\n                fullName = parentSuite.description + ' ' + fullName;\r\n            }\r\n        }\r\n        return fullName;\r\n    };\r\n\r\n    Suite.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Suite.prototype.beforeEach = function(fn) {\r\n        this.beforeFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.beforeAll = function(fn) {\r\n        this.beforeAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.afterEach = function(fn) {\r\n        this.afterFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.afterAll = function(fn) {\r\n        this.afterAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.addChild = function(child) {\r\n        this.children.push(child);\r\n    };\r\n\r\n    Suite.prototype.status = function() {\r\n        if (this.disabled) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'finished';\r\n        }\r\n    };\r\n\r\n    Suite.prototype.execute = function(onComplete) {\r\n        var self = this;\r\n\r\n        this.onStart(this);\r\n\r\n        if (this.disabled) {\r\n            complete();\r\n            return;\r\n        }\r\n\r\n        var allFns = [];\r\n\r\n        for (var i = 0; i < this.children.length; i++) {\r\n            allFns.push(wrapChildAsAsync(this.children[i]));\r\n        }\r\n\r\n        if (this.isExecutable()) {\r\n            allFns = this.beforeAllFns.concat(allFns);\r\n            allFns = allFns.concat(this.afterAllFns);\r\n        }\r\n\r\n        this.queueRunner({\r\n            queueableFns: allFns,\r\n            onComplete: complete,\r\n            userContext: this.sharedUserContext(),\r\n            onException: function() { self.onException.apply(self, arguments); }\r\n        });\r\n\r\n        function complete() {\r\n            self.result.status = self.status();\r\n            self.resultCallback(self.result);\r\n\r\n            if (onComplete) {\r\n                onComplete();\r\n            }\r\n        }\r\n\r\n        function wrapChildAsAsync(child) {\r\n            return { fn: function(done) { child.execute(done); } };\r\n        }\r\n    };\r\n\r\n    Suite.prototype.isExecutable = function() {\r\n        var runnablesExplicitlySet = this.runnablesExplictlySetGetter();\r\n        return !runnablesExplicitlySet && hasExecutableChild(this.children);\r\n    };\r\n\r\n    Suite.prototype.sharedUserContext = function() {\r\n        if (!this.sharedContext) {\r\n            this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\r\n        }\r\n\r\n        return this.sharedContext;\r\n    };\r\n\r\n    Suite.prototype.clonedSharedUserContext = function() {\r\n        return clone(this.sharedUserContext());\r\n    };\r\n\r\n    Suite.prototype.onException = function() {\r\n        if(isAfterAll(this.children)) {\r\n            var data = {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                error: arguments[0]\r\n            };\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.onException.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    Suite.prototype.addExpectationResult = function () {\r\n        if(isAfterAll(this.children) && isFailure(arguments)){\r\n            var data = arguments[1];\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.addExpectationResult.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    function isAfterAll(children) {\r\n        return children && children[0].result.status;\r\n    }\r\n\r\n    function isFailure(args) {\r\n        return !args[0];\r\n    }\r\n\r\n    function hasExecutableChild(children) {\r\n        var foundActive = false;\r\n        for (var i = 0; i < children.length; i++) {\r\n            if (children[i].isExecutable()) {\r\n                foundActive = true;\r\n                break;\r\n            }\r\n        }\r\n        return foundActive;\r\n    }\r\n\r\n    function clone(obj) {\r\n        var clonedObj = {};\r\n        for (var prop in obj) {\r\n            if (obj.hasOwnProperty(prop)) {\r\n                clonedObj[prop] = obj[prop];\r\n            }\r\n        }\r\n\r\n        return clonedObj;\r\n    }\r\n\r\n    return Suite;\r\n}","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmineRequire.Suite.[function].[return].[function].[arg0]","key":"queueRunner","isClass":false,"containerType":"// Seen as: attrs\ninterface interface_823 {\n    description: any;\n    env: any;\n    expectationFactory: any;\n    expectationResultFactory: any;\n    id: any;\n    parentSuite: any;\n    throwOnExpectationFailure: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.Suite.[function].[return]","newFunction":"function(j$) {\r\n    function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }\r\n\r\n    Suite.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Suite.prototype.getFullName = function() {\r\n        var fullName = [];\r\n        for (var parentSuite = this; parentSuite; parentSuite = parentSuite.parentSuite) {\r\n            if (parentSuite.parentSuite) {\r\n                fullName.unshift(parentSuite.description);\r\n            }\r\n        }\r\n        return fullName.join(' ');\r\n    };\r\n\r\n    Suite.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Suite.prototype.pend = function(message) {\r\n        this.markedPending = true;\r\n    };\r\n\r\n    Suite.prototype.beforeEach = function(fn) {\r\n        this.beforeFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.beforeAll = function(fn) {\r\n        this.beforeAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.afterEach = function(fn) {\r\n        this.afterFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.afterAll = function(fn) {\r\n        this.afterAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.addChild = function(child) {\r\n        this.children.push(child);\r\n    };\r\n\r\n    Suite.prototype.status = function() {\r\n        if (this.disabled) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.markedPending) {\r\n            return 'pending';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'finished';\r\n        }\r\n    };\r\n\r\n    Suite.prototype.isExecutable = function() {\r\n        return !this.disabled;\r\n    };\r\n\r\n    Suite.prototype.canBeReentered = function() {\r\n        return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;\r\n    };\r\n\r\n    Suite.prototype.getResult = function() {\r\n        this.result.status = this.status();\r\n        return this.result;\r\n    };\r\n\r\n    Suite.prototype.sharedUserContext = function() {\r\n        if (!this.sharedContext) {\r\n            this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\r\n        }\r\n\r\n        return this.sharedContext;\r\n    };\r\n\r\n    Suite.prototype.clonedSharedUserContext = function() {\r\n        return clone(this.sharedUserContext());\r\n    };\r\n\r\n    Suite.prototype.onException = function() {\r\n        if (arguments[0] instanceof j$.errors.ExpectationFailed) {\r\n            return;\r\n        }\r\n\r\n        if(isAfterAll(this.children)) {\r\n            var data = {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                error: arguments[0]\r\n            };\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.onException.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    Suite.prototype.addExpectationResult = function () {\r\n        if(isAfterAll(this.children) && isFailure(arguments)){\r\n            var data = arguments[1];\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n            if(this.throwOnExpectationFailure) {\r\n                throw new j$.errors.ExpectationFailed();\r\n            }\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                try {\r\n                    child.addExpectationResult.apply(child, arguments);\r\n                } catch(e) {\r\n                    // keep going\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    function isAfterAll(children) {\r\n        return children && children[0].result.status;\r\n    }\r\n\r\n    function isFailure(args) {\r\n        return !args[0];\r\n    }\r\n\r\n    function clone(obj) {\r\n        var clonedObj = {};\r\n        for (var prop in obj) {\r\n            if (obj.hasOwnProperty(prop)) {\r\n                clonedObj[prop] = obj[prop];\r\n            }\r\n        }\r\n\r\n        return clonedObj;\r\n    }\r\n\r\n    return Suite;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.Suite.[function].[return]","oldFunction":"function() {\r\n    function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }\r\n\r\n    Suite.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Suite.prototype.getFullName = function() {\r\n        var fullName = this.description;\r\n        for (var parentSuite = this.parentSuite; parentSuite; parentSuite = parentSuite.parentSuite) {\r\n            if (parentSuite.parentSuite) {\r\n                fullName = parentSuite.description + ' ' + fullName;\r\n            }\r\n        }\r\n        return fullName;\r\n    };\r\n\r\n    Suite.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Suite.prototype.beforeEach = function(fn) {\r\n        this.beforeFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.beforeAll = function(fn) {\r\n        this.beforeAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.afterEach = function(fn) {\r\n        this.afterFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.afterAll = function(fn) {\r\n        this.afterAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.addChild = function(child) {\r\n        this.children.push(child);\r\n    };\r\n\r\n    Suite.prototype.status = function() {\r\n        if (this.disabled) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'finished';\r\n        }\r\n    };\r\n\r\n    Suite.prototype.execute = function(onComplete) {\r\n        var self = this;\r\n\r\n        this.onStart(this);\r\n\r\n        if (this.disabled) {\r\n            complete();\r\n            return;\r\n        }\r\n\r\n        var allFns = [];\r\n\r\n        for (var i = 0; i < this.children.length; i++) {\r\n            allFns.push(wrapChildAsAsync(this.children[i]));\r\n        }\r\n\r\n        if (this.isExecutable()) {\r\n            allFns = this.beforeAllFns.concat(allFns);\r\n            allFns = allFns.concat(this.afterAllFns);\r\n        }\r\n\r\n        this.queueRunner({\r\n            queueableFns: allFns,\r\n            onComplete: complete,\r\n            userContext: this.sharedUserContext(),\r\n            onException: function() { self.onException.apply(self, arguments); }\r\n        });\r\n\r\n        function complete() {\r\n            self.result.status = self.status();\r\n            self.resultCallback(self.result);\r\n\r\n            if (onComplete) {\r\n                onComplete();\r\n            }\r\n        }\r\n\r\n        function wrapChildAsAsync(child) {\r\n            return { fn: function(done) { child.execute(done); } };\r\n        }\r\n    };\r\n\r\n    Suite.prototype.isExecutable = function() {\r\n        var runnablesExplicitlySet = this.runnablesExplictlySetGetter();\r\n        return !runnablesExplicitlySet && hasExecutableChild(this.children);\r\n    };\r\n\r\n    Suite.prototype.sharedUserContext = function() {\r\n        if (!this.sharedContext) {\r\n            this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\r\n        }\r\n\r\n        return this.sharedContext;\r\n    };\r\n\r\n    Suite.prototype.clonedSharedUserContext = function() {\r\n        return clone(this.sharedUserContext());\r\n    };\r\n\r\n    Suite.prototype.onException = function() {\r\n        if(isAfterAll(this.children)) {\r\n            var data = {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                error: arguments[0]\r\n            };\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.onException.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    Suite.prototype.addExpectationResult = function () {\r\n        if(isAfterAll(this.children) && isFailure(arguments)){\r\n            var data = arguments[1];\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.addExpectationResult.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    function isAfterAll(children) {\r\n        return children && children[0].result.status;\r\n    }\r\n\r\n    function isFailure(args) {\r\n        return !args[0];\r\n    }\r\n\r\n    function hasExecutableChild(children) {\r\n        var foundActive = false;\r\n        for (var i = 0; i < children.length; i++) {\r\n            if (children[i].isExecutable()) {\r\n                foundActive = true;\r\n                break;\r\n            }\r\n        }\r\n        return foundActive;\r\n    }\r\n\r\n    function clone(obj) {\r\n        var clonedObj = {};\r\n        for (var prop in obj) {\r\n            if (obj.hasOwnProperty(prop)) {\r\n                clonedObj[prop] = obj[prop];\r\n            }\r\n        }\r\n\r\n        return clonedObj;\r\n    }\r\n\r\n    return Suite;\r\n}","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmineRequire.Suite.[function].[return].[function].[arg0]","key":"resultCallback","isClass":false,"containerType":"// Seen as: attrs\ninterface interface_823 {\n    description: any;\n    env: any;\n    expectationFactory: any;\n    expectationResultFactory: any;\n    id: any;\n    parentSuite: any;\n    throwOnExpectationFailure: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.Suite.[function].[return]","newFunction":"function(j$) {\r\n    function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }\r\n\r\n    Suite.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Suite.prototype.getFullName = function() {\r\n        var fullName = [];\r\n        for (var parentSuite = this; parentSuite; parentSuite = parentSuite.parentSuite) {\r\n            if (parentSuite.parentSuite) {\r\n                fullName.unshift(parentSuite.description);\r\n            }\r\n        }\r\n        return fullName.join(' ');\r\n    };\r\n\r\n    Suite.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Suite.prototype.pend = function(message) {\r\n        this.markedPending = true;\r\n    };\r\n\r\n    Suite.prototype.beforeEach = function(fn) {\r\n        this.beforeFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.beforeAll = function(fn) {\r\n        this.beforeAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.afterEach = function(fn) {\r\n        this.afterFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.afterAll = function(fn) {\r\n        this.afterAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.addChild = function(child) {\r\n        this.children.push(child);\r\n    };\r\n\r\n    Suite.prototype.status = function() {\r\n        if (this.disabled) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.markedPending) {\r\n            return 'pending';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'finished';\r\n        }\r\n    };\r\n\r\n    Suite.prototype.isExecutable = function() {\r\n        return !this.disabled;\r\n    };\r\n\r\n    Suite.prototype.canBeReentered = function() {\r\n        return this.beforeAllFns.length === 0 && this.afterAllFns.length === 0;\r\n    };\r\n\r\n    Suite.prototype.getResult = function() {\r\n        this.result.status = this.status();\r\n        return this.result;\r\n    };\r\n\r\n    Suite.prototype.sharedUserContext = function() {\r\n        if (!this.sharedContext) {\r\n            this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\r\n        }\r\n\r\n        return this.sharedContext;\r\n    };\r\n\r\n    Suite.prototype.clonedSharedUserContext = function() {\r\n        return clone(this.sharedUserContext());\r\n    };\r\n\r\n    Suite.prototype.onException = function() {\r\n        if (arguments[0] instanceof j$.errors.ExpectationFailed) {\r\n            return;\r\n        }\r\n\r\n        if(isAfterAll(this.children)) {\r\n            var data = {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                error: arguments[0]\r\n            };\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.onException.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    Suite.prototype.addExpectationResult = function () {\r\n        if(isAfterAll(this.children) && isFailure(arguments)){\r\n            var data = arguments[1];\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n            if(this.throwOnExpectationFailure) {\r\n                throw new j$.errors.ExpectationFailed();\r\n            }\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                try {\r\n                    child.addExpectationResult.apply(child, arguments);\r\n                } catch(e) {\r\n                    // keep going\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    function isAfterAll(children) {\r\n        return children && children[0].result.status;\r\n    }\r\n\r\n    function isFailure(args) {\r\n        return !args[0];\r\n    }\r\n\r\n    function clone(obj) {\r\n        var clonedObj = {};\r\n        for (var prop in obj) {\r\n            if (obj.hasOwnProperty(prop)) {\r\n                clonedObj[prop] = obj[prop];\r\n            }\r\n        }\r\n\r\n        return clonedObj;\r\n    }\r\n\r\n    return Suite;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.Suite.[function].[return]","oldFunction":"function() {\r\n    function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }\r\n\r\n    Suite.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Suite.prototype.getFullName = function() {\r\n        var fullName = this.description;\r\n        for (var parentSuite = this.parentSuite; parentSuite; parentSuite = parentSuite.parentSuite) {\r\n            if (parentSuite.parentSuite) {\r\n                fullName = parentSuite.description + ' ' + fullName;\r\n            }\r\n        }\r\n        return fullName;\r\n    };\r\n\r\n    Suite.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Suite.prototype.beforeEach = function(fn) {\r\n        this.beforeFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.beforeAll = function(fn) {\r\n        this.beforeAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.afterEach = function(fn) {\r\n        this.afterFns.unshift(fn);\r\n    };\r\n\r\n    Suite.prototype.afterAll = function(fn) {\r\n        this.afterAllFns.push(fn);\r\n    };\r\n\r\n    Suite.prototype.addChild = function(child) {\r\n        this.children.push(child);\r\n    };\r\n\r\n    Suite.prototype.status = function() {\r\n        if (this.disabled) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'finished';\r\n        }\r\n    };\r\n\r\n    Suite.prototype.execute = function(onComplete) {\r\n        var self = this;\r\n\r\n        this.onStart(this);\r\n\r\n        if (this.disabled) {\r\n            complete();\r\n            return;\r\n        }\r\n\r\n        var allFns = [];\r\n\r\n        for (var i = 0; i < this.children.length; i++) {\r\n            allFns.push(wrapChildAsAsync(this.children[i]));\r\n        }\r\n\r\n        if (this.isExecutable()) {\r\n            allFns = this.beforeAllFns.concat(allFns);\r\n            allFns = allFns.concat(this.afterAllFns);\r\n        }\r\n\r\n        this.queueRunner({\r\n            queueableFns: allFns,\r\n            onComplete: complete,\r\n            userContext: this.sharedUserContext(),\r\n            onException: function() { self.onException.apply(self, arguments); }\r\n        });\r\n\r\n        function complete() {\r\n            self.result.status = self.status();\r\n            self.resultCallback(self.result);\r\n\r\n            if (onComplete) {\r\n                onComplete();\r\n            }\r\n        }\r\n\r\n        function wrapChildAsAsync(child) {\r\n            return { fn: function(done) { child.execute(done); } };\r\n        }\r\n    };\r\n\r\n    Suite.prototype.isExecutable = function() {\r\n        var runnablesExplicitlySet = this.runnablesExplictlySetGetter();\r\n        return !runnablesExplicitlySet && hasExecutableChild(this.children);\r\n    };\r\n\r\n    Suite.prototype.sharedUserContext = function() {\r\n        if (!this.sharedContext) {\r\n            this.sharedContext = this.parentSuite ? clone(this.parentSuite.sharedUserContext()) : {};\r\n        }\r\n\r\n        return this.sharedContext;\r\n    };\r\n\r\n    Suite.prototype.clonedSharedUserContext = function() {\r\n        return clone(this.sharedUserContext());\r\n    };\r\n\r\n    Suite.prototype.onException = function() {\r\n        if(isAfterAll(this.children)) {\r\n            var data = {\r\n                matcherName: '',\r\n                passed: false,\r\n                expected: '',\r\n                actual: '',\r\n                error: arguments[0]\r\n            };\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.onException.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    Suite.prototype.addExpectationResult = function () {\r\n        if(isAfterAll(this.children) && isFailure(arguments)){\r\n            var data = arguments[1];\r\n            this.result.failedExpectations.push(this.expectationResultFactory(data));\r\n        } else {\r\n            for (var i = 0; i < this.children.length; i++) {\r\n                var child = this.children[i];\r\n                child.addExpectationResult.apply(child, arguments);\r\n            }\r\n        }\r\n    };\r\n\r\n    function isAfterAll(children) {\r\n        return children && children[0].result.status;\r\n    }\r\n\r\n    function isFailure(args) {\r\n        return !args[0];\r\n    }\r\n\r\n    function hasExecutableChild(children) {\r\n        var foundActive = false;\r\n        for (var i = 0; i < children.length; i++) {\r\n            if (children[i].isExecutable()) {\r\n                foundActive = true;\r\n                break;\r\n            }\r\n        }\r\n        return foundActive;\r\n    }\r\n\r\n    function clone(obj) {\r\n        var clonedObj = {};\r\n        for (var prop in obj) {\r\n            if (obj.hasOwnProperty(prop)) {\r\n                clonedObj[prop] = obj[prop];\r\n            }\r\n        }\r\n\r\n        return clonedObj;\r\n    }\r\n\r\n    return Suite;\r\n}","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.Suite.[function].[return].[function].[arg0]","key":"throwOnExpectationFailure","newType":null,"isAny":true,"isClass":false,"containerType":"// Seen as: attrs\ninterface interface_823 {\n    description: any;\n    env: any;\n    expectationFactory: any;\n    expectationResultFactory: any;\n    id: any;\n    parentSuite: any;\n    throwOnExpectationFailure: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.Clock.[function].[return]","newFunction":"function() {\r\n    function Clock(global, delayedFunctionSchedulerFactory, mockDate) {\r\n        var self = this,\r\n            realTimingFunctions = {\r\n                setTimeout: global.setTimeout,\r\n                clearTimeout: global.clearTimeout,\r\n                setInterval: global.setInterval,\r\n                clearInterval: global.clearInterval\r\n            },\r\n            fakeTimingFunctions = {\r\n                setTimeout: setTimeout,\r\n                clearTimeout: clearTimeout,\r\n                setInterval: setInterval,\r\n                clearInterval: clearInterval\r\n            },\r\n            installed = false,\r\n            delayedFunctionScheduler,\r\n            timer;\r\n\r\n\r\n        self.install = function() {\r\n            if(!originalTimingFunctionsIntact()) {\r\n                throw new Error('Jasmine Clock was unable to install over custom global timer functions. Is the clock already installed?');\r\n            }\r\n            replace(global, fakeTimingFunctions);\r\n            timer = fakeTimingFunctions;\r\n            delayedFunctionScheduler = delayedFunctionSchedulerFactory();\r\n            installed = true;\r\n\r\n            return self;\r\n        };\r\n\r\n        self.uninstall = function() {\r\n            delayedFunctionScheduler = null;\r\n            mockDate.uninstall();\r\n            replace(global, realTimingFunctions);\r\n\r\n            timer = realTimingFunctions;\r\n            installed = false;\r\n        };\r\n\r\n        self.withMock = function(closure) {\r\n            this.install();\r\n            try {\r\n                closure();\r\n            } finally {\r\n                this.uninstall();\r\n            }\r\n        };\r\n\r\n        self.mockDate = function(initialDate) {\r\n            mockDate.install(initialDate);\r\n        };\r\n\r\n        self.setTimeout = function(fn, delay, params) {\r\n            if (legacyIE()) {\r\n                if (arguments.length > 2) {\r\n                    throw new Error('IE < 9 cannot support extra params to setTimeout without a polyfill');\r\n                }\r\n                return timer.setTimeout(fn, delay);\r\n            }\r\n            return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);\r\n        };\r\n\r\n        self.setInterval = function(fn, delay, params) {\r\n            if (legacyIE()) {\r\n                if (arguments.length > 2) {\r\n                    throw new Error('IE < 9 cannot support extra params to setInterval without a polyfill');\r\n                }\r\n                return timer.setInterval(fn, delay);\r\n            }\r\n            return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);\r\n        };\r\n\r\n        self.clearTimeout = function(id) {\r\n            return Function.prototype.call.apply(timer.clearTimeout, [global, id]);\r\n        };\r\n\r\n        self.clearInterval = function(id) {\r\n            return Function.prototype.call.apply(timer.clearInterval, [global, id]);\r\n        };\r\n\r\n        self.tick = function(millis) {\r\n            if (installed) {\r\n                delayedFunctionScheduler.tick(millis, function(millis) { mockDate.tick(millis); });\r\n            } else {\r\n                throw new Error('Mock clock is not installed, use jasmine.clock().install()');\r\n            }\r\n        };\r\n\r\n        return self;\r\n\r\n        function originalTimingFunctionsIntact() {\r\n            return global.setTimeout === realTimingFunctions.setTimeout &&\r\n                global.clearTimeout === realTimingFunctions.clearTimeout &&\r\n                global.setInterval === realTimingFunctions.setInterval &&\r\n                global.clearInterval === realTimingFunctions.clearInterval;\r\n        }\r\n\r\n        function legacyIE() {\r\n            //if these methods are polyfilled, apply will be present\r\n            return !(realTimingFunctions.setTimeout || realTimingFunctions.setInterval).apply;\r\n        }\r\n\r\n        function replace(dest, source) {\r\n            for (var prop in source) {\r\n                dest[prop] = source[prop];\r\n            }\r\n        }\r\n\r\n        function setTimeout(fn, delay) {\r\n            return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));\r\n        }\r\n\r\n        function clearTimeout(id) {\r\n            return delayedFunctionScheduler.removeFunctionWithId(id);\r\n        }\r\n\r\n        function setInterval(fn, interval) {\r\n            return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);\r\n        }\r\n\r\n        function clearInterval(id) {\r\n            return delayedFunctionScheduler.removeFunctionWithId(id);\r\n        }\r\n\r\n        function argSlice(argsObj, n) {\r\n            return Array.prototype.slice.call(argsObj, n);\r\n        }\r\n    }\r\n\r\n    return Clock;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.Clock.[function].[return]","oldFunction":"function() {\r\n    function Clock(global, delayedFunctionScheduler, mockDate) {\r\n        var self = this,\r\n            realTimingFunctions = {\r\n                setTimeout: global.setTimeout,\r\n                clearTimeout: global.clearTimeout,\r\n                setInterval: global.setInterval,\r\n                clearInterval: global.clearInterval\r\n            },\r\n            fakeTimingFunctions = {\r\n                setTimeout: setTimeout,\r\n                clearTimeout: clearTimeout,\r\n                setInterval: setInterval,\r\n                clearInterval: clearInterval\r\n            },\r\n            installed = false,\r\n            timer;\r\n\r\n\r\n        self.install = function() {\r\n            replace(global, fakeTimingFunctions);\r\n            timer = fakeTimingFunctions;\r\n            installed = true;\r\n\r\n            return self;\r\n        };\r\n\r\n        self.uninstall = function() {\r\n            delayedFunctionScheduler.reset();\r\n            mockDate.uninstall();\r\n            replace(global, realTimingFunctions);\r\n\r\n            timer = realTimingFunctions;\r\n            installed = false;\r\n        };\r\n\r\n        self.mockDate = function(initialDate) {\r\n            mockDate.install(initialDate);\r\n        };\r\n\r\n        self.setTimeout = function(fn, delay, params) {\r\n            if (legacyIE()) {\r\n                if (arguments.length > 2) {\r\n                    throw new Error('IE < 9 cannot support extra params to setTimeout without a polyfill');\r\n                }\r\n                return timer.setTimeout(fn, delay);\r\n            }\r\n            return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);\r\n        };\r\n\r\n        self.setInterval = function(fn, delay, params) {\r\n            if (legacyIE()) {\r\n                if (arguments.length > 2) {\r\n                    throw new Error('IE < 9 cannot support extra params to setInterval without a polyfill');\r\n                }\r\n                return timer.setInterval(fn, delay);\r\n            }\r\n            return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);\r\n        };\r\n\r\n        self.clearTimeout = function(id) {\r\n            return Function.prototype.call.apply(timer.clearTimeout, [global, id]);\r\n        };\r\n\r\n        self.clearInterval = function(id) {\r\n            return Function.prototype.call.apply(timer.clearInterval, [global, id]);\r\n        };\r\n\r\n        self.tick = function(millis) {\r\n            if (installed) {\r\n                mockDate.tick(millis);\r\n                delayedFunctionScheduler.tick(millis);\r\n            } else {\r\n                throw new Error('Mock clock is not installed, use jasmine.clock().install()');\r\n            }\r\n        };\r\n\r\n        return self;\r\n\r\n        function legacyIE() {\r\n            //if these methods are polyfilled, apply will be present\r\n            return !(realTimingFunctions.setTimeout || realTimingFunctions.setInterval).apply;\r\n        }\r\n\r\n        function replace(dest, source) {\r\n            for (var prop in source) {\r\n                dest[prop] = source[prop];\r\n            }\r\n        }\r\n\r\n        function setTimeout(fn, delay) {\r\n            return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));\r\n        }\r\n\r\n        function clearTimeout(id) {\r\n            return delayedFunctionScheduler.removeFunctionWithId(id);\r\n        }\r\n\r\n        function setInterval(fn, interval) {\r\n            return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);\r\n        }\r\n\r\n        function clearInterval(id) {\r\n            return delayedFunctionScheduler.removeFunctionWithId(id);\r\n        }\r\n\r\n        function argSlice(argsObj, n) {\r\n            return Array.prototype.slice.call(argsObj, n);\r\n        }\r\n    }\r\n\r\n    return Clock;\r\n}","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.Clock.[function].[return].[function].[return]","key":"withMock","newType":"(closure: () => void) => void","isAny":false,"isClass":false,"containerType":"// Seen as: self\ninterface interface_796 {\n    clearInterval: (id: interface_521) => any;\n    clearTimeout: (id: interface_520) => any;\n    install: function_794;\n    mockDate: (initialDate: any) => void;\n    setInterval: (fn: any, delay: any, params: any) => any;\n    setTimeout: (fn: any, delay: any, params: any) => any;\n    tick: (millis: any) => void;\n    uninstall: () => void;\n    withMock: (closure: () => void) => void;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.DelayedFunctionScheduler.[function].[return]","newFunction":"function() {\r\n    function DelayedFunctionScheduler() {\r\n        var self = this;\r\n        var scheduledLookup = [];\r\n        var scheduledFunctions = {};\r\n        var currentTime = 0;\r\n        var delayedFnCount = 0;\r\n\r\n        self.tick = function(millis, tickDate) {\r\n            millis = millis || 0;\r\n            var endTime = currentTime + millis;\r\n\r\n            runScheduledFunctions(endTime, tickDate);\r\n            currentTime = endTime;\r\n        };\r\n\r\n        self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {\r\n            var f;\r\n            if (typeof(funcToCall) === 'string') {\r\n                /* jshint evil: true */\r\n                f = function() { return eval(funcToCall); };\r\n                /* jshint evil: false */\r\n            } else {\r\n                f = funcToCall;\r\n            }\r\n\r\n            millis = millis || 0;\r\n            timeoutKey = timeoutKey || ++delayedFnCount;\r\n            runAtMillis = runAtMillis || (currentTime + millis);\r\n\r\n            var funcToSchedule = {\r\n                runAtMillis: runAtMillis,\r\n                funcToCall: f,\r\n                recurring: recurring,\r\n                params: params,\r\n                timeoutKey: timeoutKey,\r\n                millis: millis\r\n            };\r\n\r\n            if (runAtMillis in scheduledFunctions) {\r\n                scheduledFunctions[runAtMillis].push(funcToSchedule);\r\n            } else {\r\n                scheduledFunctions[runAtMillis] = [funcToSchedule];\r\n                scheduledLookup.push(runAtMillis);\r\n                scheduledLookup.sort(function (a, b) {\r\n                    return a - b;\r\n                });\r\n            }\r\n\r\n            return timeoutKey;\r\n        };\r\n\r\n        self.removeFunctionWithId = function(timeoutKey) {\r\n            for (var runAtMillis in scheduledFunctions) {\r\n                var funcs = scheduledFunctions[runAtMillis];\r\n                var i = indexOfFirstToPass(funcs, function (func) {\r\n                    return func.timeoutKey === timeoutKey;\r\n                });\r\n\r\n                if (i > -1) {\r\n                    if (funcs.length === 1) {\r\n                        delete scheduledFunctions[runAtMillis];\r\n                        deleteFromLookup(runAtMillis);\r\n                    } else {\r\n                        funcs.splice(i, 1);\r\n                    }\r\n\r\n                    // intervals get rescheduled when executed, so there's never more\r\n                    // than a single scheduled function with a given timeoutKey\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n\r\n        return self;\r\n\r\n        function indexOfFirstToPass(array, testFn) {\r\n            var index = -1;\r\n\r\n            for (var i = 0; i < array.length; ++i) {\r\n                if (testFn(array[i])) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return index;\r\n        }\r\n\r\n        function deleteFromLookup(key) {\r\n            var value = Number(key);\r\n            var i = indexOfFirstToPass(scheduledLookup, function (millis) {\r\n                return millis === value;\r\n            });\r\n\r\n            if (i > -1) {\r\n                scheduledLookup.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        function reschedule(scheduledFn) {\r\n            self.scheduleFunction(scheduledFn.funcToCall,\r\n                scheduledFn.millis,\r\n                scheduledFn.params,\r\n                true,\r\n                scheduledFn.timeoutKey,\r\n                scheduledFn.runAtMillis + scheduledFn.millis);\r\n        }\r\n\r\n        function forEachFunction(funcsToRun, callback) {\r\n            for (var i = 0; i < funcsToRun.length; ++i) {\r\n                callback(funcsToRun[i]);\r\n            }\r\n        }\r\n\r\n        function runScheduledFunctions(endTime, tickDate) {\r\n            tickDate = tickDate || function() {};\r\n            if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {\r\n                tickDate(endTime);\r\n                return;\r\n            }\r\n\r\n            do {\r\n                var newCurrentTime = scheduledLookup.shift();\r\n                tickDate(newCurrentTime - currentTime);\r\n\r\n                currentTime = newCurrentTime;\r\n\r\n                var funcsToRun = scheduledFunctions[currentTime];\r\n                delete scheduledFunctions[currentTime];\r\n\r\n                forEachFunction(funcsToRun, function(funcToRun) {\r\n                    if (funcToRun.recurring) {\r\n                        reschedule(funcToRun);\r\n                    }\r\n                });\r\n\r\n                forEachFunction(funcsToRun, function(funcToRun) {\r\n                    funcToRun.funcToCall.apply(null, funcToRun.params || []);\r\n                });\r\n            } while (scheduledLookup.length > 0 &&\r\n            // checking first if we're out of time prevents setTimeout(0)\r\n            // scheduled in a funcToRun from forcing an extra iteration\r\n            currentTime !== endTime  &&\r\n            scheduledLookup[0] <= endTime);\r\n        }\r\n    }\r\n\r\n    return DelayedFunctionScheduler;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.DelayedFunctionScheduler.[function].[return]","oldFunction":"function() {\r\n    function DelayedFunctionScheduler() {\r\n        var self = this;\r\n        var scheduledLookup = [];\r\n        var scheduledFunctions = {};\r\n        var currentTime = 0;\r\n        var delayedFnCount = 0;\r\n\r\n        self.tick = function(millis) {\r\n            millis = millis || 0;\r\n            var endTime = currentTime + millis;\r\n\r\n            runScheduledFunctions(endTime);\r\n            currentTime = endTime;\r\n        };\r\n\r\n        self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {\r\n            var f;\r\n            if (typeof(funcToCall) === 'string') {\r\n                /* jshint evil: true */\r\n                f = function() { return eval(funcToCall); };\r\n                /* jshint evil: false */\r\n            } else {\r\n                f = funcToCall;\r\n            }\r\n\r\n            millis = millis || 0;\r\n            timeoutKey = timeoutKey || ++delayedFnCount;\r\n            runAtMillis = runAtMillis || (currentTime + millis);\r\n\r\n            var funcToSchedule = {\r\n                runAtMillis: runAtMillis,\r\n                funcToCall: f,\r\n                recurring: recurring,\r\n                params: params,\r\n                timeoutKey: timeoutKey,\r\n                millis: millis\r\n            };\r\n\r\n            if (runAtMillis in scheduledFunctions) {\r\n                scheduledFunctions[runAtMillis].push(funcToSchedule);\r\n            } else {\r\n                scheduledFunctions[runAtMillis] = [funcToSchedule];\r\n                scheduledLookup.push(runAtMillis);\r\n                scheduledLookup.sort(function (a, b) {\r\n                    return a - b;\r\n                });\r\n            }\r\n\r\n            return timeoutKey;\r\n        };\r\n\r\n        self.removeFunctionWithId = function(timeoutKey) {\r\n            for (var runAtMillis in scheduledFunctions) {\r\n                var funcs = scheduledFunctions[runAtMillis];\r\n                var i = indexOfFirstToPass(funcs, function (func) {\r\n                    return func.timeoutKey === timeoutKey;\r\n                });\r\n\r\n                if (i > -1) {\r\n                    if (funcs.length === 1) {\r\n                        delete scheduledFunctions[runAtMillis];\r\n                        deleteFromLookup(runAtMillis);\r\n                    } else {\r\n                        funcs.splice(i, 1);\r\n                    }\r\n\r\n                    // intervals get rescheduled when executed, so there's never more\r\n                    // than a single scheduled function with a given timeoutKey\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n\r\n        self.reset = function() {\r\n            currentTime = 0;\r\n            scheduledLookup = [];\r\n            scheduledFunctions = {};\r\n            delayedFnCount = 0;\r\n        };\r\n\r\n        return self;\r\n\r\n        function indexOfFirstToPass(array, testFn) {\r\n            var index = -1;\r\n\r\n            for (var i = 0; i < array.length; ++i) {\r\n                if (testFn(array[i])) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return index;\r\n        }\r\n\r\n        function deleteFromLookup(key) {\r\n            var value = Number(key);\r\n            var i = indexOfFirstToPass(scheduledLookup, function (millis) {\r\n                return millis === value;\r\n            });\r\n\r\n            if (i > -1) {\r\n                scheduledLookup.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        function reschedule(scheduledFn) {\r\n            self.scheduleFunction(scheduledFn.funcToCall,\r\n                scheduledFn.millis,\r\n                scheduledFn.params,\r\n                true,\r\n                scheduledFn.timeoutKey,\r\n                scheduledFn.runAtMillis + scheduledFn.millis);\r\n        }\r\n\r\n        function forEachFunction(funcsToRun, callback) {\r\n            for (var i = 0; i < funcsToRun.length; ++i) {\r\n                callback(funcsToRun[i]);\r\n            }\r\n        }\r\n\r\n        function runScheduledFunctions(endTime) {\r\n            if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {\r\n                return;\r\n            }\r\n\r\n            do {\r\n                currentTime = scheduledLookup.shift();\r\n\r\n                var funcsToRun = scheduledFunctions[currentTime];\r\n                delete scheduledFunctions[currentTime];\r\n\r\n                forEachFunction(funcsToRun, function(funcToRun) {\r\n                    if (funcToRun.recurring) {\r\n                        reschedule(funcToRun);\r\n                    }\r\n                });\r\n\r\n                forEachFunction(funcsToRun, function(funcToRun) {\r\n                    funcToRun.funcToCall.apply(null, funcToRun.params || []);\r\n                });\r\n            } while (scheduledLookup.length > 0 &&\r\n            // checking first if we're out of time prevents setTimeout(0)\r\n            // scheduled in a funcToRun from forcing an extra iteration\r\n            currentTime !== endTime  &&\r\n            scheduledLookup[0] <= endTime);\r\n        }\r\n    }\r\n\r\n    return DelayedFunctionScheduler;\r\n}","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmineRequire.DelayedFunctionScheduler.[function].[return].[function].[return]","key":"reset","isClass":false,"containerType":"// Seen as: self\ninterface interface_798 {\n    removeFunctionWithId: (timeoutKey: any) => void;\n    scheduleFunction: (funcToCall: string | (() => any), millis: number, params: any, recurring: any, timeoutKey: number, newCurrentTime: string) => number;\n    tick: (millis: number, tickDate: (arg0: void) => void) => void;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.Spec.[function]","newFunction":"function(j$) {\r\n    function Spec(attrs) {\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.id = attrs.id;\r\n        this.description = attrs.description || '';\r\n        this.queueableFn = attrs.queueableFn;\r\n        this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n        this.userContext = attrs.userContext || function() { return {}; };\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n        this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n        this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n        this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        if (!this.queueableFn.fn) {\r\n            this.pend();\r\n        }\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: [],\r\n            passedExpectations: [],\r\n            pendingReason: ''\r\n        };\r\n    }\r\n\r\n    Spec.prototype.addExpectationResult = function(passed, data, isError) {\r\n        var expectationResult = this.expectationResultFactory(data);\r\n        if (passed) {\r\n            this.result.passedExpectations.push(expectationResult);\r\n        } else {\r\n            this.result.failedExpectations.push(expectationResult);\r\n\r\n            if (this.throwOnExpectationFailure && !isError) {\r\n                throw new j$.errors.ExpectationFailed();\r\n            }\r\n        }\r\n    };\r\n\r\n    Spec.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Spec.prototype.execute = function(onComplete, enabled) {\r\n        var self = this;\r\n\r\n        this.onStart(this);\r\n\r\n        if (!this.isExecutable() || this.markedPending || enabled === false) {\r\n            complete(enabled);\r\n            return;\r\n        }\r\n\r\n        var fns = this.beforeAndAfterFns();\r\n        var allFns = fns.befores.concat(this.queueableFn).concat(fns.afters);\r\n\r\n        this.queueRunnerFactory({\r\n            queueableFns: allFns,\r\n            onException: function() { self.onException.apply(self, arguments); },\r\n            onComplete: complete,\r\n            userContext: this.userContext()\r\n        });\r\n\r\n        function complete(enabledAgain) {\r\n            self.result.status = self.status(enabledAgain);\r\n            self.resultCallback(self.result);\r\n\r\n            if (onComplete) {\r\n                onComplete();\r\n            }\r\n        }\r\n    };\r\n\r\n    Spec.prototype.onException = function onException(e) {\r\n        if (Spec.isPendingSpecException(e)) {\r\n            this.pend(extractCustomPendingMessage(e));\r\n            return;\r\n        }\r\n\r\n        if (e instanceof j$.errors.ExpectationFailed) {\r\n            return;\r\n        }\r\n\r\n        this.addExpectationResult(false, {\r\n            matcherName: '',\r\n            passed: false,\r\n            expected: '',\r\n            actual: '',\r\n            error: e\r\n        }, true);\r\n    };\r\n\r\n    Spec.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Spec.prototype.pend = function(message) {\r\n        this.markedPending = true;\r\n        if (message) {\r\n            this.result.pendingReason = message;\r\n        }\r\n    };\r\n\r\n    Spec.prototype.getResult = function() {\r\n        this.result.status = this.status();\r\n        return this.result;\r\n    };\r\n\r\n    Spec.prototype.status = function(enabled) {\r\n        if (this.disabled || enabled === false) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.markedPending) {\r\n            return 'pending';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'passed';\r\n        }\r\n    };\r\n\r\n    Spec.prototype.isExecutable = function() {\r\n        return !this.disabled;\r\n    };\r\n\r\n    Spec.prototype.getFullName = function() {\r\n        return this.getSpecName(this);\r\n    };\r\n\r\n    var extractCustomPendingMessage = function(e) {\r\n        var fullMessage = e.toString(),\r\n            boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),\r\n            boilerplateEnd = boilerplateStart + Spec.pendingSpecExceptionMessage.length;\r\n\r\n        return fullMessage.substr(boilerplateEnd);\r\n    };\r\n\r\n    Spec.pendingSpecExceptionMessage = '=> marked Pending';\r\n\r\n    Spec.isPendingSpecException = function(e) {\r\n        return !!(e && e.toString && e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1);\r\n    };\r\n\r\n    return Spec;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.Spec.[function]","oldFunction":"function(j$) {\r\n    function Spec(attrs) {\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.id = attrs.id;\r\n        this.description = attrs.description || '';\r\n        this.queueableFn = attrs.queueableFn;\r\n        this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n        this.userContext = attrs.userContext || function() { return {}; };\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n        this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n        this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n        this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n\r\n        if (!this.queueableFn.fn) {\r\n            this.pend();\r\n        }\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: [],\r\n            passedExpectations: [],\r\n            pendingReason: ''\r\n        };\r\n    }\r\n\r\n    Spec.prototype.addExpectationResult = function(passed, data) {\r\n        var expectationResult = this.expectationResultFactory(data);\r\n        if (passed) {\r\n            this.result.passedExpectations.push(expectationResult);\r\n        } else {\r\n            this.result.failedExpectations.push(expectationResult);\r\n        }\r\n    };\r\n\r\n    Spec.prototype.expect = function(actual) {\r\n        return this.expectationFactory(actual, this);\r\n    };\r\n\r\n    Spec.prototype.execute = function(onComplete) {\r\n        var self = this;\r\n\r\n        this.onStart(this);\r\n\r\n        if (this.markedPending || this.disabled) {\r\n            complete();\r\n            return;\r\n        }\r\n\r\n        var fns = this.beforeAndAfterFns();\r\n        var allFns = fns.befores.concat(this.queueableFn).concat(fns.afters);\r\n\r\n        this.queueRunnerFactory({\r\n            queueableFns: allFns,\r\n            onException: function() { self.onException.apply(self, arguments); },\r\n            onComplete: complete,\r\n            userContext: this.userContext()\r\n        });\r\n\r\n        function complete() {\r\n            self.result.status = self.status();\r\n            self.resultCallback(self.result);\r\n\r\n            if (onComplete) {\r\n                onComplete();\r\n            }\r\n        }\r\n    };\r\n\r\n    Spec.prototype.onException = function onException(e) {\r\n        if (Spec.isPendingSpecException(e)) {\r\n            this.pend(extractCustomPendingMessage(e));\r\n            return;\r\n        }\r\n\r\n        this.addExpectationResult(false, {\r\n            matcherName: '',\r\n            passed: false,\r\n            expected: '',\r\n            actual: '',\r\n            error: e\r\n        });\r\n    };\r\n\r\n    Spec.prototype.disable = function() {\r\n        this.disabled = true;\r\n    };\r\n\r\n    Spec.prototype.pend = function(message) {\r\n        this.markedPending = true;\r\n        if (message) {\r\n            this.result.pendingReason = message;\r\n        }\r\n    };\r\n\r\n    Spec.prototype.status = function() {\r\n        if (this.disabled) {\r\n            return 'disabled';\r\n        }\r\n\r\n        if (this.markedPending) {\r\n            return 'pending';\r\n        }\r\n\r\n        if (this.result.failedExpectations.length > 0) {\r\n            return 'failed';\r\n        } else {\r\n            return 'passed';\r\n        }\r\n    };\r\n\r\n    Spec.prototype.isExecutable = function() {\r\n        return !this.disabled && !this.markedPending;\r\n    };\r\n\r\n    Spec.prototype.getFullName = function() {\r\n        return this.getSpecName(this);\r\n    };\r\n\r\n    var extractCustomPendingMessage = function(e) {\r\n        var fullMessage = e.toString(),\r\n            boilerplateStart = fullMessage.indexOf(Spec.pendingSpecExceptionMessage),\r\n            boilerplateEnd = boilerplateStart + Spec.pendingSpecExceptionMessage.length;\r\n\r\n        return fullMessage.substr(boilerplateEnd);\r\n    };\r\n\r\n    Spec.pendingSpecExceptionMessage = '=> marked Pending';\r\n\r\n    Spec.isPendingSpecException = function(e) {\r\n        return !!(e && e.toString && e.toString().indexOf(Spec.pendingSpecExceptionMessage) !== -1);\r\n    };\r\n\r\n    return Spec;\r\n}","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.Spec.[function].[return].[function].[arg0]","key":"throwOnExpectationFailure","newType":null,"isAny":true,"isClass":false,"containerType":"// Seen as: attrs\ninterface interface_909 {\n    beforeAndAfterFns: any;\n    catchingExceptions: any;\n    description: any;\n    expectationFactory: any;\n    expectationResultFactory: any;\n    getSpecName: any;\n    id: any;\n    onStart: any;\n    queueRunnerFactory: any;\n    queueableFn: {fn: any};\n    resultCallback: any;\n    throwOnExpectationFailure: any;\n    userContext: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.Clock.[function].[return]","newFunction":"function() {\r\n    function Clock(global, delayedFunctionSchedulerFactory, mockDate) {\r\n        var self = this,\r\n            realTimingFunctions = {\r\n                setTimeout: global.setTimeout,\r\n                clearTimeout: global.clearTimeout,\r\n                setInterval: global.setInterval,\r\n                clearInterval: global.clearInterval\r\n            },\r\n            fakeTimingFunctions = {\r\n                setTimeout: setTimeout,\r\n                clearTimeout: clearTimeout,\r\n                setInterval: setInterval,\r\n                clearInterval: clearInterval\r\n            },\r\n            installed = false,\r\n            delayedFunctionScheduler,\r\n            timer;\r\n\r\n\r\n        self.install = function() {\r\n            if(!originalTimingFunctionsIntact()) {\r\n                throw new Error('Jasmine Clock was unable to install over custom global timer functions. Is the clock already installed?');\r\n            }\r\n            replace(global, fakeTimingFunctions);\r\n            timer = fakeTimingFunctions;\r\n            delayedFunctionScheduler = delayedFunctionSchedulerFactory();\r\n            installed = true;\r\n\r\n            return self;\r\n        };\r\n\r\n        self.uninstall = function() {\r\n            delayedFunctionScheduler = null;\r\n            mockDate.uninstall();\r\n            replace(global, realTimingFunctions);\r\n\r\n            timer = realTimingFunctions;\r\n            installed = false;\r\n        };\r\n\r\n        self.withMock = function(closure) {\r\n            this.install();\r\n            try {\r\n                closure();\r\n            } finally {\r\n                this.uninstall();\r\n            }\r\n        };\r\n\r\n        self.mockDate = function(initialDate) {\r\n            mockDate.install(initialDate);\r\n        };\r\n\r\n        self.setTimeout = function(fn, delay, params) {\r\n            if (legacyIE()) {\r\n                if (arguments.length > 2) {\r\n                    throw new Error('IE < 9 cannot support extra params to setTimeout without a polyfill');\r\n                }\r\n                return timer.setTimeout(fn, delay);\r\n            }\r\n            return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);\r\n        };\r\n\r\n        self.setInterval = function(fn, delay, params) {\r\n            if (legacyIE()) {\r\n                if (arguments.length > 2) {\r\n                    throw new Error('IE < 9 cannot support extra params to setInterval without a polyfill');\r\n                }\r\n                return timer.setInterval(fn, delay);\r\n            }\r\n            return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);\r\n        };\r\n\r\n        self.clearTimeout = function(id) {\r\n            return Function.prototype.call.apply(timer.clearTimeout, [global, id]);\r\n        };\r\n\r\n        self.clearInterval = function(id) {\r\n            return Function.prototype.call.apply(timer.clearInterval, [global, id]);\r\n        };\r\n\r\n        self.tick = function(millis) {\r\n            if (installed) {\r\n                delayedFunctionScheduler.tick(millis, function(millis) { mockDate.tick(millis); });\r\n            } else {\r\n                throw new Error('Mock clock is not installed, use jasmine.clock().install()');\r\n            }\r\n        };\r\n\r\n        return self;\r\n\r\n        function originalTimingFunctionsIntact() {\r\n            return global.setTimeout === realTimingFunctions.setTimeout &&\r\n                global.clearTimeout === realTimingFunctions.clearTimeout &&\r\n                global.setInterval === realTimingFunctions.setInterval &&\r\n                global.clearInterval === realTimingFunctions.clearInterval;\r\n        }\r\n\r\n        function legacyIE() {\r\n            //if these methods are polyfilled, apply will be present\r\n            return !(realTimingFunctions.setTimeout || realTimingFunctions.setInterval).apply;\r\n        }\r\n\r\n        function replace(dest, source) {\r\n            for (var prop in source) {\r\n                dest[prop] = source[prop];\r\n            }\r\n        }\r\n\r\n        function setTimeout(fn, delay) {\r\n            return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));\r\n        }\r\n\r\n        function clearTimeout(id) {\r\n            return delayedFunctionScheduler.removeFunctionWithId(id);\r\n        }\r\n\r\n        function setInterval(fn, interval) {\r\n            return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);\r\n        }\r\n\r\n        function clearInterval(id) {\r\n            return delayedFunctionScheduler.removeFunctionWithId(id);\r\n        }\r\n\r\n        function argSlice(argsObj, n) {\r\n            return Array.prototype.slice.call(argsObj, n);\r\n        }\r\n    }\r\n\r\n    return Clock;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.Clock.[function].[return]","oldFunction":"function() {\r\n    function Clock(global, delayedFunctionScheduler, mockDate) {\r\n        var self = this,\r\n            realTimingFunctions = {\r\n                setTimeout: global.setTimeout,\r\n                clearTimeout: global.clearTimeout,\r\n                setInterval: global.setInterval,\r\n                clearInterval: global.clearInterval\r\n            },\r\n            fakeTimingFunctions = {\r\n                setTimeout: setTimeout,\r\n                clearTimeout: clearTimeout,\r\n                setInterval: setInterval,\r\n                clearInterval: clearInterval\r\n            },\r\n            installed = false,\r\n            timer;\r\n\r\n\r\n        self.install = function() {\r\n            replace(global, fakeTimingFunctions);\r\n            timer = fakeTimingFunctions;\r\n            installed = true;\r\n\r\n            return self;\r\n        };\r\n\r\n        self.uninstall = function() {\r\n            delayedFunctionScheduler.reset();\r\n            mockDate.uninstall();\r\n            replace(global, realTimingFunctions);\r\n\r\n            timer = realTimingFunctions;\r\n            installed = false;\r\n        };\r\n\r\n        self.mockDate = function(initialDate) {\r\n            mockDate.install(initialDate);\r\n        };\r\n\r\n        self.setTimeout = function(fn, delay, params) {\r\n            if (legacyIE()) {\r\n                if (arguments.length > 2) {\r\n                    throw new Error('IE < 9 cannot support extra params to setTimeout without a polyfill');\r\n                }\r\n                return timer.setTimeout(fn, delay);\r\n            }\r\n            return Function.prototype.apply.apply(timer.setTimeout, [global, arguments]);\r\n        };\r\n\r\n        self.setInterval = function(fn, delay, params) {\r\n            if (legacyIE()) {\r\n                if (arguments.length > 2) {\r\n                    throw new Error('IE < 9 cannot support extra params to setInterval without a polyfill');\r\n                }\r\n                return timer.setInterval(fn, delay);\r\n            }\r\n            return Function.prototype.apply.apply(timer.setInterval, [global, arguments]);\r\n        };\r\n\r\n        self.clearTimeout = function(id) {\r\n            return Function.prototype.call.apply(timer.clearTimeout, [global, id]);\r\n        };\r\n\r\n        self.clearInterval = function(id) {\r\n            return Function.prototype.call.apply(timer.clearInterval, [global, id]);\r\n        };\r\n\r\n        self.tick = function(millis) {\r\n            if (installed) {\r\n                mockDate.tick(millis);\r\n                delayedFunctionScheduler.tick(millis);\r\n            } else {\r\n                throw new Error('Mock clock is not installed, use jasmine.clock().install()');\r\n            }\r\n        };\r\n\r\n        return self;\r\n\r\n        function legacyIE() {\r\n            //if these methods are polyfilled, apply will be present\r\n            return !(realTimingFunctions.setTimeout || realTimingFunctions.setInterval).apply;\r\n        }\r\n\r\n        function replace(dest, source) {\r\n            for (var prop in source) {\r\n                dest[prop] = source[prop];\r\n            }\r\n        }\r\n\r\n        function setTimeout(fn, delay) {\r\n            return delayedFunctionScheduler.scheduleFunction(fn, delay, argSlice(arguments, 2));\r\n        }\r\n\r\n        function clearTimeout(id) {\r\n            return delayedFunctionScheduler.removeFunctionWithId(id);\r\n        }\r\n\r\n        function setInterval(fn, interval) {\r\n            return delayedFunctionScheduler.scheduleFunction(fn, interval, argSlice(arguments, 2), true);\r\n        }\r\n\r\n        function clearInterval(id) {\r\n            return delayedFunctionScheduler.removeFunctionWithId(id);\r\n        }\r\n\r\n        function argSlice(argsObj, n) {\r\n            return Array.prototype.slice.call(argsObj, n);\r\n        }\r\n    }\r\n\r\n    return Clock;\r\n}","oldJSDoc":null,"type":"changedType","typePath":"window.jasmineRequire.Clock.[function].[return].[function].[arg1]","newType":"() => void","oldType":"// Seen as: delayedFunctionScheduler\ninterface interface_773 {\n    removeFunctionWithId: (arg0: void) => void;\n    reset: () => void;\n    scheduleFunction: (arg0: void, arg1: void, arg2: void, arg3: void) => void;\n    tick: (arg0: void) => void;\n}\n\n","containerType":"(global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.ReportDispatcher.[function]","newFunction":"function() {\r\n    function ReportDispatcher(methods) {\r\n\r\n        var dispatchedMethods = methods || [];\r\n\r\n        for (var i = 0; i < dispatchedMethods.length; i++) {\r\n            var method = dispatchedMethods[i];\r\n            this[method] = (function(m) {\r\n                return function() {\r\n                    dispatch(m, arguments);\r\n                };\r\n            }(method));\r\n        }\r\n\r\n        var reporters = [];\r\n        var fallbackReporter = null;\r\n\r\n        this.addReporter = function(reporter) {\r\n            reporters.push(reporter);\r\n        };\r\n\r\n        this.provideFallbackReporter = function(reporter) {\r\n            fallbackReporter = reporter;\r\n        };\r\n\r\n\r\n        return this;\r\n\r\n        function dispatch(method, args) {\r\n            if (reporters.length === 0 && fallbackReporter !== null) {\r\n                reporters.push(fallbackReporter);\r\n            }\r\n            for (var i = 0; i < reporters.length; i++) {\r\n                var reporter = reporters[i];\r\n                if (reporter[method]) {\r\n                    reporter[method].apply(reporter, args);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return ReportDispatcher;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.ReportDispatcher.[function]","oldFunction":"function() {\r\n    function ReportDispatcher(methods) {\r\n\r\n        var dispatchedMethods = methods || [];\r\n\r\n        for (var i = 0; i < dispatchedMethods.length; i++) {\r\n            var method = dispatchedMethods[i];\r\n            this[method] = (function(m) {\r\n                return function() {\r\n                    dispatch(m, arguments);\r\n                };\r\n            }(method));\r\n        }\r\n\r\n        var reporters = [];\r\n\r\n        this.addReporter = function(reporter) {\r\n            reporters.push(reporter);\r\n        };\r\n\r\n        return this;\r\n\r\n        function dispatch(method, args) {\r\n            for (var i = 0; i < reporters.length; i++) {\r\n                var reporter = reporters[i];\r\n                if (reporter[method]) {\r\n                    reporter[method].apply(reporter, args);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return ReportDispatcher;\r\n}","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.ReportDispatcher.[function].[return].[function].[return]","key":"provideFallbackReporter","newType":"(fallbackReporter: any) => void","isAny":false,"isClass":false,"containerType":"interface interface_545 {\n    addReporter: (reporter: any) => void;\n    provideFallbackReporter: (fallbackReporter: any) => void;\n}\n\n","containerDescription":"interface"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.HtmlReporter.[function].[return]","newFunction":"function(j$) {\r\n\r\n    var noopTimer = {\r\n        start: function() {},\r\n        elapsed: function() { return 0; }\r\n    };\r\n\r\n    function HtmlReporter(options) {\r\n        var env = options.env || {},\r\n            getContainer = options.getContainer,\r\n            createElement = options.createElement,\r\n            createTextNode = options.createTextNode,\r\n            onRaiseExceptionsClick = options.onRaiseExceptionsClick || function() {},\r\n            onThrowExpectationsClick = options.onThrowExpectationsClick || function() {},\r\n            onRandomClick = options.onRandomClick || function() {},\r\n            addToExistingQueryString = options.addToExistingQueryString || defaultQueryString,\r\n            timer = options.timer || noopTimer,\r\n            results = [],\r\n            specsExecuted = 0,\r\n            failureCount = 0,\r\n            pendingSpecCount = 0,\r\n            htmlReporterMain,\r\n            symbols,\r\n            failedSuites = [];\r\n\r\n        this.initialize = function() {\r\n            clearPrior();\r\n            htmlReporterMain = createDom('div', {className: 'jasmine_html-reporter'},\r\n                createDom('div', {className: 'jasmine-banner'},\r\n                    createDom('a', {className: 'jasmine-title', href: 'http://jasmine.github.io/', target: '_blank'}),\r\n                    createDom('span', {className: 'jasmine-version'}, j$.version)\r\n                ),\r\n                createDom('ul', {className: 'jasmine-symbol-summary'}),\r\n                createDom('div', {className: 'jasmine-alert'}),\r\n                createDom('div', {className: 'jasmine-results'},\r\n                    createDom('div', {className: 'jasmine-failures'})\r\n                )\r\n            );\r\n            getContainer().appendChild(htmlReporterMain);\r\n        };\r\n\r\n        var totalSpecsDefined;\r\n        this.jasmineStarted = function(options) {\r\n            totalSpecsDefined = options.totalSpecsDefined || 0;\r\n            timer.start();\r\n        };\r\n\r\n        var summary = createDom('div', {className: 'jasmine-summary'});\r\n\r\n        var topResults = new j$.ResultsNode({}, '', null),\r\n            currentParent = topResults;\r\n\r\n        this.suiteStarted = function(result) {\r\n            currentParent.addChild(result, 'suite');\r\n            currentParent = currentParent.last();\r\n        };\r\n\r\n        this.suiteDone = function(result) {\r\n            if (result.status == 'failed') {\r\n                failedSuites.push(result);\r\n            }\r\n\r\n            if (currentParent == topResults) {\r\n                return;\r\n            }\r\n\r\n            currentParent = currentParent.parent;\r\n        };\r\n\r\n        this.specStarted = function(result) {\r\n            currentParent.addChild(result, 'spec');\r\n        };\r\n\r\n        var failures = [];\r\n        this.specDone = function(result) {\r\n            if(noExpectations(result) && typeof console !== 'undefined' && typeof console.error !== 'undefined') {\r\n                console.error('Spec \\'' + result.fullName + '\\' has no expectations.');\r\n            }\r\n\r\n            if (result.status != 'disabled') {\r\n                specsExecuted++;\r\n            }\r\n\r\n            if (!symbols){\r\n                symbols = find('.jasmine-symbol-summary');\r\n            }\r\n\r\n            symbols.appendChild(createDom('li', {\r\n                    className: noExpectations(result) ? 'jasmine-empty' : 'jasmine-' + result.status,\r\n                    id: 'spec_' + result.id,\r\n                    title: result.fullName\r\n                }\r\n            ));\r\n\r\n            if (result.status == 'failed') {\r\n                failureCount++;\r\n\r\n                var failure =\r\n                    createDom('div', {className: 'jasmine-spec-detail jasmine-failed'},\r\n                        createDom('div', {className: 'jasmine-description'},\r\n                            createDom('a', {title: result.fullName, href: specHref(result)}, result.fullName)\r\n                        ),\r\n                        createDom('div', {className: 'jasmine-messages'})\r\n                    );\r\n                var messages = failure.childNodes[1];\r\n\r\n                for (var i = 0; i < result.failedExpectations.length; i++) {\r\n                    var expectation = result.failedExpectations[i];\r\n                    messages.appendChild(createDom('div', {className: 'jasmine-result-message'}, expectation.message));\r\n                    messages.appendChild(createDom('div', {className: 'jasmine-stack-trace'}, expectation.stack));\r\n                }\r\n\r\n                failures.push(failure);\r\n            }\r\n\r\n            if (result.status == 'pending') {\r\n                pendingSpecCount++;\r\n            }\r\n        };\r\n\r\n        this.jasmineDone = function(doneResult) {\r\n            var banner = find('.jasmine-banner');\r\n            var alert = find('.jasmine-alert');\r\n            var order = doneResult && doneResult.order;\r\n            alert.appendChild(createDom('span', {className: 'jasmine-duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));\r\n\r\n            banner.appendChild(\r\n                createDom('div', { className: 'jasmine-run-options' },\r\n                    createDom('span', { className: 'jasmine-trigger' }, 'Options'),\r\n                    createDom('div', { className: 'jasmine-payload' },\r\n                        createDom('div', { className: 'jasmine-exceptions' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-raise',\r\n                                id: 'jasmine-raise-exceptions',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-raise-exceptions' }, 'raise exceptions')),\r\n                        createDom('div', { className: 'jasmine-throw-failures' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-throw',\r\n                                id: 'jasmine-throw-failures',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-throw-failures' }, 'stop spec on expectation failure')),\r\n                        createDom('div', { className: 'jasmine-random-order' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-random',\r\n                                id: 'jasmine-random-order',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-random-order' }, 'run tests in random order'))\r\n                    )\r\n                ));\r\n\r\n            var raiseCheckbox = find('#jasmine-raise-exceptions');\r\n\r\n            raiseCheckbox.checked = !env.catchingExceptions();\r\n            raiseCheckbox.onclick = onRaiseExceptionsClick;\r\n\r\n            var throwCheckbox = find('#jasmine-throw-failures');\r\n            throwCheckbox.checked = env.throwingExpectationFailures();\r\n            throwCheckbox.onclick = onThrowExpectationsClick;\r\n\r\n            var randomCheckbox = find('#jasmine-random-order');\r\n            randomCheckbox.checked = env.randomTests();\r\n            randomCheckbox.onclick = onRandomClick;\r\n\r\n            var optionsMenu = find('.jasmine-run-options'),\r\n                optionsTrigger = optionsMenu.querySelector('.jasmine-trigger'),\r\n                optionsPayload = optionsMenu.querySelector('.jasmine-payload'),\r\n                isOpen = /\\bjasmine-open\\b/;\r\n\r\n            optionsTrigger.onclick = function() {\r\n                if (isOpen.test(optionsPayload.className)) {\r\n                    optionsPayload.className = optionsPayload.className.replace(isOpen, '');\r\n                } else {\r\n                    optionsPayload.className += ' jasmine-open';\r\n                }\r\n            };\r\n\r\n            if (specsExecuted < totalSpecsDefined) {\r\n                var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';\r\n                var skippedLink = order && order.random ? '?random=true' : '?';\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-bar jasmine-skipped'},\r\n                        createDom('a', {href: skippedLink, title: 'Run all specs'}, skippedMessage)\r\n                    )\r\n                );\r\n            }\r\n            var statusBarMessage = '';\r\n            var statusBarClassName = 'jasmine-bar ';\r\n\r\n            if (totalSpecsDefined > 0) {\r\n                statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);\r\n                if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }\r\n                statusBarClassName += (failureCount > 0) ? 'jasmine-failed' : 'jasmine-passed';\r\n            } else {\r\n                statusBarClassName += 'jasmine-skipped';\r\n                statusBarMessage += 'No specs found';\r\n            }\r\n\r\n            var seedBar;\r\n            if (order && order.random) {\r\n                seedBar = createDom('span', {className: 'jasmine-seed-bar'},\r\n                    ', randomized with seed ',\r\n                    createDom('a', {title: 'randomized with seed ' + order.seed, href: seedHref(order.seed)}, order.seed)\r\n                );\r\n            }\r\n\r\n            alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage, seedBar));\r\n\r\n            var errorBarClassName = 'jasmine-bar jasmine-errored';\r\n            var errorBarMessagePrefix = 'AfterAll ';\r\n\r\n            for(var i = 0; i < failedSuites.length; i++) {\r\n                var failedSuite = failedSuites[i];\r\n                for(var j = 0; j < failedSuite.failedExpectations.length; j++) {\r\n                    alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessagePrefix + failedSuite.failedExpectations[j].message));\r\n                }\r\n            }\r\n\r\n            var globalFailures = (doneResult && doneResult.failedExpectations) || [];\r\n            for(i = 0; i < globalFailures.length; i++) {\r\n                var failure = globalFailures[i];\r\n                alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessagePrefix + failure.message));\r\n            }\r\n\r\n            var results = find('.jasmine-results');\r\n            results.appendChild(summary);\r\n\r\n            summaryList(topResults, summary);\r\n\r\n            function summaryList(resultsTree, domParent) {\r\n                var specListNode;\r\n                for (var i = 0; i < resultsTree.children.length; i++) {\r\n                    var resultNode = resultsTree.children[i];\r\n                    if (resultNode.type == 'suite') {\r\n                        var suiteListNode = createDom('ul', {className: 'jasmine-suite', id: 'suite-' + resultNode.result.id},\r\n                            createDom('li', {className: 'jasmine-suite-detail'},\r\n                                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)\r\n                            )\r\n                        );\r\n\r\n                        summaryList(resultNode, suiteListNode);\r\n                        domParent.appendChild(suiteListNode);\r\n                    }\r\n                    if (resultNode.type == 'spec') {\r\n                        if (domParent.getAttribute('class') != 'jasmine-specs') {\r\n                            specListNode = createDom('ul', {className: 'jasmine-specs'});\r\n                            domParent.appendChild(specListNode);\r\n                        }\r\n                        var specDescription = resultNode.result.description;\r\n                        if(noExpectations(resultNode.result)) {\r\n                            specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;\r\n                        }\r\n                        if(resultNode.result.status === 'pending' && resultNode.result.pendingReason !== '') {\r\n                            specDescription = specDescription + ' PENDING WITH MESSAGE: ' + resultNode.result.pendingReason;\r\n                        }\r\n                        specListNode.appendChild(\r\n                            createDom('li', {\r\n                                    className: 'jasmine-' + resultNode.result.status,\r\n                                    id: 'spec-' + resultNode.result.id\r\n                                },\r\n                                createDom('a', {href: specHref(resultNode.result)}, specDescription)\r\n                            )\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (failures.length) {\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-spec-list'},\r\n                        createDom('span', {}, 'Spec List | '),\r\n                        createDom('a', {className: 'jasmine-failures-menu', href: '#'}, 'Failures')));\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-failure-list'},\r\n                        createDom('a', {className: 'jasmine-spec-list-menu', href: '#'}, 'Spec List'),\r\n                        createDom('span', {}, ' | Failures ')));\r\n\r\n                find('.jasmine-failures-menu').onclick = function() {\r\n                    setMenuModeTo('jasmine-failure-list');\r\n                };\r\n                find('.jasmine-spec-list-menu').onclick = function() {\r\n                    setMenuModeTo('jasmine-spec-list');\r\n                };\r\n\r\n                setMenuModeTo('jasmine-failure-list');\r\n\r\n                var failureNode = find('.jasmine-failures');\r\n                for (i = 0; i < failures.length; i++) {\r\n                    failureNode.appendChild(failures[i]);\r\n                }\r\n            }\r\n        };\r\n\r\n        return this;\r\n\r\n        function find(selector) {\r\n            return getContainer().querySelector('.jasmine_html-reporter ' + selector);\r\n        }\r\n\r\n        function clearPrior() {\r\n            // return the reporter\r\n            var oldReporter = find('');\r\n\r\n            if(oldReporter) {\r\n                getContainer().removeChild(oldReporter);\r\n            }\r\n        }\r\n\r\n        function createDom(type, attrs, childrenVarArgs) {\r\n            var el = createElement(type);\r\n\r\n            for (var i = 2; i < arguments.length; i++) {\r\n                var child = arguments[i];\r\n\r\n                if (typeof child === 'string') {\r\n                    el.appendChild(createTextNode(child));\r\n                } else {\r\n                    if (child) {\r\n                        el.appendChild(child);\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (var attr in attrs) {\r\n                if (attr == 'className') {\r\n                    el[attr] = attrs[attr];\r\n                } else {\r\n                    el.setAttribute(attr, attrs[attr]);\r\n                }\r\n            }\r\n\r\n            return el;\r\n        }\r\n\r\n        function pluralize(singular, count) {\r\n            var word = (count == 1 ? singular : singular + 's');\r\n\r\n            return '' + count + ' ' + word;\r\n        }\r\n\r\n        function specHref(result) {\r\n            return addToExistingQueryString('spec', result.fullName);\r\n        }\r\n\r\n        function seedHref(seed) {\r\n            return addToExistingQueryString('seed', seed);\r\n        }\r\n\r\n        function defaultQueryString(key, value) {\r\n            return '?' + key + '=' + value;\r\n        }\r\n\r\n        function setMenuModeTo(mode) {\r\n            htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);\r\n        }\r\n\r\n        function noExpectations(result) {\r\n            return (result.failedExpectations.length + result.passedExpectations.length) === 0 &&\r\n                result.status === 'passed';\r\n        }\r\n    }\r\n\r\n    return HtmlReporter;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.HtmlReporter.[function].[return]","oldFunction":"function(j$) {\r\n\r\n    var noopTimer = {\r\n        start: function() {},\r\n        elapsed: function() { return 0; }\r\n    };\r\n\r\n    function HtmlReporter(options) {\r\n        var env = options.env || {},\r\n            getContainer = options.getContainer,\r\n            createElement = options.createElement,\r\n            createTextNode = options.createTextNode,\r\n            onRaiseExceptionsClick = options.onRaiseExceptionsClick || function() {},\r\n            addToExistingQueryString = options.addToExistingQueryString || defaultQueryString,\r\n            timer = options.timer || noopTimer,\r\n            results = [],\r\n            specsExecuted = 0,\r\n            failureCount = 0,\r\n            pendingSpecCount = 0,\r\n            htmlReporterMain,\r\n            symbols,\r\n            failedSuites = [];\r\n\r\n        this.initialize = function() {\r\n            clearPrior();\r\n            htmlReporterMain = createDom('div', {className: 'jasmine_html-reporter'},\r\n                createDom('div', {className: 'banner'},\r\n                    createDom('a', {className: 'title', href: 'http://jasmine.github.io/', target: '_blank'}),\r\n                    createDom('span', {className: 'version'}, j$.version)\r\n                ),\r\n                createDom('ul', {className: 'symbol-summary'}),\r\n                createDom('div', {className: 'alert'}),\r\n                createDom('div', {className: 'results'},\r\n                    createDom('div', {className: 'failures'})\r\n                )\r\n            );\r\n            getContainer().appendChild(htmlReporterMain);\r\n\r\n            symbols = find('.symbol-summary');\r\n        };\r\n\r\n        var totalSpecsDefined;\r\n        this.jasmineStarted = function(options) {\r\n            totalSpecsDefined = options.totalSpecsDefined || 0;\r\n            timer.start();\r\n        };\r\n\r\n        var summary = createDom('div', {className: 'summary'});\r\n\r\n        var topResults = new j$.ResultsNode({}, '', null),\r\n            currentParent = topResults;\r\n\r\n        this.suiteStarted = function(result) {\r\n            currentParent.addChild(result, 'suite');\r\n            currentParent = currentParent.last();\r\n        };\r\n\r\n        this.suiteDone = function(result) {\r\n            if (result.status == 'failed') {\r\n                failedSuites.push(result);\r\n            }\r\n\r\n            if (currentParent == topResults) {\r\n                return;\r\n            }\r\n\r\n            currentParent = currentParent.parent;\r\n        };\r\n\r\n        this.specStarted = function(result) {\r\n            currentParent.addChild(result, 'spec');\r\n        };\r\n\r\n        var failures = [];\r\n        this.specDone = function(result) {\r\n            if(noExpectations(result) && typeof console !== 'undefined' && typeof console.error !== 'undefined') {\r\n                console.error('Spec \\'' + result.fullName + '\\' has no expectations.');\r\n            }\r\n\r\n            if (result.status != 'disabled') {\r\n                specsExecuted++;\r\n            }\r\n\r\n            symbols.appendChild(createDom('li', {\r\n                    className: noExpectations(result) ? 'empty' : result.status,\r\n                    id: 'spec_' + result.id,\r\n                    title: result.fullName\r\n                }\r\n            ));\r\n\r\n            if (result.status == 'failed') {\r\n                failureCount++;\r\n\r\n                var failure =\r\n                    createDom('div', {className: 'spec-detail failed'},\r\n                        createDom('div', {className: 'description'},\r\n                            createDom('a', {title: result.fullName, href: specHref(result)}, result.fullName)\r\n                        ),\r\n                        createDom('div', {className: 'messages'})\r\n                    );\r\n                var messages = failure.childNodes[1];\r\n\r\n                for (var i = 0; i < result.failedExpectations.length; i++) {\r\n                    var expectation = result.failedExpectations[i];\r\n                    messages.appendChild(createDom('div', {className: 'result-message'}, expectation.message));\r\n                    messages.appendChild(createDom('div', {className: 'stack-trace'}, expectation.stack));\r\n                }\r\n\r\n                failures.push(failure);\r\n            }\r\n\r\n            if (result.status == 'pending') {\r\n                pendingSpecCount++;\r\n            }\r\n        };\r\n\r\n        this.jasmineDone = function() {\r\n            var banner = find('.banner');\r\n            banner.appendChild(createDom('span', {className: 'duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));\r\n\r\n            var alert = find('.alert');\r\n\r\n            alert.appendChild(createDom('span', { className: 'exceptions' },\r\n                createDom('label', { className: 'label', 'for': 'raise-exceptions' }, 'raise exceptions'),\r\n                createDom('input', {\r\n                    className: 'raise',\r\n                    id: 'raise-exceptions',\r\n                    type: 'checkbox'\r\n                })\r\n            ));\r\n            var checkbox = find('#raise-exceptions');\r\n\r\n            checkbox.checked = !env.catchingExceptions();\r\n            checkbox.onclick = onRaiseExceptionsClick;\r\n\r\n            if (specsExecuted < totalSpecsDefined) {\r\n                var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'bar skipped'},\r\n                        createDom('a', {href: '?', title: 'Run all specs'}, skippedMessage)\r\n                    )\r\n                );\r\n            }\r\n            var statusBarMessage = '';\r\n            var statusBarClassName = 'bar ';\r\n\r\n            if (totalSpecsDefined > 0) {\r\n                statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);\r\n                if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }\r\n                statusBarClassName += (failureCount > 0) ? 'failed' : 'passed';\r\n            } else {\r\n                statusBarClassName += 'skipped';\r\n                statusBarMessage += 'No specs found';\r\n            }\r\n\r\n            alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage));\r\n\r\n            for(i = 0; i < failedSuites.length; i++) {\r\n                var failedSuite = failedSuites[i];\r\n                for(var j = 0; j < failedSuite.failedExpectations.length; j++) {\r\n                    var errorBarMessage = 'AfterAll ' + failedSuite.failedExpectations[j].message;\r\n                    var errorBarClassName = 'bar errored';\r\n                    alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessage));\r\n                }\r\n            }\r\n\r\n            var results = find('.results');\r\n            results.appendChild(summary);\r\n\r\n            summaryList(topResults, summary);\r\n\r\n            function summaryList(resultsTree, domParent) {\r\n                var specListNode;\r\n                for (var i = 0; i < resultsTree.children.length; i++) {\r\n                    var resultNode = resultsTree.children[i];\r\n                    if (resultNode.type == 'suite') {\r\n                        var suiteListNode = createDom('ul', {className: 'suite', id: 'suite-' + resultNode.result.id},\r\n                            createDom('li', {className: 'suite-detail'},\r\n                                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)\r\n                            )\r\n                        );\r\n\r\n                        summaryList(resultNode, suiteListNode);\r\n                        domParent.appendChild(suiteListNode);\r\n                    }\r\n                    if (resultNode.type == 'spec') {\r\n                        if (domParent.getAttribute('class') != 'specs') {\r\n                            specListNode = createDom('ul', {className: 'specs'});\r\n                            domParent.appendChild(specListNode);\r\n                        }\r\n                        var specDescription = resultNode.result.description;\r\n                        if(noExpectations(resultNode.result)) {\r\n                            specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;\r\n                        }\r\n                        if(resultNode.result.status === 'pending' && resultNode.result.pendingReason !== '') {\r\n                            specDescription = specDescription + ' PENDING WITH MESSAGE: ' + resultNode.result.pendingReason;\r\n                        }\r\n                        specListNode.appendChild(\r\n                            createDom('li', {\r\n                                    className: resultNode.result.status,\r\n                                    id: 'spec-' + resultNode.result.id\r\n                                },\r\n                                createDom('a', {href: specHref(resultNode.result)}, specDescription)\r\n                            )\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (failures.length) {\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'menu bar spec-list'},\r\n                        createDom('span', {}, 'Spec List | '),\r\n                        createDom('a', {className: 'failures-menu', href: '#'}, 'Failures')));\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'menu bar failure-list'},\r\n                        createDom('a', {className: 'spec-list-menu', href: '#'}, 'Spec List'),\r\n                        createDom('span', {}, ' | Failures ')));\r\n\r\n                find('.failures-menu').onclick = function() {\r\n                    setMenuModeTo('failure-list');\r\n                };\r\n                find('.spec-list-menu').onclick = function() {\r\n                    setMenuModeTo('spec-list');\r\n                };\r\n\r\n                setMenuModeTo('failure-list');\r\n\r\n                var failureNode = find('.failures');\r\n                for (var i = 0; i < failures.length; i++) {\r\n                    failureNode.appendChild(failures[i]);\r\n                }\r\n            }\r\n        };\r\n\r\n        return this;\r\n\r\n        function find(selector) {\r\n            return getContainer().querySelector('.jasmine_html-reporter ' + selector);\r\n        }\r\n\r\n        function clearPrior() {\r\n            // return the reporter\r\n            var oldReporter = find('');\r\n\r\n            if(oldReporter) {\r\n                getContainer().removeChild(oldReporter);\r\n            }\r\n        }\r\n\r\n        function createDom(type, attrs, childrenVarArgs) {\r\n            var el = createElement(type);\r\n\r\n            for (var i = 2; i < arguments.length; i++) {\r\n                var child = arguments[i];\r\n\r\n                if (typeof child === 'string') {\r\n                    el.appendChild(createTextNode(child));\r\n                } else {\r\n                    if (child) {\r\n                        el.appendChild(child);\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (var attr in attrs) {\r\n                if (attr == 'className') {\r\n                    el[attr] = attrs[attr];\r\n                } else {\r\n                    el.setAttribute(attr, attrs[attr]);\r\n                }\r\n            }\r\n\r\n            return el;\r\n        }\r\n\r\n        function pluralize(singular, count) {\r\n            var word = (count == 1 ? singular : singular + 's');\r\n\r\n            return '' + count + ' ' + word;\r\n        }\r\n\r\n        function specHref(result) {\r\n            return addToExistingQueryString('spec', result.fullName);\r\n        }\r\n\r\n        function defaultQueryString(key, value) {\r\n            return '?' + key + '=' + value;\r\n        }\r\n\r\n        function setMenuModeTo(mode) {\r\n            htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);\r\n        }\r\n\r\n        function noExpectations(result) {\r\n            return (result.failedExpectations.length + result.passedExpectations.length) === 0 &&\r\n                result.status === 'passed';\r\n        }\r\n    }\r\n\r\n    return HtmlReporter;\r\n}","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.HtmlReporter.[function].[return].[function].[arg0]","key":"onRandomClick","newType":null,"isAny":true,"isClass":false,"containerType":"// Seen as: options\ninterface interface_807 {\n    addToExistingQueryString: any;\n    createElement: (arg0: void) => void;\n    createTextNode: (arg0: void) => void;\n    env: any;\n    getContainer: () => void;\n    onRaiseExceptionsClick: any;\n    onRandomClick: any;\n    onThrowExpectationsClick: any;\n    timer: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.HtmlReporter.[function].[return]","newFunction":"function(j$) {\r\n\r\n    var noopTimer = {\r\n        start: function() {},\r\n        elapsed: function() { return 0; }\r\n    };\r\n\r\n    function HtmlReporter(options) {\r\n        var env = options.env || {},\r\n            getContainer = options.getContainer,\r\n            createElement = options.createElement,\r\n            createTextNode = options.createTextNode,\r\n            onRaiseExceptionsClick = options.onRaiseExceptionsClick || function() {},\r\n            onThrowExpectationsClick = options.onThrowExpectationsClick || function() {},\r\n            onRandomClick = options.onRandomClick || function() {},\r\n            addToExistingQueryString = options.addToExistingQueryString || defaultQueryString,\r\n            timer = options.timer || noopTimer,\r\n            results = [],\r\n            specsExecuted = 0,\r\n            failureCount = 0,\r\n            pendingSpecCount = 0,\r\n            htmlReporterMain,\r\n            symbols,\r\n            failedSuites = [];\r\n\r\n        this.initialize = function() {\r\n            clearPrior();\r\n            htmlReporterMain = createDom('div', {className: 'jasmine_html-reporter'},\r\n                createDom('div', {className: 'jasmine-banner'},\r\n                    createDom('a', {className: 'jasmine-title', href: 'http://jasmine.github.io/', target: '_blank'}),\r\n                    createDom('span', {className: 'jasmine-version'}, j$.version)\r\n                ),\r\n                createDom('ul', {className: 'jasmine-symbol-summary'}),\r\n                createDom('div', {className: 'jasmine-alert'}),\r\n                createDom('div', {className: 'jasmine-results'},\r\n                    createDom('div', {className: 'jasmine-failures'})\r\n                )\r\n            );\r\n            getContainer().appendChild(htmlReporterMain);\r\n        };\r\n\r\n        var totalSpecsDefined;\r\n        this.jasmineStarted = function(options) {\r\n            totalSpecsDefined = options.totalSpecsDefined || 0;\r\n            timer.start();\r\n        };\r\n\r\n        var summary = createDom('div', {className: 'jasmine-summary'});\r\n\r\n        var topResults = new j$.ResultsNode({}, '', null),\r\n            currentParent = topResults;\r\n\r\n        this.suiteStarted = function(result) {\r\n            currentParent.addChild(result, 'suite');\r\n            currentParent = currentParent.last();\r\n        };\r\n\r\n        this.suiteDone = function(result) {\r\n            if (result.status == 'failed') {\r\n                failedSuites.push(result);\r\n            }\r\n\r\n            if (currentParent == topResults) {\r\n                return;\r\n            }\r\n\r\n            currentParent = currentParent.parent;\r\n        };\r\n\r\n        this.specStarted = function(result) {\r\n            currentParent.addChild(result, 'spec');\r\n        };\r\n\r\n        var failures = [];\r\n        this.specDone = function(result) {\r\n            if(noExpectations(result) && typeof console !== 'undefined' && typeof console.error !== 'undefined') {\r\n                console.error('Spec \\'' + result.fullName + '\\' has no expectations.');\r\n            }\r\n\r\n            if (result.status != 'disabled') {\r\n                specsExecuted++;\r\n            }\r\n\r\n            if (!symbols){\r\n                symbols = find('.jasmine-symbol-summary');\r\n            }\r\n\r\n            symbols.appendChild(createDom('li', {\r\n                    className: noExpectations(result) ? 'jasmine-empty' : 'jasmine-' + result.status,\r\n                    id: 'spec_' + result.id,\r\n                    title: result.fullName\r\n                }\r\n            ));\r\n\r\n            if (result.status == 'failed') {\r\n                failureCount++;\r\n\r\n                var failure =\r\n                    createDom('div', {className: 'jasmine-spec-detail jasmine-failed'},\r\n                        createDom('div', {className: 'jasmine-description'},\r\n                            createDom('a', {title: result.fullName, href: specHref(result)}, result.fullName)\r\n                        ),\r\n                        createDom('div', {className: 'jasmine-messages'})\r\n                    );\r\n                var messages = failure.childNodes[1];\r\n\r\n                for (var i = 0; i < result.failedExpectations.length; i++) {\r\n                    var expectation = result.failedExpectations[i];\r\n                    messages.appendChild(createDom('div', {className: 'jasmine-result-message'}, expectation.message));\r\n                    messages.appendChild(createDom('div', {className: 'jasmine-stack-trace'}, expectation.stack));\r\n                }\r\n\r\n                failures.push(failure);\r\n            }\r\n\r\n            if (result.status == 'pending') {\r\n                pendingSpecCount++;\r\n            }\r\n        };\r\n\r\n        this.jasmineDone = function(doneResult) {\r\n            var banner = find('.jasmine-banner');\r\n            var alert = find('.jasmine-alert');\r\n            var order = doneResult && doneResult.order;\r\n            alert.appendChild(createDom('span', {className: 'jasmine-duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));\r\n\r\n            banner.appendChild(\r\n                createDom('div', { className: 'jasmine-run-options' },\r\n                    createDom('span', { className: 'jasmine-trigger' }, 'Options'),\r\n                    createDom('div', { className: 'jasmine-payload' },\r\n                        createDom('div', { className: 'jasmine-exceptions' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-raise',\r\n                                id: 'jasmine-raise-exceptions',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-raise-exceptions' }, 'raise exceptions')),\r\n                        createDom('div', { className: 'jasmine-throw-failures' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-throw',\r\n                                id: 'jasmine-throw-failures',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-throw-failures' }, 'stop spec on expectation failure')),\r\n                        createDom('div', { className: 'jasmine-random-order' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-random',\r\n                                id: 'jasmine-random-order',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-random-order' }, 'run tests in random order'))\r\n                    )\r\n                ));\r\n\r\n            var raiseCheckbox = find('#jasmine-raise-exceptions');\r\n\r\n            raiseCheckbox.checked = !env.catchingExceptions();\r\n            raiseCheckbox.onclick = onRaiseExceptionsClick;\r\n\r\n            var throwCheckbox = find('#jasmine-throw-failures');\r\n            throwCheckbox.checked = env.throwingExpectationFailures();\r\n            throwCheckbox.onclick = onThrowExpectationsClick;\r\n\r\n            var randomCheckbox = find('#jasmine-random-order');\r\n            randomCheckbox.checked = env.randomTests();\r\n            randomCheckbox.onclick = onRandomClick;\r\n\r\n            var optionsMenu = find('.jasmine-run-options'),\r\n                optionsTrigger = optionsMenu.querySelector('.jasmine-trigger'),\r\n                optionsPayload = optionsMenu.querySelector('.jasmine-payload'),\r\n                isOpen = /\\bjasmine-open\\b/;\r\n\r\n            optionsTrigger.onclick = function() {\r\n                if (isOpen.test(optionsPayload.className)) {\r\n                    optionsPayload.className = optionsPayload.className.replace(isOpen, '');\r\n                } else {\r\n                    optionsPayload.className += ' jasmine-open';\r\n                }\r\n            };\r\n\r\n            if (specsExecuted < totalSpecsDefined) {\r\n                var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';\r\n                var skippedLink = order && order.random ? '?random=true' : '?';\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-bar jasmine-skipped'},\r\n                        createDom('a', {href: skippedLink, title: 'Run all specs'}, skippedMessage)\r\n                    )\r\n                );\r\n            }\r\n            var statusBarMessage = '';\r\n            var statusBarClassName = 'jasmine-bar ';\r\n\r\n            if (totalSpecsDefined > 0) {\r\n                statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);\r\n                if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }\r\n                statusBarClassName += (failureCount > 0) ? 'jasmine-failed' : 'jasmine-passed';\r\n            } else {\r\n                statusBarClassName += 'jasmine-skipped';\r\n                statusBarMessage += 'No specs found';\r\n            }\r\n\r\n            var seedBar;\r\n            if (order && order.random) {\r\n                seedBar = createDom('span', {className: 'jasmine-seed-bar'},\r\n                    ', randomized with seed ',\r\n                    createDom('a', {title: 'randomized with seed ' + order.seed, href: seedHref(order.seed)}, order.seed)\r\n                );\r\n            }\r\n\r\n            alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage, seedBar));\r\n\r\n            var errorBarClassName = 'jasmine-bar jasmine-errored';\r\n            var errorBarMessagePrefix = 'AfterAll ';\r\n\r\n            for(var i = 0; i < failedSuites.length; i++) {\r\n                var failedSuite = failedSuites[i];\r\n                for(var j = 0; j < failedSuite.failedExpectations.length; j++) {\r\n                    alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessagePrefix + failedSuite.failedExpectations[j].message));\r\n                }\r\n            }\r\n\r\n            var globalFailures = (doneResult && doneResult.failedExpectations) || [];\r\n            for(i = 0; i < globalFailures.length; i++) {\r\n                var failure = globalFailures[i];\r\n                alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessagePrefix + failure.message));\r\n            }\r\n\r\n            var results = find('.jasmine-results');\r\n            results.appendChild(summary);\r\n\r\n            summaryList(topResults, summary);\r\n\r\n            function summaryList(resultsTree, domParent) {\r\n                var specListNode;\r\n                for (var i = 0; i < resultsTree.children.length; i++) {\r\n                    var resultNode = resultsTree.children[i];\r\n                    if (resultNode.type == 'suite') {\r\n                        var suiteListNode = createDom('ul', {className: 'jasmine-suite', id: 'suite-' + resultNode.result.id},\r\n                            createDom('li', {className: 'jasmine-suite-detail'},\r\n                                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)\r\n                            )\r\n                        );\r\n\r\n                        summaryList(resultNode, suiteListNode);\r\n                        domParent.appendChild(suiteListNode);\r\n                    }\r\n                    if (resultNode.type == 'spec') {\r\n                        if (domParent.getAttribute('class') != 'jasmine-specs') {\r\n                            specListNode = createDom('ul', {className: 'jasmine-specs'});\r\n                            domParent.appendChild(specListNode);\r\n                        }\r\n                        var specDescription = resultNode.result.description;\r\n                        if(noExpectations(resultNode.result)) {\r\n                            specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;\r\n                        }\r\n                        if(resultNode.result.status === 'pending' && resultNode.result.pendingReason !== '') {\r\n                            specDescription = specDescription + ' PENDING WITH MESSAGE: ' + resultNode.result.pendingReason;\r\n                        }\r\n                        specListNode.appendChild(\r\n                            createDom('li', {\r\n                                    className: 'jasmine-' + resultNode.result.status,\r\n                                    id: 'spec-' + resultNode.result.id\r\n                                },\r\n                                createDom('a', {href: specHref(resultNode.result)}, specDescription)\r\n                            )\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (failures.length) {\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-spec-list'},\r\n                        createDom('span', {}, 'Spec List | '),\r\n                        createDom('a', {className: 'jasmine-failures-menu', href: '#'}, 'Failures')));\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-failure-list'},\r\n                        createDom('a', {className: 'jasmine-spec-list-menu', href: '#'}, 'Spec List'),\r\n                        createDom('span', {}, ' | Failures ')));\r\n\r\n                find('.jasmine-failures-menu').onclick = function() {\r\n                    setMenuModeTo('jasmine-failure-list');\r\n                };\r\n                find('.jasmine-spec-list-menu').onclick = function() {\r\n                    setMenuModeTo('jasmine-spec-list');\r\n                };\r\n\r\n                setMenuModeTo('jasmine-failure-list');\r\n\r\n                var failureNode = find('.jasmine-failures');\r\n                for (i = 0; i < failures.length; i++) {\r\n                    failureNode.appendChild(failures[i]);\r\n                }\r\n            }\r\n        };\r\n\r\n        return this;\r\n\r\n        function find(selector) {\r\n            return getContainer().querySelector('.jasmine_html-reporter ' + selector);\r\n        }\r\n\r\n        function clearPrior() {\r\n            // return the reporter\r\n            var oldReporter = find('');\r\n\r\n            if(oldReporter) {\r\n                getContainer().removeChild(oldReporter);\r\n            }\r\n        }\r\n\r\n        function createDom(type, attrs, childrenVarArgs) {\r\n            var el = createElement(type);\r\n\r\n            for (var i = 2; i < arguments.length; i++) {\r\n                var child = arguments[i];\r\n\r\n                if (typeof child === 'string') {\r\n                    el.appendChild(createTextNode(child));\r\n                } else {\r\n                    if (child) {\r\n                        el.appendChild(child);\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (var attr in attrs) {\r\n                if (attr == 'className') {\r\n                    el[attr] = attrs[attr];\r\n                } else {\r\n                    el.setAttribute(attr, attrs[attr]);\r\n                }\r\n            }\r\n\r\n            return el;\r\n        }\r\n\r\n        function pluralize(singular, count) {\r\n            var word = (count == 1 ? singular : singular + 's');\r\n\r\n            return '' + count + ' ' + word;\r\n        }\r\n\r\n        function specHref(result) {\r\n            return addToExistingQueryString('spec', result.fullName);\r\n        }\r\n\r\n        function seedHref(seed) {\r\n            return addToExistingQueryString('seed', seed);\r\n        }\r\n\r\n        function defaultQueryString(key, value) {\r\n            return '?' + key + '=' + value;\r\n        }\r\n\r\n        function setMenuModeTo(mode) {\r\n            htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);\r\n        }\r\n\r\n        function noExpectations(result) {\r\n            return (result.failedExpectations.length + result.passedExpectations.length) === 0 &&\r\n                result.status === 'passed';\r\n        }\r\n    }\r\n\r\n    return HtmlReporter;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.HtmlReporter.[function].[return]","oldFunction":"function(j$) {\r\n\r\n    var noopTimer = {\r\n        start: function() {},\r\n        elapsed: function() { return 0; }\r\n    };\r\n\r\n    function HtmlReporter(options) {\r\n        var env = options.env || {},\r\n            getContainer = options.getContainer,\r\n            createElement = options.createElement,\r\n            createTextNode = options.createTextNode,\r\n            onRaiseExceptionsClick = options.onRaiseExceptionsClick || function() {},\r\n            addToExistingQueryString = options.addToExistingQueryString || defaultQueryString,\r\n            timer = options.timer || noopTimer,\r\n            results = [],\r\n            specsExecuted = 0,\r\n            failureCount = 0,\r\n            pendingSpecCount = 0,\r\n            htmlReporterMain,\r\n            symbols,\r\n            failedSuites = [];\r\n\r\n        this.initialize = function() {\r\n            clearPrior();\r\n            htmlReporterMain = createDom('div', {className: 'jasmine_html-reporter'},\r\n                createDom('div', {className: 'banner'},\r\n                    createDom('a', {className: 'title', href: 'http://jasmine.github.io/', target: '_blank'}),\r\n                    createDom('span', {className: 'version'}, j$.version)\r\n                ),\r\n                createDom('ul', {className: 'symbol-summary'}),\r\n                createDom('div', {className: 'alert'}),\r\n                createDom('div', {className: 'results'},\r\n                    createDom('div', {className: 'failures'})\r\n                )\r\n            );\r\n            getContainer().appendChild(htmlReporterMain);\r\n\r\n            symbols = find('.symbol-summary');\r\n        };\r\n\r\n        var totalSpecsDefined;\r\n        this.jasmineStarted = function(options) {\r\n            totalSpecsDefined = options.totalSpecsDefined || 0;\r\n            timer.start();\r\n        };\r\n\r\n        var summary = createDom('div', {className: 'summary'});\r\n\r\n        var topResults = new j$.ResultsNode({}, '', null),\r\n            currentParent = topResults;\r\n\r\n        this.suiteStarted = function(result) {\r\n            currentParent.addChild(result, 'suite');\r\n            currentParent = currentParent.last();\r\n        };\r\n\r\n        this.suiteDone = function(result) {\r\n            if (result.status == 'failed') {\r\n                failedSuites.push(result);\r\n            }\r\n\r\n            if (currentParent == topResults) {\r\n                return;\r\n            }\r\n\r\n            currentParent = currentParent.parent;\r\n        };\r\n\r\n        this.specStarted = function(result) {\r\n            currentParent.addChild(result, 'spec');\r\n        };\r\n\r\n        var failures = [];\r\n        this.specDone = function(result) {\r\n            if(noExpectations(result) && typeof console !== 'undefined' && typeof console.error !== 'undefined') {\r\n                console.error('Spec \\'' + result.fullName + '\\' has no expectations.');\r\n            }\r\n\r\n            if (result.status != 'disabled') {\r\n                specsExecuted++;\r\n            }\r\n\r\n            symbols.appendChild(createDom('li', {\r\n                    className: noExpectations(result) ? 'empty' : result.status,\r\n                    id: 'spec_' + result.id,\r\n                    title: result.fullName\r\n                }\r\n            ));\r\n\r\n            if (result.status == 'failed') {\r\n                failureCount++;\r\n\r\n                var failure =\r\n                    createDom('div', {className: 'spec-detail failed'},\r\n                        createDom('div', {className: 'description'},\r\n                            createDom('a', {title: result.fullName, href: specHref(result)}, result.fullName)\r\n                        ),\r\n                        createDom('div', {className: 'messages'})\r\n                    );\r\n                var messages = failure.childNodes[1];\r\n\r\n                for (var i = 0; i < result.failedExpectations.length; i++) {\r\n                    var expectation = result.failedExpectations[i];\r\n                    messages.appendChild(createDom('div', {className: 'result-message'}, expectation.message));\r\n                    messages.appendChild(createDom('div', {className: 'stack-trace'}, expectation.stack));\r\n                }\r\n\r\n                failures.push(failure);\r\n            }\r\n\r\n            if (result.status == 'pending') {\r\n                pendingSpecCount++;\r\n            }\r\n        };\r\n\r\n        this.jasmineDone = function() {\r\n            var banner = find('.banner');\r\n            banner.appendChild(createDom('span', {className: 'duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));\r\n\r\n            var alert = find('.alert');\r\n\r\n            alert.appendChild(createDom('span', { className: 'exceptions' },\r\n                createDom('label', { className: 'label', 'for': 'raise-exceptions' }, 'raise exceptions'),\r\n                createDom('input', {\r\n                    className: 'raise',\r\n                    id: 'raise-exceptions',\r\n                    type: 'checkbox'\r\n                })\r\n            ));\r\n            var checkbox = find('#raise-exceptions');\r\n\r\n            checkbox.checked = !env.catchingExceptions();\r\n            checkbox.onclick = onRaiseExceptionsClick;\r\n\r\n            if (specsExecuted < totalSpecsDefined) {\r\n                var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'bar skipped'},\r\n                        createDom('a', {href: '?', title: 'Run all specs'}, skippedMessage)\r\n                    )\r\n                );\r\n            }\r\n            var statusBarMessage = '';\r\n            var statusBarClassName = 'bar ';\r\n\r\n            if (totalSpecsDefined > 0) {\r\n                statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);\r\n                if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }\r\n                statusBarClassName += (failureCount > 0) ? 'failed' : 'passed';\r\n            } else {\r\n                statusBarClassName += 'skipped';\r\n                statusBarMessage += 'No specs found';\r\n            }\r\n\r\n            alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage));\r\n\r\n            for(i = 0; i < failedSuites.length; i++) {\r\n                var failedSuite = failedSuites[i];\r\n                for(var j = 0; j < failedSuite.failedExpectations.length; j++) {\r\n                    var errorBarMessage = 'AfterAll ' + failedSuite.failedExpectations[j].message;\r\n                    var errorBarClassName = 'bar errored';\r\n                    alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessage));\r\n                }\r\n            }\r\n\r\n            var results = find('.results');\r\n            results.appendChild(summary);\r\n\r\n            summaryList(topResults, summary);\r\n\r\n            function summaryList(resultsTree, domParent) {\r\n                var specListNode;\r\n                for (var i = 0; i < resultsTree.children.length; i++) {\r\n                    var resultNode = resultsTree.children[i];\r\n                    if (resultNode.type == 'suite') {\r\n                        var suiteListNode = createDom('ul', {className: 'suite', id: 'suite-' + resultNode.result.id},\r\n                            createDom('li', {className: 'suite-detail'},\r\n                                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)\r\n                            )\r\n                        );\r\n\r\n                        summaryList(resultNode, suiteListNode);\r\n                        domParent.appendChild(suiteListNode);\r\n                    }\r\n                    if (resultNode.type == 'spec') {\r\n                        if (domParent.getAttribute('class') != 'specs') {\r\n                            specListNode = createDom('ul', {className: 'specs'});\r\n                            domParent.appendChild(specListNode);\r\n                        }\r\n                        var specDescription = resultNode.result.description;\r\n                        if(noExpectations(resultNode.result)) {\r\n                            specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;\r\n                        }\r\n                        if(resultNode.result.status === 'pending' && resultNode.result.pendingReason !== '') {\r\n                            specDescription = specDescription + ' PENDING WITH MESSAGE: ' + resultNode.result.pendingReason;\r\n                        }\r\n                        specListNode.appendChild(\r\n                            createDom('li', {\r\n                                    className: resultNode.result.status,\r\n                                    id: 'spec-' + resultNode.result.id\r\n                                },\r\n                                createDom('a', {href: specHref(resultNode.result)}, specDescription)\r\n                            )\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (failures.length) {\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'menu bar spec-list'},\r\n                        createDom('span', {}, 'Spec List | '),\r\n                        createDom('a', {className: 'failures-menu', href: '#'}, 'Failures')));\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'menu bar failure-list'},\r\n                        createDom('a', {className: 'spec-list-menu', href: '#'}, 'Spec List'),\r\n                        createDom('span', {}, ' | Failures ')));\r\n\r\n                find('.failures-menu').onclick = function() {\r\n                    setMenuModeTo('failure-list');\r\n                };\r\n                find('.spec-list-menu').onclick = function() {\r\n                    setMenuModeTo('spec-list');\r\n                };\r\n\r\n                setMenuModeTo('failure-list');\r\n\r\n                var failureNode = find('.failures');\r\n                for (var i = 0; i < failures.length; i++) {\r\n                    failureNode.appendChild(failures[i]);\r\n                }\r\n            }\r\n        };\r\n\r\n        return this;\r\n\r\n        function find(selector) {\r\n            return getContainer().querySelector('.jasmine_html-reporter ' + selector);\r\n        }\r\n\r\n        function clearPrior() {\r\n            // return the reporter\r\n            var oldReporter = find('');\r\n\r\n            if(oldReporter) {\r\n                getContainer().removeChild(oldReporter);\r\n            }\r\n        }\r\n\r\n        function createDom(type, attrs, childrenVarArgs) {\r\n            var el = createElement(type);\r\n\r\n            for (var i = 2; i < arguments.length; i++) {\r\n                var child = arguments[i];\r\n\r\n                if (typeof child === 'string') {\r\n                    el.appendChild(createTextNode(child));\r\n                } else {\r\n                    if (child) {\r\n                        el.appendChild(child);\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (var attr in attrs) {\r\n                if (attr == 'className') {\r\n                    el[attr] = attrs[attr];\r\n                } else {\r\n                    el.setAttribute(attr, attrs[attr]);\r\n                }\r\n            }\r\n\r\n            return el;\r\n        }\r\n\r\n        function pluralize(singular, count) {\r\n            var word = (count == 1 ? singular : singular + 's');\r\n\r\n            return '' + count + ' ' + word;\r\n        }\r\n\r\n        function specHref(result) {\r\n            return addToExistingQueryString('spec', result.fullName);\r\n        }\r\n\r\n        function defaultQueryString(key, value) {\r\n            return '?' + key + '=' + value;\r\n        }\r\n\r\n        function setMenuModeTo(mode) {\r\n            htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);\r\n        }\r\n\r\n        function noExpectations(result) {\r\n            return (result.failedExpectations.length + result.passedExpectations.length) === 0 &&\r\n                result.status === 'passed';\r\n        }\r\n    }\r\n\r\n    return HtmlReporter;\r\n}","oldJSDoc":null,"type":"addedProperty","typePath":"window.jasmineRequire.HtmlReporter.[function].[return].[function].[arg0]","key":"onThrowExpectationsClick","newType":null,"isAny":true,"isClass":false,"containerType":"// Seen as: options\ninterface interface_807 {\n    addToExistingQueryString: any;\n    createElement: (arg0: void) => void;\n    createTextNode: (arg0: void) => void;\n    env: any;\n    getContainer: () => void;\n    onRaiseExceptionsClick: any;\n    onRandomClick: any;\n    onThrowExpectationsClick: any;\n    timer: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.HtmlReporter.[function].[return]","newFunction":"function(j$) {\r\n\r\n    var noopTimer = {\r\n        start: function() {},\r\n        elapsed: function() { return 0; }\r\n    };\r\n\r\n    function HtmlReporter(options) {\r\n        var env = options.env || {},\r\n            getContainer = options.getContainer,\r\n            createElement = options.createElement,\r\n            createTextNode = options.createTextNode,\r\n            onRaiseExceptionsClick = options.onRaiseExceptionsClick || function() {},\r\n            onThrowExpectationsClick = options.onThrowExpectationsClick || function() {},\r\n            onRandomClick = options.onRandomClick || function() {},\r\n            addToExistingQueryString = options.addToExistingQueryString || defaultQueryString,\r\n            timer = options.timer || noopTimer,\r\n            results = [],\r\n            specsExecuted = 0,\r\n            failureCount = 0,\r\n            pendingSpecCount = 0,\r\n            htmlReporterMain,\r\n            symbols,\r\n            failedSuites = [];\r\n\r\n        this.initialize = function() {\r\n            clearPrior();\r\n            htmlReporterMain = createDom('div', {className: 'jasmine_html-reporter'},\r\n                createDom('div', {className: 'jasmine-banner'},\r\n                    createDom('a', {className: 'jasmine-title', href: 'http://jasmine.github.io/', target: '_blank'}),\r\n                    createDom('span', {className: 'jasmine-version'}, j$.version)\r\n                ),\r\n                createDom('ul', {className: 'jasmine-symbol-summary'}),\r\n                createDom('div', {className: 'jasmine-alert'}),\r\n                createDom('div', {className: 'jasmine-results'},\r\n                    createDom('div', {className: 'jasmine-failures'})\r\n                )\r\n            );\r\n            getContainer().appendChild(htmlReporterMain);\r\n        };\r\n\r\n        var totalSpecsDefined;\r\n        this.jasmineStarted = function(options) {\r\n            totalSpecsDefined = options.totalSpecsDefined || 0;\r\n            timer.start();\r\n        };\r\n\r\n        var summary = createDom('div', {className: 'jasmine-summary'});\r\n\r\n        var topResults = new j$.ResultsNode({}, '', null),\r\n            currentParent = topResults;\r\n\r\n        this.suiteStarted = function(result) {\r\n            currentParent.addChild(result, 'suite');\r\n            currentParent = currentParent.last();\r\n        };\r\n\r\n        this.suiteDone = function(result) {\r\n            if (result.status == 'failed') {\r\n                failedSuites.push(result);\r\n            }\r\n\r\n            if (currentParent == topResults) {\r\n                return;\r\n            }\r\n\r\n            currentParent = currentParent.parent;\r\n        };\r\n\r\n        this.specStarted = function(result) {\r\n            currentParent.addChild(result, 'spec');\r\n        };\r\n\r\n        var failures = [];\r\n        this.specDone = function(result) {\r\n            if(noExpectations(result) && typeof console !== 'undefined' && typeof console.error !== 'undefined') {\r\n                console.error('Spec \\'' + result.fullName + '\\' has no expectations.');\r\n            }\r\n\r\n            if (result.status != 'disabled') {\r\n                specsExecuted++;\r\n            }\r\n\r\n            if (!symbols){\r\n                symbols = find('.jasmine-symbol-summary');\r\n            }\r\n\r\n            symbols.appendChild(createDom('li', {\r\n                    className: noExpectations(result) ? 'jasmine-empty' : 'jasmine-' + result.status,\r\n                    id: 'spec_' + result.id,\r\n                    title: result.fullName\r\n                }\r\n            ));\r\n\r\n            if (result.status == 'failed') {\r\n                failureCount++;\r\n\r\n                var failure =\r\n                    createDom('div', {className: 'jasmine-spec-detail jasmine-failed'},\r\n                        createDom('div', {className: 'jasmine-description'},\r\n                            createDom('a', {title: result.fullName, href: specHref(result)}, result.fullName)\r\n                        ),\r\n                        createDom('div', {className: 'jasmine-messages'})\r\n                    );\r\n                var messages = failure.childNodes[1];\r\n\r\n                for (var i = 0; i < result.failedExpectations.length; i++) {\r\n                    var expectation = result.failedExpectations[i];\r\n                    messages.appendChild(createDom('div', {className: 'jasmine-result-message'}, expectation.message));\r\n                    messages.appendChild(createDom('div', {className: 'jasmine-stack-trace'}, expectation.stack));\r\n                }\r\n\r\n                failures.push(failure);\r\n            }\r\n\r\n            if (result.status == 'pending') {\r\n                pendingSpecCount++;\r\n            }\r\n        };\r\n\r\n        this.jasmineDone = function(doneResult) {\r\n            var banner = find('.jasmine-banner');\r\n            var alert = find('.jasmine-alert');\r\n            var order = doneResult && doneResult.order;\r\n            alert.appendChild(createDom('span', {className: 'jasmine-duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));\r\n\r\n            banner.appendChild(\r\n                createDom('div', { className: 'jasmine-run-options' },\r\n                    createDom('span', { className: 'jasmine-trigger' }, 'Options'),\r\n                    createDom('div', { className: 'jasmine-payload' },\r\n                        createDom('div', { className: 'jasmine-exceptions' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-raise',\r\n                                id: 'jasmine-raise-exceptions',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-raise-exceptions' }, 'raise exceptions')),\r\n                        createDom('div', { className: 'jasmine-throw-failures' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-throw',\r\n                                id: 'jasmine-throw-failures',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-throw-failures' }, 'stop spec on expectation failure')),\r\n                        createDom('div', { className: 'jasmine-random-order' },\r\n                            createDom('input', {\r\n                                className: 'jasmine-random',\r\n                                id: 'jasmine-random-order',\r\n                                type: 'checkbox'\r\n                            }),\r\n                            createDom('label', { className: 'jasmine-label', 'for': 'jasmine-random-order' }, 'run tests in random order'))\r\n                    )\r\n                ));\r\n\r\n            var raiseCheckbox = find('#jasmine-raise-exceptions');\r\n\r\n            raiseCheckbox.checked = !env.catchingExceptions();\r\n            raiseCheckbox.onclick = onRaiseExceptionsClick;\r\n\r\n            var throwCheckbox = find('#jasmine-throw-failures');\r\n            throwCheckbox.checked = env.throwingExpectationFailures();\r\n            throwCheckbox.onclick = onThrowExpectationsClick;\r\n\r\n            var randomCheckbox = find('#jasmine-random-order');\r\n            randomCheckbox.checked = env.randomTests();\r\n            randomCheckbox.onclick = onRandomClick;\r\n\r\n            var optionsMenu = find('.jasmine-run-options'),\r\n                optionsTrigger = optionsMenu.querySelector('.jasmine-trigger'),\r\n                optionsPayload = optionsMenu.querySelector('.jasmine-payload'),\r\n                isOpen = /\\bjasmine-open\\b/;\r\n\r\n            optionsTrigger.onclick = function() {\r\n                if (isOpen.test(optionsPayload.className)) {\r\n                    optionsPayload.className = optionsPayload.className.replace(isOpen, '');\r\n                } else {\r\n                    optionsPayload.className += ' jasmine-open';\r\n                }\r\n            };\r\n\r\n            if (specsExecuted < totalSpecsDefined) {\r\n                var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';\r\n                var skippedLink = order && order.random ? '?random=true' : '?';\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-bar jasmine-skipped'},\r\n                        createDom('a', {href: skippedLink, title: 'Run all specs'}, skippedMessage)\r\n                    )\r\n                );\r\n            }\r\n            var statusBarMessage = '';\r\n            var statusBarClassName = 'jasmine-bar ';\r\n\r\n            if (totalSpecsDefined > 0) {\r\n                statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);\r\n                if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }\r\n                statusBarClassName += (failureCount > 0) ? 'jasmine-failed' : 'jasmine-passed';\r\n            } else {\r\n                statusBarClassName += 'jasmine-skipped';\r\n                statusBarMessage += 'No specs found';\r\n            }\r\n\r\n            var seedBar;\r\n            if (order && order.random) {\r\n                seedBar = createDom('span', {className: 'jasmine-seed-bar'},\r\n                    ', randomized with seed ',\r\n                    createDom('a', {title: 'randomized with seed ' + order.seed, href: seedHref(order.seed)}, order.seed)\r\n                );\r\n            }\r\n\r\n            alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage, seedBar));\r\n\r\n            var errorBarClassName = 'jasmine-bar jasmine-errored';\r\n            var errorBarMessagePrefix = 'AfterAll ';\r\n\r\n            for(var i = 0; i < failedSuites.length; i++) {\r\n                var failedSuite = failedSuites[i];\r\n                for(var j = 0; j < failedSuite.failedExpectations.length; j++) {\r\n                    alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessagePrefix + failedSuite.failedExpectations[j].message));\r\n                }\r\n            }\r\n\r\n            var globalFailures = (doneResult && doneResult.failedExpectations) || [];\r\n            for(i = 0; i < globalFailures.length; i++) {\r\n                var failure = globalFailures[i];\r\n                alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessagePrefix + failure.message));\r\n            }\r\n\r\n            var results = find('.jasmine-results');\r\n            results.appendChild(summary);\r\n\r\n            summaryList(topResults, summary);\r\n\r\n            function summaryList(resultsTree, domParent) {\r\n                var specListNode;\r\n                for (var i = 0; i < resultsTree.children.length; i++) {\r\n                    var resultNode = resultsTree.children[i];\r\n                    if (resultNode.type == 'suite') {\r\n                        var suiteListNode = createDom('ul', {className: 'jasmine-suite', id: 'suite-' + resultNode.result.id},\r\n                            createDom('li', {className: 'jasmine-suite-detail'},\r\n                                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)\r\n                            )\r\n                        );\r\n\r\n                        summaryList(resultNode, suiteListNode);\r\n                        domParent.appendChild(suiteListNode);\r\n                    }\r\n                    if (resultNode.type == 'spec') {\r\n                        if (domParent.getAttribute('class') != 'jasmine-specs') {\r\n                            specListNode = createDom('ul', {className: 'jasmine-specs'});\r\n                            domParent.appendChild(specListNode);\r\n                        }\r\n                        var specDescription = resultNode.result.description;\r\n                        if(noExpectations(resultNode.result)) {\r\n                            specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;\r\n                        }\r\n                        if(resultNode.result.status === 'pending' && resultNode.result.pendingReason !== '') {\r\n                            specDescription = specDescription + ' PENDING WITH MESSAGE: ' + resultNode.result.pendingReason;\r\n                        }\r\n                        specListNode.appendChild(\r\n                            createDom('li', {\r\n                                    className: 'jasmine-' + resultNode.result.status,\r\n                                    id: 'spec-' + resultNode.result.id\r\n                                },\r\n                                createDom('a', {href: specHref(resultNode.result)}, specDescription)\r\n                            )\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (failures.length) {\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-spec-list'},\r\n                        createDom('span', {}, 'Spec List | '),\r\n                        createDom('a', {className: 'jasmine-failures-menu', href: '#'}, 'Failures')));\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'jasmine-menu jasmine-bar jasmine-failure-list'},\r\n                        createDom('a', {className: 'jasmine-spec-list-menu', href: '#'}, 'Spec List'),\r\n                        createDom('span', {}, ' | Failures ')));\r\n\r\n                find('.jasmine-failures-menu').onclick = function() {\r\n                    setMenuModeTo('jasmine-failure-list');\r\n                };\r\n                find('.jasmine-spec-list-menu').onclick = function() {\r\n                    setMenuModeTo('jasmine-spec-list');\r\n                };\r\n\r\n                setMenuModeTo('jasmine-failure-list');\r\n\r\n                var failureNode = find('.jasmine-failures');\r\n                for (i = 0; i < failures.length; i++) {\r\n                    failureNode.appendChild(failures[i]);\r\n                }\r\n            }\r\n        };\r\n\r\n        return this;\r\n\r\n        function find(selector) {\r\n            return getContainer().querySelector('.jasmine_html-reporter ' + selector);\r\n        }\r\n\r\n        function clearPrior() {\r\n            // return the reporter\r\n            var oldReporter = find('');\r\n\r\n            if(oldReporter) {\r\n                getContainer().removeChild(oldReporter);\r\n            }\r\n        }\r\n\r\n        function createDom(type, attrs, childrenVarArgs) {\r\n            var el = createElement(type);\r\n\r\n            for (var i = 2; i < arguments.length; i++) {\r\n                var child = arguments[i];\r\n\r\n                if (typeof child === 'string') {\r\n                    el.appendChild(createTextNode(child));\r\n                } else {\r\n                    if (child) {\r\n                        el.appendChild(child);\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (var attr in attrs) {\r\n                if (attr == 'className') {\r\n                    el[attr] = attrs[attr];\r\n                } else {\r\n                    el.setAttribute(attr, attrs[attr]);\r\n                }\r\n            }\r\n\r\n            return el;\r\n        }\r\n\r\n        function pluralize(singular, count) {\r\n            var word = (count == 1 ? singular : singular + 's');\r\n\r\n            return '' + count + ' ' + word;\r\n        }\r\n\r\n        function specHref(result) {\r\n            return addToExistingQueryString('spec', result.fullName);\r\n        }\r\n\r\n        function seedHref(seed) {\r\n            return addToExistingQueryString('seed', seed);\r\n        }\r\n\r\n        function defaultQueryString(key, value) {\r\n            return '?' + key + '=' + value;\r\n        }\r\n\r\n        function setMenuModeTo(mode) {\r\n            htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);\r\n        }\r\n\r\n        function noExpectations(result) {\r\n            return (result.failedExpectations.length + result.passedExpectations.length) === 0 &&\r\n                result.status === 'passed';\r\n        }\r\n    }\r\n\r\n    return HtmlReporter;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.HtmlReporter.[function].[return]","oldFunction":"function(j$) {\r\n\r\n    var noopTimer = {\r\n        start: function() {},\r\n        elapsed: function() { return 0; }\r\n    };\r\n\r\n    function HtmlReporter(options) {\r\n        var env = options.env || {},\r\n            getContainer = options.getContainer,\r\n            createElement = options.createElement,\r\n            createTextNode = options.createTextNode,\r\n            onRaiseExceptionsClick = options.onRaiseExceptionsClick || function() {},\r\n            addToExistingQueryString = options.addToExistingQueryString || defaultQueryString,\r\n            timer = options.timer || noopTimer,\r\n            results = [],\r\n            specsExecuted = 0,\r\n            failureCount = 0,\r\n            pendingSpecCount = 0,\r\n            htmlReporterMain,\r\n            symbols,\r\n            failedSuites = [];\r\n\r\n        this.initialize = function() {\r\n            clearPrior();\r\n            htmlReporterMain = createDom('div', {className: 'jasmine_html-reporter'},\r\n                createDom('div', {className: 'banner'},\r\n                    createDom('a', {className: 'title', href: 'http://jasmine.github.io/', target: '_blank'}),\r\n                    createDom('span', {className: 'version'}, j$.version)\r\n                ),\r\n                createDom('ul', {className: 'symbol-summary'}),\r\n                createDom('div', {className: 'alert'}),\r\n                createDom('div', {className: 'results'},\r\n                    createDom('div', {className: 'failures'})\r\n                )\r\n            );\r\n            getContainer().appendChild(htmlReporterMain);\r\n\r\n            symbols = find('.symbol-summary');\r\n        };\r\n\r\n        var totalSpecsDefined;\r\n        this.jasmineStarted = function(options) {\r\n            totalSpecsDefined = options.totalSpecsDefined || 0;\r\n            timer.start();\r\n        };\r\n\r\n        var summary = createDom('div', {className: 'summary'});\r\n\r\n        var topResults = new j$.ResultsNode({}, '', null),\r\n            currentParent = topResults;\r\n\r\n        this.suiteStarted = function(result) {\r\n            currentParent.addChild(result, 'suite');\r\n            currentParent = currentParent.last();\r\n        };\r\n\r\n        this.suiteDone = function(result) {\r\n            if (result.status == 'failed') {\r\n                failedSuites.push(result);\r\n            }\r\n\r\n            if (currentParent == topResults) {\r\n                return;\r\n            }\r\n\r\n            currentParent = currentParent.parent;\r\n        };\r\n\r\n        this.specStarted = function(result) {\r\n            currentParent.addChild(result, 'spec');\r\n        };\r\n\r\n        var failures = [];\r\n        this.specDone = function(result) {\r\n            if(noExpectations(result) && typeof console !== 'undefined' && typeof console.error !== 'undefined') {\r\n                console.error('Spec \\'' + result.fullName + '\\' has no expectations.');\r\n            }\r\n\r\n            if (result.status != 'disabled') {\r\n                specsExecuted++;\r\n            }\r\n\r\n            symbols.appendChild(createDom('li', {\r\n                    className: noExpectations(result) ? 'empty' : result.status,\r\n                    id: 'spec_' + result.id,\r\n                    title: result.fullName\r\n                }\r\n            ));\r\n\r\n            if (result.status == 'failed') {\r\n                failureCount++;\r\n\r\n                var failure =\r\n                    createDom('div', {className: 'spec-detail failed'},\r\n                        createDom('div', {className: 'description'},\r\n                            createDom('a', {title: result.fullName, href: specHref(result)}, result.fullName)\r\n                        ),\r\n                        createDom('div', {className: 'messages'})\r\n                    );\r\n                var messages = failure.childNodes[1];\r\n\r\n                for (var i = 0; i < result.failedExpectations.length; i++) {\r\n                    var expectation = result.failedExpectations[i];\r\n                    messages.appendChild(createDom('div', {className: 'result-message'}, expectation.message));\r\n                    messages.appendChild(createDom('div', {className: 'stack-trace'}, expectation.stack));\r\n                }\r\n\r\n                failures.push(failure);\r\n            }\r\n\r\n            if (result.status == 'pending') {\r\n                pendingSpecCount++;\r\n            }\r\n        };\r\n\r\n        this.jasmineDone = function() {\r\n            var banner = find('.banner');\r\n            banner.appendChild(createDom('span', {className: 'duration'}, 'finished in ' + timer.elapsed() / 1000 + 's'));\r\n\r\n            var alert = find('.alert');\r\n\r\n            alert.appendChild(createDom('span', { className: 'exceptions' },\r\n                createDom('label', { className: 'label', 'for': 'raise-exceptions' }, 'raise exceptions'),\r\n                createDom('input', {\r\n                    className: 'raise',\r\n                    id: 'raise-exceptions',\r\n                    type: 'checkbox'\r\n                })\r\n            ));\r\n            var checkbox = find('#raise-exceptions');\r\n\r\n            checkbox.checked = !env.catchingExceptions();\r\n            checkbox.onclick = onRaiseExceptionsClick;\r\n\r\n            if (specsExecuted < totalSpecsDefined) {\r\n                var skippedMessage = 'Ran ' + specsExecuted + ' of ' + totalSpecsDefined + ' specs - run all';\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'bar skipped'},\r\n                        createDom('a', {href: '?', title: 'Run all specs'}, skippedMessage)\r\n                    )\r\n                );\r\n            }\r\n            var statusBarMessage = '';\r\n            var statusBarClassName = 'bar ';\r\n\r\n            if (totalSpecsDefined > 0) {\r\n                statusBarMessage += pluralize('spec', specsExecuted) + ', ' + pluralize('failure', failureCount);\r\n                if (pendingSpecCount) { statusBarMessage += ', ' + pluralize('pending spec', pendingSpecCount); }\r\n                statusBarClassName += (failureCount > 0) ? 'failed' : 'passed';\r\n            } else {\r\n                statusBarClassName += 'skipped';\r\n                statusBarMessage += 'No specs found';\r\n            }\r\n\r\n            alert.appendChild(createDom('span', {className: statusBarClassName}, statusBarMessage));\r\n\r\n            for(i = 0; i < failedSuites.length; i++) {\r\n                var failedSuite = failedSuites[i];\r\n                for(var j = 0; j < failedSuite.failedExpectations.length; j++) {\r\n                    var errorBarMessage = 'AfterAll ' + failedSuite.failedExpectations[j].message;\r\n                    var errorBarClassName = 'bar errored';\r\n                    alert.appendChild(createDom('span', {className: errorBarClassName}, errorBarMessage));\r\n                }\r\n            }\r\n\r\n            var results = find('.results');\r\n            results.appendChild(summary);\r\n\r\n            summaryList(topResults, summary);\r\n\r\n            function summaryList(resultsTree, domParent) {\r\n                var specListNode;\r\n                for (var i = 0; i < resultsTree.children.length; i++) {\r\n                    var resultNode = resultsTree.children[i];\r\n                    if (resultNode.type == 'suite') {\r\n                        var suiteListNode = createDom('ul', {className: 'suite', id: 'suite-' + resultNode.result.id},\r\n                            createDom('li', {className: 'suite-detail'},\r\n                                createDom('a', {href: specHref(resultNode.result)}, resultNode.result.description)\r\n                            )\r\n                        );\r\n\r\n                        summaryList(resultNode, suiteListNode);\r\n                        domParent.appendChild(suiteListNode);\r\n                    }\r\n                    if (resultNode.type == 'spec') {\r\n                        if (domParent.getAttribute('class') != 'specs') {\r\n                            specListNode = createDom('ul', {className: 'specs'});\r\n                            domParent.appendChild(specListNode);\r\n                        }\r\n                        var specDescription = resultNode.result.description;\r\n                        if(noExpectations(resultNode.result)) {\r\n                            specDescription = 'SPEC HAS NO EXPECTATIONS ' + specDescription;\r\n                        }\r\n                        if(resultNode.result.status === 'pending' && resultNode.result.pendingReason !== '') {\r\n                            specDescription = specDescription + ' PENDING WITH MESSAGE: ' + resultNode.result.pendingReason;\r\n                        }\r\n                        specListNode.appendChild(\r\n                            createDom('li', {\r\n                                    className: resultNode.result.status,\r\n                                    id: 'spec-' + resultNode.result.id\r\n                                },\r\n                                createDom('a', {href: specHref(resultNode.result)}, specDescription)\r\n                            )\r\n                        );\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (failures.length) {\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'menu bar spec-list'},\r\n                        createDom('span', {}, 'Spec List | '),\r\n                        createDom('a', {className: 'failures-menu', href: '#'}, 'Failures')));\r\n                alert.appendChild(\r\n                    createDom('span', {className: 'menu bar failure-list'},\r\n                        createDom('a', {className: 'spec-list-menu', href: '#'}, 'Spec List'),\r\n                        createDom('span', {}, ' | Failures ')));\r\n\r\n                find('.failures-menu').onclick = function() {\r\n                    setMenuModeTo('failure-list');\r\n                };\r\n                find('.spec-list-menu').onclick = function() {\r\n                    setMenuModeTo('spec-list');\r\n                };\r\n\r\n                setMenuModeTo('failure-list');\r\n\r\n                var failureNode = find('.failures');\r\n                for (var i = 0; i < failures.length; i++) {\r\n                    failureNode.appendChild(failures[i]);\r\n                }\r\n            }\r\n        };\r\n\r\n        return this;\r\n\r\n        function find(selector) {\r\n            return getContainer().querySelector('.jasmine_html-reporter ' + selector);\r\n        }\r\n\r\n        function clearPrior() {\r\n            // return the reporter\r\n            var oldReporter = find('');\r\n\r\n            if(oldReporter) {\r\n                getContainer().removeChild(oldReporter);\r\n            }\r\n        }\r\n\r\n        function createDom(type, attrs, childrenVarArgs) {\r\n            var el = createElement(type);\r\n\r\n            for (var i = 2; i < arguments.length; i++) {\r\n                var child = arguments[i];\r\n\r\n                if (typeof child === 'string') {\r\n                    el.appendChild(createTextNode(child));\r\n                } else {\r\n                    if (child) {\r\n                        el.appendChild(child);\r\n                    }\r\n                }\r\n            }\r\n\r\n            for (var attr in attrs) {\r\n                if (attr == 'className') {\r\n                    el[attr] = attrs[attr];\r\n                } else {\r\n                    el.setAttribute(attr, attrs[attr]);\r\n                }\r\n            }\r\n\r\n            return el;\r\n        }\r\n\r\n        function pluralize(singular, count) {\r\n            var word = (count == 1 ? singular : singular + 's');\r\n\r\n            return '' + count + ' ' + word;\r\n        }\r\n\r\n        function specHref(result) {\r\n            return addToExistingQueryString('spec', result.fullName);\r\n        }\r\n\r\n        function defaultQueryString(key, value) {\r\n            return '?' + key + '=' + value;\r\n        }\r\n\r\n        function setMenuModeTo(mode) {\r\n            htmlReporterMain.setAttribute('class', 'jasmine_html-reporter ' + mode);\r\n        }\r\n\r\n        function noExpectations(result) {\r\n            return (result.failedExpectations.length + result.passedExpectations.length) === 0 &&\r\n                result.status === 'passed';\r\n        }\r\n    }\r\n\r\n    return HtmlReporter;\r\n}","oldJSDoc":null,"type":"changedArgCount","typePath":"window.jasmineRequire.HtmlReporter.[function].[return].[function].[return].jasmineDone","isClass":false,"newType":"(doneResult: {failedExpectations: any, order: any}) => void","newTypeDescription":"function","oldType":"() => void","oldArgCount":0,"newArgCount":1,"containerType":"interface interface_811 {\n    initialize: () => void;\n    jasmineDone: (doneResult: {failedExpectations: any, order: any}) => void;\n    jasmineStarted: (options: {totalSpecsDefined: any}) => void;\n    specDone: (result: interface_809) => void;\n    specStarted: (result: any) => void;\n    suiteDone: (result: {status: string}) => void;\n    suiteStarted: (result: any) => void;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.DelayedFunctionScheduler.[function].[return]","newFunction":"function() {\r\n    function DelayedFunctionScheduler() {\r\n        var self = this;\r\n        var scheduledLookup = [];\r\n        var scheduledFunctions = {};\r\n        var currentTime = 0;\r\n        var delayedFnCount = 0;\r\n\r\n        self.tick = function(millis, tickDate) {\r\n            millis = millis || 0;\r\n            var endTime = currentTime + millis;\r\n\r\n            runScheduledFunctions(endTime, tickDate);\r\n            currentTime = endTime;\r\n        };\r\n\r\n        self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {\r\n            var f;\r\n            if (typeof(funcToCall) === 'string') {\r\n                /* jshint evil: true */\r\n                f = function() { return eval(funcToCall); };\r\n                /* jshint evil: false */\r\n            } else {\r\n                f = funcToCall;\r\n            }\r\n\r\n            millis = millis || 0;\r\n            timeoutKey = timeoutKey || ++delayedFnCount;\r\n            runAtMillis = runAtMillis || (currentTime + millis);\r\n\r\n            var funcToSchedule = {\r\n                runAtMillis: runAtMillis,\r\n                funcToCall: f,\r\n                recurring: recurring,\r\n                params: params,\r\n                timeoutKey: timeoutKey,\r\n                millis: millis\r\n            };\r\n\r\n            if (runAtMillis in scheduledFunctions) {\r\n                scheduledFunctions[runAtMillis].push(funcToSchedule);\r\n            } else {\r\n                scheduledFunctions[runAtMillis] = [funcToSchedule];\r\n                scheduledLookup.push(runAtMillis);\r\n                scheduledLookup.sort(function (a, b) {\r\n                    return a - b;\r\n                });\r\n            }\r\n\r\n            return timeoutKey;\r\n        };\r\n\r\n        self.removeFunctionWithId = function(timeoutKey) {\r\n            for (var runAtMillis in scheduledFunctions) {\r\n                var funcs = scheduledFunctions[runAtMillis];\r\n                var i = indexOfFirstToPass(funcs, function (func) {\r\n                    return func.timeoutKey === timeoutKey;\r\n                });\r\n\r\n                if (i > -1) {\r\n                    if (funcs.length === 1) {\r\n                        delete scheduledFunctions[runAtMillis];\r\n                        deleteFromLookup(runAtMillis);\r\n                    } else {\r\n                        funcs.splice(i, 1);\r\n                    }\r\n\r\n                    // intervals get rescheduled when executed, so there's never more\r\n                    // than a single scheduled function with a given timeoutKey\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n\r\n        return self;\r\n\r\n        function indexOfFirstToPass(array, testFn) {\r\n            var index = -1;\r\n\r\n            for (var i = 0; i < array.length; ++i) {\r\n                if (testFn(array[i])) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return index;\r\n        }\r\n\r\n        function deleteFromLookup(key) {\r\n            var value = Number(key);\r\n            var i = indexOfFirstToPass(scheduledLookup, function (millis) {\r\n                return millis === value;\r\n            });\r\n\r\n            if (i > -1) {\r\n                scheduledLookup.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        function reschedule(scheduledFn) {\r\n            self.scheduleFunction(scheduledFn.funcToCall,\r\n                scheduledFn.millis,\r\n                scheduledFn.params,\r\n                true,\r\n                scheduledFn.timeoutKey,\r\n                scheduledFn.runAtMillis + scheduledFn.millis);\r\n        }\r\n\r\n        function forEachFunction(funcsToRun, callback) {\r\n            for (var i = 0; i < funcsToRun.length; ++i) {\r\n                callback(funcsToRun[i]);\r\n            }\r\n        }\r\n\r\n        function runScheduledFunctions(endTime, tickDate) {\r\n            tickDate = tickDate || function() {};\r\n            if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {\r\n                tickDate(endTime);\r\n                return;\r\n            }\r\n\r\n            do {\r\n                var newCurrentTime = scheduledLookup.shift();\r\n                tickDate(newCurrentTime - currentTime);\r\n\r\n                currentTime = newCurrentTime;\r\n\r\n                var funcsToRun = scheduledFunctions[currentTime];\r\n                delete scheduledFunctions[currentTime];\r\n\r\n                forEachFunction(funcsToRun, function(funcToRun) {\r\n                    if (funcToRun.recurring) {\r\n                        reschedule(funcToRun);\r\n                    }\r\n                });\r\n\r\n                forEachFunction(funcsToRun, function(funcToRun) {\r\n                    funcToRun.funcToCall.apply(null, funcToRun.params || []);\r\n                });\r\n            } while (scheduledLookup.length > 0 &&\r\n            // checking first if we're out of time prevents setTimeout(0)\r\n            // scheduled in a funcToRun from forcing an extra iteration\r\n            currentTime !== endTime  &&\r\n            scheduledLookup[0] <= endTime);\r\n        }\r\n    }\r\n\r\n    return DelayedFunctionScheduler;\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.DelayedFunctionScheduler.[function].[return]","oldFunction":"function() {\r\n    function DelayedFunctionScheduler() {\r\n        var self = this;\r\n        var scheduledLookup = [];\r\n        var scheduledFunctions = {};\r\n        var currentTime = 0;\r\n        var delayedFnCount = 0;\r\n\r\n        self.tick = function(millis) {\r\n            millis = millis || 0;\r\n            var endTime = currentTime + millis;\r\n\r\n            runScheduledFunctions(endTime);\r\n            currentTime = endTime;\r\n        };\r\n\r\n        self.scheduleFunction = function(funcToCall, millis, params, recurring, timeoutKey, runAtMillis) {\r\n            var f;\r\n            if (typeof(funcToCall) === 'string') {\r\n                /* jshint evil: true */\r\n                f = function() { return eval(funcToCall); };\r\n                /* jshint evil: false */\r\n            } else {\r\n                f = funcToCall;\r\n            }\r\n\r\n            millis = millis || 0;\r\n            timeoutKey = timeoutKey || ++delayedFnCount;\r\n            runAtMillis = runAtMillis || (currentTime + millis);\r\n\r\n            var funcToSchedule = {\r\n                runAtMillis: runAtMillis,\r\n                funcToCall: f,\r\n                recurring: recurring,\r\n                params: params,\r\n                timeoutKey: timeoutKey,\r\n                millis: millis\r\n            };\r\n\r\n            if (runAtMillis in scheduledFunctions) {\r\n                scheduledFunctions[runAtMillis].push(funcToSchedule);\r\n            } else {\r\n                scheduledFunctions[runAtMillis] = [funcToSchedule];\r\n                scheduledLookup.push(runAtMillis);\r\n                scheduledLookup.sort(function (a, b) {\r\n                    return a - b;\r\n                });\r\n            }\r\n\r\n            return timeoutKey;\r\n        };\r\n\r\n        self.removeFunctionWithId = function(timeoutKey) {\r\n            for (var runAtMillis in scheduledFunctions) {\r\n                var funcs = scheduledFunctions[runAtMillis];\r\n                var i = indexOfFirstToPass(funcs, function (func) {\r\n                    return func.timeoutKey === timeoutKey;\r\n                });\r\n\r\n                if (i > -1) {\r\n                    if (funcs.length === 1) {\r\n                        delete scheduledFunctions[runAtMillis];\r\n                        deleteFromLookup(runAtMillis);\r\n                    } else {\r\n                        funcs.splice(i, 1);\r\n                    }\r\n\r\n                    // intervals get rescheduled when executed, so there's never more\r\n                    // than a single scheduled function with a given timeoutKey\r\n                    break;\r\n                }\r\n            }\r\n        };\r\n\r\n        self.reset = function() {\r\n            currentTime = 0;\r\n            scheduledLookup = [];\r\n            scheduledFunctions = {};\r\n            delayedFnCount = 0;\r\n        };\r\n\r\n        return self;\r\n\r\n        function indexOfFirstToPass(array, testFn) {\r\n            var index = -1;\r\n\r\n            for (var i = 0; i < array.length; ++i) {\r\n                if (testFn(array[i])) {\r\n                    index = i;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            return index;\r\n        }\r\n\r\n        function deleteFromLookup(key) {\r\n            var value = Number(key);\r\n            var i = indexOfFirstToPass(scheduledLookup, function (millis) {\r\n                return millis === value;\r\n            });\r\n\r\n            if (i > -1) {\r\n                scheduledLookup.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        function reschedule(scheduledFn) {\r\n            self.scheduleFunction(scheduledFn.funcToCall,\r\n                scheduledFn.millis,\r\n                scheduledFn.params,\r\n                true,\r\n                scheduledFn.timeoutKey,\r\n                scheduledFn.runAtMillis + scheduledFn.millis);\r\n        }\r\n\r\n        function forEachFunction(funcsToRun, callback) {\r\n            for (var i = 0; i < funcsToRun.length; ++i) {\r\n                callback(funcsToRun[i]);\r\n            }\r\n        }\r\n\r\n        function runScheduledFunctions(endTime) {\r\n            if (scheduledLookup.length === 0 || scheduledLookup[0] > endTime) {\r\n                return;\r\n            }\r\n\r\n            do {\r\n                currentTime = scheduledLookup.shift();\r\n\r\n                var funcsToRun = scheduledFunctions[currentTime];\r\n                delete scheduledFunctions[currentTime];\r\n\r\n                forEachFunction(funcsToRun, function(funcToRun) {\r\n                    if (funcToRun.recurring) {\r\n                        reschedule(funcToRun);\r\n                    }\r\n                });\r\n\r\n                forEachFunction(funcsToRun, function(funcToRun) {\r\n                    funcToRun.funcToCall.apply(null, funcToRun.params || []);\r\n                });\r\n            } while (scheduledLookup.length > 0 &&\r\n            // checking first if we're out of time prevents setTimeout(0)\r\n            // scheduled in a funcToRun from forcing an extra iteration\r\n            currentTime !== endTime  &&\r\n            scheduledLookup[0] <= endTime);\r\n        }\r\n    }\r\n\r\n    return DelayedFunctionScheduler;\r\n}","oldJSDoc":null,"type":"changedArgCount","typePath":"window.jasmineRequire.DelayedFunctionScheduler.[function].[return].[function].[return].tick","isClass":false,"newType":"(millis: number, tickDate: (arg0: void) => void) => void","newTypeDescription":"function","oldType":"(millis: number) => void","oldArgCount":1,"newArgCount":2,"containerType":"// Seen as: self\ninterface interface_798 {\n    removeFunctionWithId: (timeoutKey: any) => void;\n    scheduleFunction: (funcToCall: string | (() => any), millis: number, params: any, recurring: any, timeoutKey: number, newCurrentTime: string) => number;\n    tick: (millis: number, tickDate: (arg0: void) => void) => void;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.matchersUtil.[function].[return]","newFunction":"function(j$) {\r\n    // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?\r\n\r\n    return {\r\n        equals: function(a, b, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            return eq(a, b, [], [], customTesters);\r\n        },\r\n\r\n        contains: function(haystack, needle, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||\r\n                (!!haystack && !haystack.indexOf))\r\n            {\r\n                for (var i = 0; i < haystack.length; i++) {\r\n                    if (eq(haystack[i], needle, [], [], customTesters)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n\r\n            return !!haystack && haystack.indexOf(needle) >= 0;\r\n        },\r\n\r\n        buildFailureMessage: function() {\r\n            var args = Array.prototype.slice.call(arguments, 0),\r\n                matcherName = args[0],\r\n                isNot = args[1],\r\n                actual = args[2],\r\n                expected = args.slice(3),\r\n                englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\r\n\r\n            var message = 'Expected ' +\r\n                j$.pp(actual) +\r\n                (isNot ? ' not ' : ' ') +\r\n                englishyPredicate;\r\n\r\n            if (expected.length > 0) {\r\n                for (var i = 0; i < expected.length; i++) {\r\n                    if (i > 0) {\r\n                        message += ',';\r\n                    }\r\n                    message += ' ' + j$.pp(expected[i]);\r\n                }\r\n            }\r\n\r\n            return message + '.';\r\n        }\r\n    };\r\n\r\n    function isAsymmetric(obj) {\r\n        return obj && j$.isA_('Function', obj.asymmetricMatch);\r\n    }\r\n\r\n    function asymmetricMatch(a, b) {\r\n        var asymmetricA = isAsymmetric(a),\r\n            asymmetricB = isAsymmetric(b);\r\n\r\n        if (asymmetricA && asymmetricB) {\r\n            return undefined;\r\n        }\r\n\r\n        if (asymmetricA) {\r\n            return a.asymmetricMatch(b);\r\n        }\r\n\r\n        if (asymmetricB) {\r\n            return b.asymmetricMatch(a);\r\n        }\r\n    }\r\n\r\n    // Equality function lovingly adapted from isEqual in\r\n    //   [Underscore](http://underscorejs.org)\r\n    function eq(a, b, aStack, bStack, customTesters) {\r\n        var result = true;\r\n\r\n        var asymmetricResult = asymmetricMatch(a, b);\r\n        if (!j$.util.isUndefined(asymmetricResult)) {\r\n            return asymmetricResult;\r\n        }\r\n\r\n        for (var i = 0; i < customTesters.length; i++) {\r\n            var customTesterResult = customTesters[i](a, b);\r\n            if (!j$.util.isUndefined(customTesterResult)) {\r\n                return customTesterResult;\r\n            }\r\n        }\r\n\r\n        if (a instanceof Error && b instanceof Error) {\r\n            return a.message == b.message;\r\n        }\r\n\r\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n        if (a === b) { return a !== 0 || 1 / a == 1 / b; }\r\n        // A strict comparison is necessary because `null == undefined`.\r\n        if (a === null || b === null) { return a === b; }\r\n        var className = Object.prototype.toString.call(a);\r\n        if (className != Object.prototype.toString.call(b)) { return false; }\r\n        switch (className) {\r\n            // Strings, numbers, dates, and booleans are compared by value.\r\n            case '[object String]':\r\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n                // equivalent to `new String(\"5\")`.\r\n                return a == String(b);\r\n            case '[object Number]':\r\n                // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\r\n                // other numeric values.\r\n                return a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);\r\n            case '[object Date]':\r\n            case '[object Boolean]':\r\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n                // millisecond representations. Note that invalid dates with millisecond representations\r\n                // of `NaN` are not equivalent.\r\n                return +a == +b;\r\n            // RegExps are compared by their source patterns and flags.\r\n            case '[object RegExp]':\r\n                return a.source == b.source &&\r\n                    a.global == b.global &&\r\n                    a.multiline == b.multiline &&\r\n                    a.ignoreCase == b.ignoreCase;\r\n        }\r\n        if (typeof a != 'object' || typeof b != 'object') { return false; }\r\n\r\n        var aIsDomNode = j$.isDomNode(a);\r\n        var bIsDomNode = j$.isDomNode(b);\r\n        if (aIsDomNode && bIsDomNode) {\r\n            // At first try to use DOM3 method isEqualNode\r\n            if (a.isEqualNode) {\r\n                return a.isEqualNode(b);\r\n            }\r\n            // IE8 doesn't support isEqualNode, try to use outerHTML && innerText\r\n            var aIsElement = a instanceof Element;\r\n            var bIsElement = b instanceof Element;\r\n            if (aIsElement && bIsElement) {\r\n                return a.outerHTML == b.outerHTML;\r\n            }\r\n            if (aIsElement || bIsElement) {\r\n                return false;\r\n            }\r\n            return a.innerText == b.innerText && a.textContent == b.textContent;\r\n        }\r\n        if (aIsDomNode || bIsDomNode) {\r\n            return false;\r\n        }\r\n\r\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n        var length = aStack.length;\r\n        while (length--) {\r\n            // Linear search. Performance is inversely proportional to the number of\r\n            // unique nested structures.\r\n            if (aStack[length] == a) { return bStack[length] == b; }\r\n        }\r\n        // Add the first object to the stack of traversed objects.\r\n        aStack.push(a);\r\n        bStack.push(b);\r\n        var size = 0;\r\n        // Recursively compare objects and arrays.\r\n        // Compare array lengths to determine if a deep comparison is necessary.\r\n        if (className == '[object Array]') {\r\n            size = a.length;\r\n            if (size !== b.length) {\r\n                return false;\r\n            }\r\n\r\n            while (size--) {\r\n                result = eq(a[size], b[size], aStack, bStack, customTesters);\r\n                if (!result) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n\r\n            // Objects with different constructors are not equivalent, but `Object`s\r\n            // or `Array`s from different frames are.\r\n            var aCtor = a.constructor, bCtor = b.constructor;\r\n            if (aCtor !== bCtor && !(isObjectConstructor(aCtor) &&\r\n                isObjectConstructor(bCtor))) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Deep compare objects.\r\n        var aKeys = keys(a, className == '[object Array]'), key;\r\n        size = aKeys.length;\r\n\r\n        // Ensure that both objects contain the same number of properties before comparing deep equality.\r\n        if (keys(b, className == '[object Array]').length !== size) { return false; }\r\n\r\n        while (size--) {\r\n            key = aKeys[size];\r\n            // Deep compare each member\r\n            result = has(b, key) && eq(a[key], b[key], aStack, bStack, customTesters);\r\n\r\n            if (!result) {\r\n                return false;\r\n            }\r\n        }\r\n        // Remove the first object from the stack of traversed objects.\r\n        aStack.pop();\r\n        bStack.pop();\r\n\r\n        return result;\r\n\r\n        function keys(obj, isArray) {\r\n            var allKeys = Object.keys ? Object.keys(obj) :\r\n                (function(o) {\r\n                    var keys = [];\r\n                    for (var key in o) {\r\n                        if (has(o, key)) {\r\n                            keys.push(key);\r\n                        }\r\n                    }\r\n                    return keys;\r\n                })(obj);\r\n\r\n            if (!isArray) {\r\n                return allKeys;\r\n            }\r\n\r\n            var extraKeys = [];\r\n            for (var i in allKeys) {\r\n                if (!allKeys[i].match(/^[0-9]+$/)) {\r\n                    extraKeys.push(allKeys[i]);\r\n                }\r\n            }\r\n\r\n            return extraKeys;\r\n        }\r\n    }\r\n\r\n    function has(obj, key) {\r\n        return Object.prototype.hasOwnProperty.call(obj, key);\r\n    }\r\n\r\n    function isFunction(obj) {\r\n        return typeof obj === 'function';\r\n    }\r\n\r\n    function isObjectConstructor(ctor) {\r\n        // aCtor instanceof aCtor is true for the Object and Function\r\n        // constructors (since a constructor is-a Function and a function is-a\r\n        // Object). We don't just compare ctor === Object because the constructor\r\n        // might come from a different frame with different globals.\r\n        return isFunction(ctor) && ctor instanceof ctor;\r\n    }\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.matchersUtil.[function].[return]","oldFunction":"function(j$) {\r\n    // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?\r\n\r\n    return {\r\n        equals: function(a, b, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            return eq(a, b, [], [], customTesters);\r\n        },\r\n\r\n        contains: function(haystack, needle, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||\r\n                (!!haystack && !haystack.indexOf))\r\n            {\r\n                for (var i = 0; i < haystack.length; i++) {\r\n                    if (eq(haystack[i], needle, [], [], customTesters)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n\r\n            return !!haystack && haystack.indexOf(needle) >= 0;\r\n        },\r\n\r\n        buildFailureMessage: function() {\r\n            var args = Array.prototype.slice.call(arguments, 0),\r\n                matcherName = args[0],\r\n                isNot = args[1],\r\n                actual = args[2],\r\n                expected = args.slice(3),\r\n                englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\r\n\r\n            var message = 'Expected ' +\r\n                j$.pp(actual) +\r\n                (isNot ? ' not ' : ' ') +\r\n                englishyPredicate;\r\n\r\n            if (expected.length > 0) {\r\n                for (var i = 0; i < expected.length; i++) {\r\n                    if (i > 0) {\r\n                        message += ',';\r\n                    }\r\n                    message += ' ' + j$.pp(expected[i]);\r\n                }\r\n            }\r\n\r\n            return message + '.';\r\n        }\r\n    };\r\n\r\n    function isAsymmetric(obj) {\r\n        return obj && j$.isA_('Function', obj.asymmetricMatch);\r\n    }\r\n\r\n    function asymmetricMatch(a, b) {\r\n        var asymmetricA = isAsymmetric(a),\r\n            asymmetricB = isAsymmetric(b);\r\n\r\n        if (asymmetricA && asymmetricB) {\r\n            return undefined;\r\n        }\r\n\r\n        if (asymmetricA) {\r\n            return a.asymmetricMatch(b);\r\n        }\r\n\r\n        if (asymmetricB) {\r\n            return b.asymmetricMatch(a);\r\n        }\r\n    }\r\n\r\n    // Equality function lovingly adapted from isEqual in\r\n    //   [Underscore](http://underscorejs.org)\r\n    function eq(a, b, aStack, bStack, customTesters) {\r\n        var result = true;\r\n\r\n        var asymmetricResult = asymmetricMatch(a, b);\r\n        if (!j$.util.isUndefined(asymmetricResult)) {\r\n            return asymmetricResult;\r\n        }\r\n\r\n        for (var i = 0; i < customTesters.length; i++) {\r\n            var customTesterResult = customTesters[i](a, b);\r\n            if (!j$.util.isUndefined(customTesterResult)) {\r\n                return customTesterResult;\r\n            }\r\n        }\r\n\r\n        if (a instanceof Error && b instanceof Error) {\r\n            return a.message == b.message;\r\n        }\r\n\r\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n        if (a === b) { return a !== 0 || 1 / a == 1 / b; }\r\n        // A strict comparison is necessary because `null == undefined`.\r\n        if (a === null || b === null) { return a === b; }\r\n        var className = Object.prototype.toString.call(a);\r\n        if (className != Object.prototype.toString.call(b)) { return false; }\r\n        switch (className) {\r\n            // Strings, numbers, dates, and booleans are compared by value.\r\n            case '[object String]':\r\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n                // equivalent to `new String(\"5\")`.\r\n                return a == String(b);\r\n            case '[object Number]':\r\n                // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\r\n                // other numeric values.\r\n                return a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);\r\n            case '[object Date]':\r\n            case '[object Boolean]':\r\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n                // millisecond representations. Note that invalid dates with millisecond representations\r\n                // of `NaN` are not equivalent.\r\n                return +a == +b;\r\n            // RegExps are compared by their source patterns and flags.\r\n            case '[object RegExp]':\r\n                return a.source == b.source &&\r\n                    a.global == b.global &&\r\n                    a.multiline == b.multiline &&\r\n                    a.ignoreCase == b.ignoreCase;\r\n        }\r\n        if (typeof a != 'object' || typeof b != 'object') { return false; }\r\n\r\n        var aIsDomNode = j$.isDomNode(a);\r\n        var bIsDomNode = j$.isDomNode(b);\r\n        if (aIsDomNode && bIsDomNode) {\r\n            // At first try to use DOM3 method isEqualNode\r\n            if (a.isEqualNode) {\r\n                return a.isEqualNode(b);\r\n            }\r\n            // IE8 doesn't support isEqualNode, try to use outerHTML && innerText\r\n            var aIsElement = a instanceof Element;\r\n            var bIsElement = b instanceof Element;\r\n            if (aIsElement && bIsElement) {\r\n                return a.outerHTML == b.outerHTML;\r\n            }\r\n            if (aIsElement || bIsElement) {\r\n                return false;\r\n            }\r\n            return a.innerText == b.innerText && a.textContent == b.textContent;\r\n        }\r\n        if (aIsDomNode || bIsDomNode) {\r\n            return false;\r\n        }\r\n\r\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n        var length = aStack.length;\r\n        while (length--) {\r\n            // Linear search. Performance is inversely proportional to the number of\r\n            // unique nested structures.\r\n            if (aStack[length] == a) { return bStack[length] == b; }\r\n        }\r\n        // Add the first object to the stack of traversed objects.\r\n        aStack.push(a);\r\n        bStack.push(b);\r\n        var size = 0;\r\n        // Recursively compare objects and arrays.\r\n        // Compare array lengths to determine if a deep comparison is necessary.\r\n        if (className == '[object Array]' && a.length !== b.length) {\r\n            result = false;\r\n        }\r\n\r\n        if (result) {\r\n            // Objects with different constructors are not equivalent, but `Object`s\r\n            // from different frames are.\r\n            var aCtor = a.constructor, bCtor = b.constructor;\r\n            if (aCtor !== bCtor && !(isFunction(aCtor) && (aCtor instanceof aCtor) &&\r\n                isFunction(bCtor) && (bCtor instanceof bCtor))) {\r\n                return false;\r\n            }\r\n            // Deep compare objects.\r\n            for (var key in a) {\r\n                if (has(a, key)) {\r\n                    // Count the expected number of properties.\r\n                    size++;\r\n                    // Deep compare each member.\r\n                    if (!(result = has(b, key) && eq(a[key], b[key], aStack, bStack, customTesters))) { break; }\r\n                }\r\n            }\r\n            // Ensure that both objects contain the same number of properties.\r\n            if (result) {\r\n                for (key in b) {\r\n                    if (has(b, key) && !(size--)) { break; }\r\n                }\r\n                result = !size;\r\n            }\r\n        }\r\n        // Remove the first object from the stack of traversed objects.\r\n        aStack.pop();\r\n        bStack.pop();\r\n\r\n        return result;\r\n\r\n        function has(obj, key) {\r\n            return Object.prototype.hasOwnProperty.call(obj, key);\r\n        }\r\n\r\n        function isFunction(obj) {\r\n            return typeof obj === 'function';\r\n        }\r\n    }\r\n}","oldJSDoc":null,"type":"changedType","typePath":"window.jasmineRequire.matchersUtil.[function].[return].contains.[function].[arg1]","newType":"string | interface_565","oldType":"string | interface_825","containerType":"(haystack: interface_560, needle: string | interface_565, customTesters: Array<function_875>) => boolean","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.matchersUtil.[function].[return]","newFunction":"function(j$) {\r\n    // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?\r\n\r\n    return {\r\n        equals: function(a, b, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            return eq(a, b, [], [], customTesters);\r\n        },\r\n\r\n        contains: function(haystack, needle, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||\r\n                (!!haystack && !haystack.indexOf))\r\n            {\r\n                for (var i = 0; i < haystack.length; i++) {\r\n                    if (eq(haystack[i], needle, [], [], customTesters)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n\r\n            return !!haystack && haystack.indexOf(needle) >= 0;\r\n        },\r\n\r\n        buildFailureMessage: function() {\r\n            var args = Array.prototype.slice.call(arguments, 0),\r\n                matcherName = args[0],\r\n                isNot = args[1],\r\n                actual = args[2],\r\n                expected = args.slice(3),\r\n                englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\r\n\r\n            var message = 'Expected ' +\r\n                j$.pp(actual) +\r\n                (isNot ? ' not ' : ' ') +\r\n                englishyPredicate;\r\n\r\n            if (expected.length > 0) {\r\n                for (var i = 0; i < expected.length; i++) {\r\n                    if (i > 0) {\r\n                        message += ',';\r\n                    }\r\n                    message += ' ' + j$.pp(expected[i]);\r\n                }\r\n            }\r\n\r\n            return message + '.';\r\n        }\r\n    };\r\n\r\n    function isAsymmetric(obj) {\r\n        return obj && j$.isA_('Function', obj.asymmetricMatch);\r\n    }\r\n\r\n    function asymmetricMatch(a, b) {\r\n        var asymmetricA = isAsymmetric(a),\r\n            asymmetricB = isAsymmetric(b);\r\n\r\n        if (asymmetricA && asymmetricB) {\r\n            return undefined;\r\n        }\r\n\r\n        if (asymmetricA) {\r\n            return a.asymmetricMatch(b);\r\n        }\r\n\r\n        if (asymmetricB) {\r\n            return b.asymmetricMatch(a);\r\n        }\r\n    }\r\n\r\n    // Equality function lovingly adapted from isEqual in\r\n    //   [Underscore](http://underscorejs.org)\r\n    function eq(a, b, aStack, bStack, customTesters) {\r\n        var result = true;\r\n\r\n        var asymmetricResult = asymmetricMatch(a, b);\r\n        if (!j$.util.isUndefined(asymmetricResult)) {\r\n            return asymmetricResult;\r\n        }\r\n\r\n        for (var i = 0; i < customTesters.length; i++) {\r\n            var customTesterResult = customTesters[i](a, b);\r\n            if (!j$.util.isUndefined(customTesterResult)) {\r\n                return customTesterResult;\r\n            }\r\n        }\r\n\r\n        if (a instanceof Error && b instanceof Error) {\r\n            return a.message == b.message;\r\n        }\r\n\r\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n        if (a === b) { return a !== 0 || 1 / a == 1 / b; }\r\n        // A strict comparison is necessary because `null == undefined`.\r\n        if (a === null || b === null) { return a === b; }\r\n        var className = Object.prototype.toString.call(a);\r\n        if (className != Object.prototype.toString.call(b)) { return false; }\r\n        switch (className) {\r\n            // Strings, numbers, dates, and booleans are compared by value.\r\n            case '[object String]':\r\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n                // equivalent to `new String(\"5\")`.\r\n                return a == String(b);\r\n            case '[object Number]':\r\n                // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\r\n                // other numeric values.\r\n                return a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);\r\n            case '[object Date]':\r\n            case '[object Boolean]':\r\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n                // millisecond representations. Note that invalid dates with millisecond representations\r\n                // of `NaN` are not equivalent.\r\n                return +a == +b;\r\n            // RegExps are compared by their source patterns and flags.\r\n            case '[object RegExp]':\r\n                return a.source == b.source &&\r\n                    a.global == b.global &&\r\n                    a.multiline == b.multiline &&\r\n                    a.ignoreCase == b.ignoreCase;\r\n        }\r\n        if (typeof a != 'object' || typeof b != 'object') { return false; }\r\n\r\n        var aIsDomNode = j$.isDomNode(a);\r\n        var bIsDomNode = j$.isDomNode(b);\r\n        if (aIsDomNode && bIsDomNode) {\r\n            // At first try to use DOM3 method isEqualNode\r\n            if (a.isEqualNode) {\r\n                return a.isEqualNode(b);\r\n            }\r\n            // IE8 doesn't support isEqualNode, try to use outerHTML && innerText\r\n            var aIsElement = a instanceof Element;\r\n            var bIsElement = b instanceof Element;\r\n            if (aIsElement && bIsElement) {\r\n                return a.outerHTML == b.outerHTML;\r\n            }\r\n            if (aIsElement || bIsElement) {\r\n                return false;\r\n            }\r\n            return a.innerText == b.innerText && a.textContent == b.textContent;\r\n        }\r\n        if (aIsDomNode || bIsDomNode) {\r\n            return false;\r\n        }\r\n\r\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n        var length = aStack.length;\r\n        while (length--) {\r\n            // Linear search. Performance is inversely proportional to the number of\r\n            // unique nested structures.\r\n            if (aStack[length] == a) { return bStack[length] == b; }\r\n        }\r\n        // Add the first object to the stack of traversed objects.\r\n        aStack.push(a);\r\n        bStack.push(b);\r\n        var size = 0;\r\n        // Recursively compare objects and arrays.\r\n        // Compare array lengths to determine if a deep comparison is necessary.\r\n        if (className == '[object Array]') {\r\n            size = a.length;\r\n            if (size !== b.length) {\r\n                return false;\r\n            }\r\n\r\n            while (size--) {\r\n                result = eq(a[size], b[size], aStack, bStack, customTesters);\r\n                if (!result) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n\r\n            // Objects with different constructors are not equivalent, but `Object`s\r\n            // or `Array`s from different frames are.\r\n            var aCtor = a.constructor, bCtor = b.constructor;\r\n            if (aCtor !== bCtor && !(isObjectConstructor(aCtor) &&\r\n                isObjectConstructor(bCtor))) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Deep compare objects.\r\n        var aKeys = keys(a, className == '[object Array]'), key;\r\n        size = aKeys.length;\r\n\r\n        // Ensure that both objects contain the same number of properties before comparing deep equality.\r\n        if (keys(b, className == '[object Array]').length !== size) { return false; }\r\n\r\n        while (size--) {\r\n            key = aKeys[size];\r\n            // Deep compare each member\r\n            result = has(b, key) && eq(a[key], b[key], aStack, bStack, customTesters);\r\n\r\n            if (!result) {\r\n                return false;\r\n            }\r\n        }\r\n        // Remove the first object from the stack of traversed objects.\r\n        aStack.pop();\r\n        bStack.pop();\r\n\r\n        return result;\r\n\r\n        function keys(obj, isArray) {\r\n            var allKeys = Object.keys ? Object.keys(obj) :\r\n                (function(o) {\r\n                    var keys = [];\r\n                    for (var key in o) {\r\n                        if (has(o, key)) {\r\n                            keys.push(key);\r\n                        }\r\n                    }\r\n                    return keys;\r\n                })(obj);\r\n\r\n            if (!isArray) {\r\n                return allKeys;\r\n            }\r\n\r\n            var extraKeys = [];\r\n            for (var i in allKeys) {\r\n                if (!allKeys[i].match(/^[0-9]+$/)) {\r\n                    extraKeys.push(allKeys[i]);\r\n                }\r\n            }\r\n\r\n            return extraKeys;\r\n        }\r\n    }\r\n\r\n    function has(obj, key) {\r\n        return Object.prototype.hasOwnProperty.call(obj, key);\r\n    }\r\n\r\n    function isFunction(obj) {\r\n        return typeof obj === 'function';\r\n    }\r\n\r\n    function isObjectConstructor(ctor) {\r\n        // aCtor instanceof aCtor is true for the Object and Function\r\n        // constructors (since a constructor is-a Function and a function is-a\r\n        // Object). We don't just compare ctor === Object because the constructor\r\n        // might come from a different frame with different globals.\r\n        return isFunction(ctor) && ctor instanceof ctor;\r\n    }\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.matchersUtil.[function].[return]","oldFunction":"function(j$) {\r\n    // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?\r\n\r\n    return {\r\n        equals: function(a, b, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            return eq(a, b, [], [], customTesters);\r\n        },\r\n\r\n        contains: function(haystack, needle, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||\r\n                (!!haystack && !haystack.indexOf))\r\n            {\r\n                for (var i = 0; i < haystack.length; i++) {\r\n                    if (eq(haystack[i], needle, [], [], customTesters)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n\r\n            return !!haystack && haystack.indexOf(needle) >= 0;\r\n        },\r\n\r\n        buildFailureMessage: function() {\r\n            var args = Array.prototype.slice.call(arguments, 0),\r\n                matcherName = args[0],\r\n                isNot = args[1],\r\n                actual = args[2],\r\n                expected = args.slice(3),\r\n                englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\r\n\r\n            var message = 'Expected ' +\r\n                j$.pp(actual) +\r\n                (isNot ? ' not ' : ' ') +\r\n                englishyPredicate;\r\n\r\n            if (expected.length > 0) {\r\n                for (var i = 0; i < expected.length; i++) {\r\n                    if (i > 0) {\r\n                        message += ',';\r\n                    }\r\n                    message += ' ' + j$.pp(expected[i]);\r\n                }\r\n            }\r\n\r\n            return message + '.';\r\n        }\r\n    };\r\n\r\n    function isAsymmetric(obj) {\r\n        return obj && j$.isA_('Function', obj.asymmetricMatch);\r\n    }\r\n\r\n    function asymmetricMatch(a, b) {\r\n        var asymmetricA = isAsymmetric(a),\r\n            asymmetricB = isAsymmetric(b);\r\n\r\n        if (asymmetricA && asymmetricB) {\r\n            return undefined;\r\n        }\r\n\r\n        if (asymmetricA) {\r\n            return a.asymmetricMatch(b);\r\n        }\r\n\r\n        if (asymmetricB) {\r\n            return b.asymmetricMatch(a);\r\n        }\r\n    }\r\n\r\n    // Equality function lovingly adapted from isEqual in\r\n    //   [Underscore](http://underscorejs.org)\r\n    function eq(a, b, aStack, bStack, customTesters) {\r\n        var result = true;\r\n\r\n        var asymmetricResult = asymmetricMatch(a, b);\r\n        if (!j$.util.isUndefined(asymmetricResult)) {\r\n            return asymmetricResult;\r\n        }\r\n\r\n        for (var i = 0; i < customTesters.length; i++) {\r\n            var customTesterResult = customTesters[i](a, b);\r\n            if (!j$.util.isUndefined(customTesterResult)) {\r\n                return customTesterResult;\r\n            }\r\n        }\r\n\r\n        if (a instanceof Error && b instanceof Error) {\r\n            return a.message == b.message;\r\n        }\r\n\r\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n        if (a === b) { return a !== 0 || 1 / a == 1 / b; }\r\n        // A strict comparison is necessary because `null == undefined`.\r\n        if (a === null || b === null) { return a === b; }\r\n        var className = Object.prototype.toString.call(a);\r\n        if (className != Object.prototype.toString.call(b)) { return false; }\r\n        switch (className) {\r\n            // Strings, numbers, dates, and booleans are compared by value.\r\n            case '[object String]':\r\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n                // equivalent to `new String(\"5\")`.\r\n                return a == String(b);\r\n            case '[object Number]':\r\n                // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\r\n                // other numeric values.\r\n                return a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);\r\n            case '[object Date]':\r\n            case '[object Boolean]':\r\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n                // millisecond representations. Note that invalid dates with millisecond representations\r\n                // of `NaN` are not equivalent.\r\n                return +a == +b;\r\n            // RegExps are compared by their source patterns and flags.\r\n            case '[object RegExp]':\r\n                return a.source == b.source &&\r\n                    a.global == b.global &&\r\n                    a.multiline == b.multiline &&\r\n                    a.ignoreCase == b.ignoreCase;\r\n        }\r\n        if (typeof a != 'object' || typeof b != 'object') { return false; }\r\n\r\n        var aIsDomNode = j$.isDomNode(a);\r\n        var bIsDomNode = j$.isDomNode(b);\r\n        if (aIsDomNode && bIsDomNode) {\r\n            // At first try to use DOM3 method isEqualNode\r\n            if (a.isEqualNode) {\r\n                return a.isEqualNode(b);\r\n            }\r\n            // IE8 doesn't support isEqualNode, try to use outerHTML && innerText\r\n            var aIsElement = a instanceof Element;\r\n            var bIsElement = b instanceof Element;\r\n            if (aIsElement && bIsElement) {\r\n                return a.outerHTML == b.outerHTML;\r\n            }\r\n            if (aIsElement || bIsElement) {\r\n                return false;\r\n            }\r\n            return a.innerText == b.innerText && a.textContent == b.textContent;\r\n        }\r\n        if (aIsDomNode || bIsDomNode) {\r\n            return false;\r\n        }\r\n\r\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n        var length = aStack.length;\r\n        while (length--) {\r\n            // Linear search. Performance is inversely proportional to the number of\r\n            // unique nested structures.\r\n            if (aStack[length] == a) { return bStack[length] == b; }\r\n        }\r\n        // Add the first object to the stack of traversed objects.\r\n        aStack.push(a);\r\n        bStack.push(b);\r\n        var size = 0;\r\n        // Recursively compare objects and arrays.\r\n        // Compare array lengths to determine if a deep comparison is necessary.\r\n        if (className == '[object Array]' && a.length !== b.length) {\r\n            result = false;\r\n        }\r\n\r\n        if (result) {\r\n            // Objects with different constructors are not equivalent, but `Object`s\r\n            // from different frames are.\r\n            var aCtor = a.constructor, bCtor = b.constructor;\r\n            if (aCtor !== bCtor && !(isFunction(aCtor) && (aCtor instanceof aCtor) &&\r\n                isFunction(bCtor) && (bCtor instanceof bCtor))) {\r\n                return false;\r\n            }\r\n            // Deep compare objects.\r\n            for (var key in a) {\r\n                if (has(a, key)) {\r\n                    // Count the expected number of properties.\r\n                    size++;\r\n                    // Deep compare each member.\r\n                    if (!(result = has(b, key) && eq(a[key], b[key], aStack, bStack, customTesters))) { break; }\r\n                }\r\n            }\r\n            // Ensure that both objects contain the same number of properties.\r\n            if (result) {\r\n                for (key in b) {\r\n                    if (has(b, key) && !(size--)) { break; }\r\n                }\r\n                result = !size;\r\n            }\r\n        }\r\n        // Remove the first object from the stack of traversed objects.\r\n        aStack.pop();\r\n        bStack.pop();\r\n\r\n        return result;\r\n\r\n        function has(obj, key) {\r\n            return Object.prototype.hasOwnProperty.call(obj, key);\r\n        }\r\n\r\n        function isFunction(obj) {\r\n            return typeof obj === 'function';\r\n        }\r\n    }\r\n}","oldJSDoc":null,"type":"changedType","typePath":"window.jasmineRequire.matchersUtil.[function].[return].equals.[function].[arg1]","newType":"string | interface_575","oldType":"string | interface_829","containerType":"(a: string | interface_573, b: string | interface_575, customTesters: Array<function_875>) => boolean","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.matchersUtil.[function].[return]","newFunction":"function(j$) {\r\n    // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?\r\n\r\n    return {\r\n        equals: function(a, b, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            return eq(a, b, [], [], customTesters);\r\n        },\r\n\r\n        contains: function(haystack, needle, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||\r\n                (!!haystack && !haystack.indexOf))\r\n            {\r\n                for (var i = 0; i < haystack.length; i++) {\r\n                    if (eq(haystack[i], needle, [], [], customTesters)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n\r\n            return !!haystack && haystack.indexOf(needle) >= 0;\r\n        },\r\n\r\n        buildFailureMessage: function() {\r\n            var args = Array.prototype.slice.call(arguments, 0),\r\n                matcherName = args[0],\r\n                isNot = args[1],\r\n                actual = args[2],\r\n                expected = args.slice(3),\r\n                englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\r\n\r\n            var message = 'Expected ' +\r\n                j$.pp(actual) +\r\n                (isNot ? ' not ' : ' ') +\r\n                englishyPredicate;\r\n\r\n            if (expected.length > 0) {\r\n                for (var i = 0; i < expected.length; i++) {\r\n                    if (i > 0) {\r\n                        message += ',';\r\n                    }\r\n                    message += ' ' + j$.pp(expected[i]);\r\n                }\r\n            }\r\n\r\n            return message + '.';\r\n        }\r\n    };\r\n\r\n    function isAsymmetric(obj) {\r\n        return obj && j$.isA_('Function', obj.asymmetricMatch);\r\n    }\r\n\r\n    function asymmetricMatch(a, b) {\r\n        var asymmetricA = isAsymmetric(a),\r\n            asymmetricB = isAsymmetric(b);\r\n\r\n        if (asymmetricA && asymmetricB) {\r\n            return undefined;\r\n        }\r\n\r\n        if (asymmetricA) {\r\n            return a.asymmetricMatch(b);\r\n        }\r\n\r\n        if (asymmetricB) {\r\n            return b.asymmetricMatch(a);\r\n        }\r\n    }\r\n\r\n    // Equality function lovingly adapted from isEqual in\r\n    //   [Underscore](http://underscorejs.org)\r\n    function eq(a, b, aStack, bStack, customTesters) {\r\n        var result = true;\r\n\r\n        var asymmetricResult = asymmetricMatch(a, b);\r\n        if (!j$.util.isUndefined(asymmetricResult)) {\r\n            return asymmetricResult;\r\n        }\r\n\r\n        for (var i = 0; i < customTesters.length; i++) {\r\n            var customTesterResult = customTesters[i](a, b);\r\n            if (!j$.util.isUndefined(customTesterResult)) {\r\n                return customTesterResult;\r\n            }\r\n        }\r\n\r\n        if (a instanceof Error && b instanceof Error) {\r\n            return a.message == b.message;\r\n        }\r\n\r\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n        if (a === b) { return a !== 0 || 1 / a == 1 / b; }\r\n        // A strict comparison is necessary because `null == undefined`.\r\n        if (a === null || b === null) { return a === b; }\r\n        var className = Object.prototype.toString.call(a);\r\n        if (className != Object.prototype.toString.call(b)) { return false; }\r\n        switch (className) {\r\n            // Strings, numbers, dates, and booleans are compared by value.\r\n            case '[object String]':\r\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n                // equivalent to `new String(\"5\")`.\r\n                return a == String(b);\r\n            case '[object Number]':\r\n                // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\r\n                // other numeric values.\r\n                return a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);\r\n            case '[object Date]':\r\n            case '[object Boolean]':\r\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n                // millisecond representations. Note that invalid dates with millisecond representations\r\n                // of `NaN` are not equivalent.\r\n                return +a == +b;\r\n            // RegExps are compared by their source patterns and flags.\r\n            case '[object RegExp]':\r\n                return a.source == b.source &&\r\n                    a.global == b.global &&\r\n                    a.multiline == b.multiline &&\r\n                    a.ignoreCase == b.ignoreCase;\r\n        }\r\n        if (typeof a != 'object' || typeof b != 'object') { return false; }\r\n\r\n        var aIsDomNode = j$.isDomNode(a);\r\n        var bIsDomNode = j$.isDomNode(b);\r\n        if (aIsDomNode && bIsDomNode) {\r\n            // At first try to use DOM3 method isEqualNode\r\n            if (a.isEqualNode) {\r\n                return a.isEqualNode(b);\r\n            }\r\n            // IE8 doesn't support isEqualNode, try to use outerHTML && innerText\r\n            var aIsElement = a instanceof Element;\r\n            var bIsElement = b instanceof Element;\r\n            if (aIsElement && bIsElement) {\r\n                return a.outerHTML == b.outerHTML;\r\n            }\r\n            if (aIsElement || bIsElement) {\r\n                return false;\r\n            }\r\n            return a.innerText == b.innerText && a.textContent == b.textContent;\r\n        }\r\n        if (aIsDomNode || bIsDomNode) {\r\n            return false;\r\n        }\r\n\r\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n        var length = aStack.length;\r\n        while (length--) {\r\n            // Linear search. Performance is inversely proportional to the number of\r\n            // unique nested structures.\r\n            if (aStack[length] == a) { return bStack[length] == b; }\r\n        }\r\n        // Add the first object to the stack of traversed objects.\r\n        aStack.push(a);\r\n        bStack.push(b);\r\n        var size = 0;\r\n        // Recursively compare objects and arrays.\r\n        // Compare array lengths to determine if a deep comparison is necessary.\r\n        if (className == '[object Array]') {\r\n            size = a.length;\r\n            if (size !== b.length) {\r\n                return false;\r\n            }\r\n\r\n            while (size--) {\r\n                result = eq(a[size], b[size], aStack, bStack, customTesters);\r\n                if (!result) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n\r\n            // Objects with different constructors are not equivalent, but `Object`s\r\n            // or `Array`s from different frames are.\r\n            var aCtor = a.constructor, bCtor = b.constructor;\r\n            if (aCtor !== bCtor && !(isObjectConstructor(aCtor) &&\r\n                isObjectConstructor(bCtor))) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Deep compare objects.\r\n        var aKeys = keys(a, className == '[object Array]'), key;\r\n        size = aKeys.length;\r\n\r\n        // Ensure that both objects contain the same number of properties before comparing deep equality.\r\n        if (keys(b, className == '[object Array]').length !== size) { return false; }\r\n\r\n        while (size--) {\r\n            key = aKeys[size];\r\n            // Deep compare each member\r\n            result = has(b, key) && eq(a[key], b[key], aStack, bStack, customTesters);\r\n\r\n            if (!result) {\r\n                return false;\r\n            }\r\n        }\r\n        // Remove the first object from the stack of traversed objects.\r\n        aStack.pop();\r\n        bStack.pop();\r\n\r\n        return result;\r\n\r\n        function keys(obj, isArray) {\r\n            var allKeys = Object.keys ? Object.keys(obj) :\r\n                (function(o) {\r\n                    var keys = [];\r\n                    for (var key in o) {\r\n                        if (has(o, key)) {\r\n                            keys.push(key);\r\n                        }\r\n                    }\r\n                    return keys;\r\n                })(obj);\r\n\r\n            if (!isArray) {\r\n                return allKeys;\r\n            }\r\n\r\n            var extraKeys = [];\r\n            for (var i in allKeys) {\r\n                if (!allKeys[i].match(/^[0-9]+$/)) {\r\n                    extraKeys.push(allKeys[i]);\r\n                }\r\n            }\r\n\r\n            return extraKeys;\r\n        }\r\n    }\r\n\r\n    function has(obj, key) {\r\n        return Object.prototype.hasOwnProperty.call(obj, key);\r\n    }\r\n\r\n    function isFunction(obj) {\r\n        return typeof obj === 'function';\r\n    }\r\n\r\n    function isObjectConstructor(ctor) {\r\n        // aCtor instanceof aCtor is true for the Object and Function\r\n        // constructors (since a constructor is-a Function and a function is-a\r\n        // Object). We don't just compare ctor === Object because the constructor\r\n        // might come from a different frame with different globals.\r\n        return isFunction(ctor) && ctor instanceof ctor;\r\n    }\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.matchersUtil.[function].[return]","oldFunction":"function(j$) {\r\n    // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?\r\n\r\n    return {\r\n        equals: function(a, b, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            return eq(a, b, [], [], customTesters);\r\n        },\r\n\r\n        contains: function(haystack, needle, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||\r\n                (!!haystack && !haystack.indexOf))\r\n            {\r\n                for (var i = 0; i < haystack.length; i++) {\r\n                    if (eq(haystack[i], needle, [], [], customTesters)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n\r\n            return !!haystack && haystack.indexOf(needle) >= 0;\r\n        },\r\n\r\n        buildFailureMessage: function() {\r\n            var args = Array.prototype.slice.call(arguments, 0),\r\n                matcherName = args[0],\r\n                isNot = args[1],\r\n                actual = args[2],\r\n                expected = args.slice(3),\r\n                englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\r\n\r\n            var message = 'Expected ' +\r\n                j$.pp(actual) +\r\n                (isNot ? ' not ' : ' ') +\r\n                englishyPredicate;\r\n\r\n            if (expected.length > 0) {\r\n                for (var i = 0; i < expected.length; i++) {\r\n                    if (i > 0) {\r\n                        message += ',';\r\n                    }\r\n                    message += ' ' + j$.pp(expected[i]);\r\n                }\r\n            }\r\n\r\n            return message + '.';\r\n        }\r\n    };\r\n\r\n    function isAsymmetric(obj) {\r\n        return obj && j$.isA_('Function', obj.asymmetricMatch);\r\n    }\r\n\r\n    function asymmetricMatch(a, b) {\r\n        var asymmetricA = isAsymmetric(a),\r\n            asymmetricB = isAsymmetric(b);\r\n\r\n        if (asymmetricA && asymmetricB) {\r\n            return undefined;\r\n        }\r\n\r\n        if (asymmetricA) {\r\n            return a.asymmetricMatch(b);\r\n        }\r\n\r\n        if (asymmetricB) {\r\n            return b.asymmetricMatch(a);\r\n        }\r\n    }\r\n\r\n    // Equality function lovingly adapted from isEqual in\r\n    //   [Underscore](http://underscorejs.org)\r\n    function eq(a, b, aStack, bStack, customTesters) {\r\n        var result = true;\r\n\r\n        var asymmetricResult = asymmetricMatch(a, b);\r\n        if (!j$.util.isUndefined(asymmetricResult)) {\r\n            return asymmetricResult;\r\n        }\r\n\r\n        for (var i = 0; i < customTesters.length; i++) {\r\n            var customTesterResult = customTesters[i](a, b);\r\n            if (!j$.util.isUndefined(customTesterResult)) {\r\n                return customTesterResult;\r\n            }\r\n        }\r\n\r\n        if (a instanceof Error && b instanceof Error) {\r\n            return a.message == b.message;\r\n        }\r\n\r\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n        if (a === b) { return a !== 0 || 1 / a == 1 / b; }\r\n        // A strict comparison is necessary because `null == undefined`.\r\n        if (a === null || b === null) { return a === b; }\r\n        var className = Object.prototype.toString.call(a);\r\n        if (className != Object.prototype.toString.call(b)) { return false; }\r\n        switch (className) {\r\n            // Strings, numbers, dates, and booleans are compared by value.\r\n            case '[object String]':\r\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n                // equivalent to `new String(\"5\")`.\r\n                return a == String(b);\r\n            case '[object Number]':\r\n                // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\r\n                // other numeric values.\r\n                return a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);\r\n            case '[object Date]':\r\n            case '[object Boolean]':\r\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n                // millisecond representations. Note that invalid dates with millisecond representations\r\n                // of `NaN` are not equivalent.\r\n                return +a == +b;\r\n            // RegExps are compared by their source patterns and flags.\r\n            case '[object RegExp]':\r\n                return a.source == b.source &&\r\n                    a.global == b.global &&\r\n                    a.multiline == b.multiline &&\r\n                    a.ignoreCase == b.ignoreCase;\r\n        }\r\n        if (typeof a != 'object' || typeof b != 'object') { return false; }\r\n\r\n        var aIsDomNode = j$.isDomNode(a);\r\n        var bIsDomNode = j$.isDomNode(b);\r\n        if (aIsDomNode && bIsDomNode) {\r\n            // At first try to use DOM3 method isEqualNode\r\n            if (a.isEqualNode) {\r\n                return a.isEqualNode(b);\r\n            }\r\n            // IE8 doesn't support isEqualNode, try to use outerHTML && innerText\r\n            var aIsElement = a instanceof Element;\r\n            var bIsElement = b instanceof Element;\r\n            if (aIsElement && bIsElement) {\r\n                return a.outerHTML == b.outerHTML;\r\n            }\r\n            if (aIsElement || bIsElement) {\r\n                return false;\r\n            }\r\n            return a.innerText == b.innerText && a.textContent == b.textContent;\r\n        }\r\n        if (aIsDomNode || bIsDomNode) {\r\n            return false;\r\n        }\r\n\r\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n        var length = aStack.length;\r\n        while (length--) {\r\n            // Linear search. Performance is inversely proportional to the number of\r\n            // unique nested structures.\r\n            if (aStack[length] == a) { return bStack[length] == b; }\r\n        }\r\n        // Add the first object to the stack of traversed objects.\r\n        aStack.push(a);\r\n        bStack.push(b);\r\n        var size = 0;\r\n        // Recursively compare objects and arrays.\r\n        // Compare array lengths to determine if a deep comparison is necessary.\r\n        if (className == '[object Array]' && a.length !== b.length) {\r\n            result = false;\r\n        }\r\n\r\n        if (result) {\r\n            // Objects with different constructors are not equivalent, but `Object`s\r\n            // from different frames are.\r\n            var aCtor = a.constructor, bCtor = b.constructor;\r\n            if (aCtor !== bCtor && !(isFunction(aCtor) && (aCtor instanceof aCtor) &&\r\n                isFunction(bCtor) && (bCtor instanceof bCtor))) {\r\n                return false;\r\n            }\r\n            // Deep compare objects.\r\n            for (var key in a) {\r\n                if (has(a, key)) {\r\n                    // Count the expected number of properties.\r\n                    size++;\r\n                    // Deep compare each member.\r\n                    if (!(result = has(b, key) && eq(a[key], b[key], aStack, bStack, customTesters))) { break; }\r\n                }\r\n            }\r\n            // Ensure that both objects contain the same number of properties.\r\n            if (result) {\r\n                for (key in b) {\r\n                    if (has(b, key) && !(size--)) { break; }\r\n                }\r\n                result = !size;\r\n            }\r\n        }\r\n        // Remove the first object from the stack of traversed objects.\r\n        aStack.pop();\r\n        bStack.pop();\r\n\r\n        return result;\r\n\r\n        function has(obj, key) {\r\n            return Object.prototype.hasOwnProperty.call(obj, key);\r\n        }\r\n\r\n        function isFunction(obj) {\r\n            return typeof obj === 'function';\r\n        }\r\n    }\r\n}","oldJSDoc":null,"type":"changedType","typePath":"window.jasmineRequire.matchersUtil.[function].[return].equals.[function].[arg0]","newType":"string | interface_573","oldType":"string | interface_828","containerType":"(a: string | interface_573, b: string | interface_575, customTesters: Array<function_875>) => boolean","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmineRequire.matchersUtil.[function].[return]","newFunction":"function(j$) {\r\n    // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?\r\n\r\n    return {\r\n        equals: function(a, b, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            return eq(a, b, [], [], customTesters);\r\n        },\r\n\r\n        contains: function(haystack, needle, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||\r\n                (!!haystack && !haystack.indexOf))\r\n            {\r\n                for (var i = 0; i < haystack.length; i++) {\r\n                    if (eq(haystack[i], needle, [], [], customTesters)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n\r\n            return !!haystack && haystack.indexOf(needle) >= 0;\r\n        },\r\n\r\n        buildFailureMessage: function() {\r\n            var args = Array.prototype.slice.call(arguments, 0),\r\n                matcherName = args[0],\r\n                isNot = args[1],\r\n                actual = args[2],\r\n                expected = args.slice(3),\r\n                englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\r\n\r\n            var message = 'Expected ' +\r\n                j$.pp(actual) +\r\n                (isNot ? ' not ' : ' ') +\r\n                englishyPredicate;\r\n\r\n            if (expected.length > 0) {\r\n                for (var i = 0; i < expected.length; i++) {\r\n                    if (i > 0) {\r\n                        message += ',';\r\n                    }\r\n                    message += ' ' + j$.pp(expected[i]);\r\n                }\r\n            }\r\n\r\n            return message + '.';\r\n        }\r\n    };\r\n\r\n    function isAsymmetric(obj) {\r\n        return obj && j$.isA_('Function', obj.asymmetricMatch);\r\n    }\r\n\r\n    function asymmetricMatch(a, b) {\r\n        var asymmetricA = isAsymmetric(a),\r\n            asymmetricB = isAsymmetric(b);\r\n\r\n        if (asymmetricA && asymmetricB) {\r\n            return undefined;\r\n        }\r\n\r\n        if (asymmetricA) {\r\n            return a.asymmetricMatch(b);\r\n        }\r\n\r\n        if (asymmetricB) {\r\n            return b.asymmetricMatch(a);\r\n        }\r\n    }\r\n\r\n    // Equality function lovingly adapted from isEqual in\r\n    //   [Underscore](http://underscorejs.org)\r\n    function eq(a, b, aStack, bStack, customTesters) {\r\n        var result = true;\r\n\r\n        var asymmetricResult = asymmetricMatch(a, b);\r\n        if (!j$.util.isUndefined(asymmetricResult)) {\r\n            return asymmetricResult;\r\n        }\r\n\r\n        for (var i = 0; i < customTesters.length; i++) {\r\n            var customTesterResult = customTesters[i](a, b);\r\n            if (!j$.util.isUndefined(customTesterResult)) {\r\n                return customTesterResult;\r\n            }\r\n        }\r\n\r\n        if (a instanceof Error && b instanceof Error) {\r\n            return a.message == b.message;\r\n        }\r\n\r\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n        if (a === b) { return a !== 0 || 1 / a == 1 / b; }\r\n        // A strict comparison is necessary because `null == undefined`.\r\n        if (a === null || b === null) { return a === b; }\r\n        var className = Object.prototype.toString.call(a);\r\n        if (className != Object.prototype.toString.call(b)) { return false; }\r\n        switch (className) {\r\n            // Strings, numbers, dates, and booleans are compared by value.\r\n            case '[object String]':\r\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n                // equivalent to `new String(\"5\")`.\r\n                return a == String(b);\r\n            case '[object Number]':\r\n                // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\r\n                // other numeric values.\r\n                return a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);\r\n            case '[object Date]':\r\n            case '[object Boolean]':\r\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n                // millisecond representations. Note that invalid dates with millisecond representations\r\n                // of `NaN` are not equivalent.\r\n                return +a == +b;\r\n            // RegExps are compared by their source patterns and flags.\r\n            case '[object RegExp]':\r\n                return a.source == b.source &&\r\n                    a.global == b.global &&\r\n                    a.multiline == b.multiline &&\r\n                    a.ignoreCase == b.ignoreCase;\r\n        }\r\n        if (typeof a != 'object' || typeof b != 'object') { return false; }\r\n\r\n        var aIsDomNode = j$.isDomNode(a);\r\n        var bIsDomNode = j$.isDomNode(b);\r\n        if (aIsDomNode && bIsDomNode) {\r\n            // At first try to use DOM3 method isEqualNode\r\n            if (a.isEqualNode) {\r\n                return a.isEqualNode(b);\r\n            }\r\n            // IE8 doesn't support isEqualNode, try to use outerHTML && innerText\r\n            var aIsElement = a instanceof Element;\r\n            var bIsElement = b instanceof Element;\r\n            if (aIsElement && bIsElement) {\r\n                return a.outerHTML == b.outerHTML;\r\n            }\r\n            if (aIsElement || bIsElement) {\r\n                return false;\r\n            }\r\n            return a.innerText == b.innerText && a.textContent == b.textContent;\r\n        }\r\n        if (aIsDomNode || bIsDomNode) {\r\n            return false;\r\n        }\r\n\r\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n        var length = aStack.length;\r\n        while (length--) {\r\n            // Linear search. Performance is inversely proportional to the number of\r\n            // unique nested structures.\r\n            if (aStack[length] == a) { return bStack[length] == b; }\r\n        }\r\n        // Add the first object to the stack of traversed objects.\r\n        aStack.push(a);\r\n        bStack.push(b);\r\n        var size = 0;\r\n        // Recursively compare objects and arrays.\r\n        // Compare array lengths to determine if a deep comparison is necessary.\r\n        if (className == '[object Array]') {\r\n            size = a.length;\r\n            if (size !== b.length) {\r\n                return false;\r\n            }\r\n\r\n            while (size--) {\r\n                result = eq(a[size], b[size], aStack, bStack, customTesters);\r\n                if (!result) {\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n\r\n            // Objects with different constructors are not equivalent, but `Object`s\r\n            // or `Array`s from different frames are.\r\n            var aCtor = a.constructor, bCtor = b.constructor;\r\n            if (aCtor !== bCtor && !(isObjectConstructor(aCtor) &&\r\n                isObjectConstructor(bCtor))) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Deep compare objects.\r\n        var aKeys = keys(a, className == '[object Array]'), key;\r\n        size = aKeys.length;\r\n\r\n        // Ensure that both objects contain the same number of properties before comparing deep equality.\r\n        if (keys(b, className == '[object Array]').length !== size) { return false; }\r\n\r\n        while (size--) {\r\n            key = aKeys[size];\r\n            // Deep compare each member\r\n            result = has(b, key) && eq(a[key], b[key], aStack, bStack, customTesters);\r\n\r\n            if (!result) {\r\n                return false;\r\n            }\r\n        }\r\n        // Remove the first object from the stack of traversed objects.\r\n        aStack.pop();\r\n        bStack.pop();\r\n\r\n        return result;\r\n\r\n        function keys(obj, isArray) {\r\n            var allKeys = Object.keys ? Object.keys(obj) :\r\n                (function(o) {\r\n                    var keys = [];\r\n                    for (var key in o) {\r\n                        if (has(o, key)) {\r\n                            keys.push(key);\r\n                        }\r\n                    }\r\n                    return keys;\r\n                })(obj);\r\n\r\n            if (!isArray) {\r\n                return allKeys;\r\n            }\r\n\r\n            var extraKeys = [];\r\n            for (var i in allKeys) {\r\n                if (!allKeys[i].match(/^[0-9]+$/)) {\r\n                    extraKeys.push(allKeys[i]);\r\n                }\r\n            }\r\n\r\n            return extraKeys;\r\n        }\r\n    }\r\n\r\n    function has(obj, key) {\r\n        return Object.prototype.hasOwnProperty.call(obj, key);\r\n    }\r\n\r\n    function isFunction(obj) {\r\n        return typeof obj === 'function';\r\n    }\r\n\r\n    function isObjectConstructor(ctor) {\r\n        // aCtor instanceof aCtor is true for the Object and Function\r\n        // constructors (since a constructor is-a Function and a function is-a\r\n        // Object). We don't just compare ctor === Object because the constructor\r\n        // might come from a different frame with different globals.\r\n        return isFunction(ctor) && ctor instanceof ctor;\r\n    }\r\n}","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmineRequire.matchersUtil.[function].[return]","oldFunction":"function(j$) {\r\n    // TODO: what to do about jasmine.pp not being inject? move to JSON.stringify? gut PrettyPrinter?\r\n\r\n    return {\r\n        equals: function(a, b, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            return eq(a, b, [], [], customTesters);\r\n        },\r\n\r\n        contains: function(haystack, needle, customTesters) {\r\n            customTesters = customTesters || [];\r\n\r\n            if ((Object.prototype.toString.apply(haystack) === '[object Array]') ||\r\n                (!!haystack && !haystack.indexOf))\r\n            {\r\n                for (var i = 0; i < haystack.length; i++) {\r\n                    if (eq(haystack[i], needle, [], [], customTesters)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                return false;\r\n            }\r\n\r\n            return !!haystack && haystack.indexOf(needle) >= 0;\r\n        },\r\n\r\n        buildFailureMessage: function() {\r\n            var args = Array.prototype.slice.call(arguments, 0),\r\n                matcherName = args[0],\r\n                isNot = args[1],\r\n                actual = args[2],\r\n                expected = args.slice(3),\r\n                englishyPredicate = matcherName.replace(/[A-Z]/g, function(s) { return ' ' + s.toLowerCase(); });\r\n\r\n            var message = 'Expected ' +\r\n                j$.pp(actual) +\r\n                (isNot ? ' not ' : ' ') +\r\n                englishyPredicate;\r\n\r\n            if (expected.length > 0) {\r\n                for (var i = 0; i < expected.length; i++) {\r\n                    if (i > 0) {\r\n                        message += ',';\r\n                    }\r\n                    message += ' ' + j$.pp(expected[i]);\r\n                }\r\n            }\r\n\r\n            return message + '.';\r\n        }\r\n    };\r\n\r\n    function isAsymmetric(obj) {\r\n        return obj && j$.isA_('Function', obj.asymmetricMatch);\r\n    }\r\n\r\n    function asymmetricMatch(a, b) {\r\n        var asymmetricA = isAsymmetric(a),\r\n            asymmetricB = isAsymmetric(b);\r\n\r\n        if (asymmetricA && asymmetricB) {\r\n            return undefined;\r\n        }\r\n\r\n        if (asymmetricA) {\r\n            return a.asymmetricMatch(b);\r\n        }\r\n\r\n        if (asymmetricB) {\r\n            return b.asymmetricMatch(a);\r\n        }\r\n    }\r\n\r\n    // Equality function lovingly adapted from isEqual in\r\n    //   [Underscore](http://underscorejs.org)\r\n    function eq(a, b, aStack, bStack, customTesters) {\r\n        var result = true;\r\n\r\n        var asymmetricResult = asymmetricMatch(a, b);\r\n        if (!j$.util.isUndefined(asymmetricResult)) {\r\n            return asymmetricResult;\r\n        }\r\n\r\n        for (var i = 0; i < customTesters.length; i++) {\r\n            var customTesterResult = customTesters[i](a, b);\r\n            if (!j$.util.isUndefined(customTesterResult)) {\r\n                return customTesterResult;\r\n            }\r\n        }\r\n\r\n        if (a instanceof Error && b instanceof Error) {\r\n            return a.message == b.message;\r\n        }\r\n\r\n        // Identical objects are equal. `0 === -0`, but they aren't identical.\r\n        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).\r\n        if (a === b) { return a !== 0 || 1 / a == 1 / b; }\r\n        // A strict comparison is necessary because `null == undefined`.\r\n        if (a === null || b === null) { return a === b; }\r\n        var className = Object.prototype.toString.call(a);\r\n        if (className != Object.prototype.toString.call(b)) { return false; }\r\n        switch (className) {\r\n            // Strings, numbers, dates, and booleans are compared by value.\r\n            case '[object String]':\r\n                // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\r\n                // equivalent to `new String(\"5\")`.\r\n                return a == String(b);\r\n            case '[object Number]':\r\n                // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\r\n                // other numeric values.\r\n                return a != +a ? b != +b : (a === 0 ? 1 / a == 1 / b : a == +b);\r\n            case '[object Date]':\r\n            case '[object Boolean]':\r\n                // Coerce dates and booleans to numeric primitive values. Dates are compared by their\r\n                // millisecond representations. Note that invalid dates with millisecond representations\r\n                // of `NaN` are not equivalent.\r\n                return +a == +b;\r\n            // RegExps are compared by their source patterns and flags.\r\n            case '[object RegExp]':\r\n                return a.source == b.source &&\r\n                    a.global == b.global &&\r\n                    a.multiline == b.multiline &&\r\n                    a.ignoreCase == b.ignoreCase;\r\n        }\r\n        if (typeof a != 'object' || typeof b != 'object') { return false; }\r\n\r\n        var aIsDomNode = j$.isDomNode(a);\r\n        var bIsDomNode = j$.isDomNode(b);\r\n        if (aIsDomNode && bIsDomNode) {\r\n            // At first try to use DOM3 method isEqualNode\r\n            if (a.isEqualNode) {\r\n                return a.isEqualNode(b);\r\n            }\r\n            // IE8 doesn't support isEqualNode, try to use outerHTML && innerText\r\n            var aIsElement = a instanceof Element;\r\n            var bIsElement = b instanceof Element;\r\n            if (aIsElement && bIsElement) {\r\n                return a.outerHTML == b.outerHTML;\r\n            }\r\n            if (aIsElement || bIsElement) {\r\n                return false;\r\n            }\r\n            return a.innerText == b.innerText && a.textContent == b.textContent;\r\n        }\r\n        if (aIsDomNode || bIsDomNode) {\r\n            return false;\r\n        }\r\n\r\n        // Assume equality for cyclic structures. The algorithm for detecting cyclic\r\n        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\r\n        var length = aStack.length;\r\n        while (length--) {\r\n            // Linear search. Performance is inversely proportional to the number of\r\n            // unique nested structures.\r\n            if (aStack[length] == a) { return bStack[length] == b; }\r\n        }\r\n        // Add the first object to the stack of traversed objects.\r\n        aStack.push(a);\r\n        bStack.push(b);\r\n        var size = 0;\r\n        // Recursively compare objects and arrays.\r\n        // Compare array lengths to determine if a deep comparison is necessary.\r\n        if (className == '[object Array]' && a.length !== b.length) {\r\n            result = false;\r\n        }\r\n\r\n        if (result) {\r\n            // Objects with different constructors are not equivalent, but `Object`s\r\n            // from different frames are.\r\n            var aCtor = a.constructor, bCtor = b.constructor;\r\n            if (aCtor !== bCtor && !(isFunction(aCtor) && (aCtor instanceof aCtor) &&\r\n                isFunction(bCtor) && (bCtor instanceof bCtor))) {\r\n                return false;\r\n            }\r\n            // Deep compare objects.\r\n            for (var key in a) {\r\n                if (has(a, key)) {\r\n                    // Count the expected number of properties.\r\n                    size++;\r\n                    // Deep compare each member.\r\n                    if (!(result = has(b, key) && eq(a[key], b[key], aStack, bStack, customTesters))) { break; }\r\n                }\r\n            }\r\n            // Ensure that both objects contain the same number of properties.\r\n            if (result) {\r\n                for (key in b) {\r\n                    if (has(b, key) && !(size--)) { break; }\r\n                }\r\n                result = !size;\r\n            }\r\n        }\r\n        // Remove the first object from the stack of traversed objects.\r\n        aStack.pop();\r\n        bStack.pop();\r\n\r\n        return result;\r\n\r\n        function has(obj, key) {\r\n            return Object.prototype.hasOwnProperty.call(obj, key);\r\n        }\r\n\r\n        function isFunction(obj) {\r\n            return typeof obj === 'function';\r\n        }\r\n    }\r\n}","oldJSDoc":null,"type":"changedType","typePath":"window.jasmineRequire.matchersUtil.[function].[return].contains.[function].[arg0].[indexer]","newType":"string | interface_562","oldType":"string | interface_868","containerType":"// Seen as: haystack\ninterface interface_560 {\n    [index: number]: string | interface_562;\n    indexOf: (arg0: void) => void;\n    length: number;\n}\n\n","containerDescription":"interface"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Suite.[constructor].[function].[arg0].expectationFactory.[function]","newFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Suite.[constructor].[function].[arg0].expectationFactory.[function]","oldFunction":"function Suite(attrs) {\r\n        this.env = attrs.env;\r\n        this.id = attrs.id;\r\n        this.parentSuite = attrs.parentSuite;\r\n        this.description = attrs.description;\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.clearStack = attrs.clearStack || function(fn) {fn();};\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.expectationResultFactory = attrs.expectationResultFactory;\r\n        this.runnablesExplictlySetGetter = attrs.runnablesExplictlySetGetter || function() {};\r\n\r\n        this.beforeFns = [];\r\n        this.afterFns = [];\r\n        this.beforeAllFns = [];\r\n        this.afterAllFns = [];\r\n        this.queueRunner = attrs.queueRunner || function() {};\r\n        this.disabled = false;\r\n\r\n        this.children = [];\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: []\r\n        };\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.Suite.[constructor].[function].[arg0].expectationFactory.[function].[arg1]","newType":"jasmine.Suite","oldType":"// Seen as: spec\ninterface interface_703 {\n    addExpectationResult: (arg0: void, arg1: void) => void;\n    id: string | number;\n}\n\n","containerType":"(actual: any, spec: jasmine.Suite) => jasmine.Expectation | {not: jasmine.Expectation}","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Spec.[constructor].[function].[arg0].queueRunnerFactory.[function].[arg0]","newFunction":"function Spec(attrs) {\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.id = attrs.id;\r\n        this.description = attrs.description || '';\r\n        this.queueableFn = attrs.queueableFn;\r\n        this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n        this.userContext = attrs.userContext || function() { return {}; };\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n        this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n        this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n        this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        if (!this.queueableFn.fn) {\r\n            this.pend();\r\n        }\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: [],\r\n            passedExpectations: [],\r\n            pendingReason: ''\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Spec.[constructor].[function].[arg0].queueRunnerFactory.[function].[arg0]","oldFunction":"function Spec(attrs) {\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.id = attrs.id;\r\n        this.description = attrs.description || '';\r\n        this.queueableFn = attrs.queueableFn;\r\n        this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n        this.userContext = attrs.userContext || function() { return {}; };\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n        this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n        this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n        this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n\r\n        if (!this.queueableFn.fn) {\r\n            this.pend();\r\n        }\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: [],\r\n            passedExpectations: [],\r\n            pendingReason: ''\r\n        };\r\n    }","oldJSDoc":null,"type":"removedProperty","typePath":"window.jasmine.Spec.[constructor].[function].[arg0].queueRunnerFactory.[function].[arg0]","key":"timer","isClass":false,"containerType":"// Seen as: attrs, options\ninterface interface_713 {\n    catchException: (e: {toString: () => void}) => boolean;\n    clearStack: (fn: () => void) => void;\n    fail: (error: {message: any}) => void;\n    onComplete: any;\n    onException: any;\n    queueableFns: any;\n    timeout: interface_711;\n    userContext: any;\n}\n\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Spec.[constructor].[function].[arg0].getSpecName.[function]","newFunction":"function Spec(attrs) {\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.id = attrs.id;\r\n        this.description = attrs.description || '';\r\n        this.queueableFn = attrs.queueableFn;\r\n        this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n        this.userContext = attrs.userContext || function() { return {}; };\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n        this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n        this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n        this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        if (!this.queueableFn.fn) {\r\n            this.pend();\r\n        }\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: [],\r\n            passedExpectations: [],\r\n            pendingReason: ''\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Spec.[constructor].[function].[arg0].getSpecName.[function]","oldFunction":"function Spec(attrs) {\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.id = attrs.id;\r\n        this.description = attrs.description || '';\r\n        this.queueableFn = attrs.queueableFn;\r\n        this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n        this.userContext = attrs.userContext || function() { return {}; };\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n        this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n        this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n        this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n\r\n        if (!this.queueableFn.fn) {\r\n            this.pend();\r\n        }\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: [],\r\n            passedExpectations: [],\r\n            pendingReason: ''\r\n        };\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.Spec.[constructor].[function].[arg0].getSpecName.[function].[return]","newType":"string","oldType":"string | number","containerType":"(spec: void) => string","containerDescription":"function"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Spec.[constructor].[function].[arg0].beforeAndAfterFns.[function].[return]","newFunction":"function Spec(attrs) {\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.id = attrs.id;\r\n        this.description = attrs.description || '';\r\n        this.queueableFn = attrs.queueableFn;\r\n        this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n        this.userContext = attrs.userContext || function() { return {}; };\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n        this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n        this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n        this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        if (!this.queueableFn.fn) {\r\n            this.pend();\r\n        }\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: [],\r\n            passedExpectations: [],\r\n            pendingReason: ''\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Spec.[constructor].[function].[arg0].beforeAndAfterFns.[function].[return]","oldFunction":"function Spec(attrs) {\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.id = attrs.id;\r\n        this.description = attrs.description || '';\r\n        this.queueableFn = attrs.queueableFn;\r\n        this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n        this.userContext = attrs.userContext || function() { return {}; };\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n        this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n        this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n        this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n\r\n        if (!this.queueableFn.fn) {\r\n            this.pend();\r\n        }\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: [],\r\n            passedExpectations: [],\r\n            pendingReason: ''\r\n        };\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.Spec.[constructor].[function].[arg0].beforeAndAfterFns.[function].[return].befores","newType":"Array<any>","oldType":"any","containerType":"{\n    afters: Array<any>, \n    befores: Array<any>\n}\n","containerDescription":"object"},{"isInOldDec":false,"isInOldDecContainer":false,"isInNewDec":false,"isInNewDecContainer":false,"newInclosingFunctionPath":"window.jasmine.Spec.[constructor].[function].[arg0].queueRunnerFactory.[function].[arg0]","newFunction":"function Spec(attrs) {\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.id = attrs.id;\r\n        this.description = attrs.description || '';\r\n        this.queueableFn = attrs.queueableFn;\r\n        this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n        this.userContext = attrs.userContext || function() { return {}; };\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n        this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n        this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n        this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n        this.throwOnExpectationFailure = !!attrs.throwOnExpectationFailure;\r\n\r\n        if (!this.queueableFn.fn) {\r\n            this.pend();\r\n        }\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: [],\r\n            passedExpectations: [],\r\n            pendingReason: ''\r\n        };\r\n    }","newJSDoc":null,"oldInclosingFunctionPath":"window.jasmine.Spec.[constructor].[function].[arg0].queueRunnerFactory.[function].[arg0]","oldFunction":"function Spec(attrs) {\r\n        this.expectationFactory = attrs.expectationFactory;\r\n        this.resultCallback = attrs.resultCallback || function() {};\r\n        this.id = attrs.id;\r\n        this.description = attrs.description || '';\r\n        this.queueableFn = attrs.queueableFn;\r\n        this.beforeAndAfterFns = attrs.beforeAndAfterFns || function() { return {befores: [], afters: []}; };\r\n        this.userContext = attrs.userContext || function() { return {}; };\r\n        this.onStart = attrs.onStart || function() {};\r\n        this.getSpecName = attrs.getSpecName || function() { return ''; };\r\n        this.expectationResultFactory = attrs.expectationResultFactory || function() { };\r\n        this.queueRunnerFactory = attrs.queueRunnerFactory || function() {};\r\n        this.catchingExceptions = attrs.catchingExceptions || function() { return true; };\r\n\r\n        if (!this.queueableFn.fn) {\r\n            this.pend();\r\n        }\r\n\r\n        this.result = {\r\n            id: this.id,\r\n            description: this.description,\r\n            fullName: this.getFullName(),\r\n            failedExpectations: [],\r\n            passedExpectations: [],\r\n            pendingReason: ''\r\n        };\r\n    }","oldJSDoc":null,"type":"changedType","typePath":"window.jasmine.Spec.[constructor].[function].[arg0].queueRunnerFactory.[function].[arg0].timeout","newType":"interface interface_711 {\n    clearTimeout: (handle: number) => void;\n    setTimeout: (handler: any, timeout: any, args: any) => number;\n}\n\n","oldType":"any","containerType":"// Seen as: attrs, options\ninterface interface_713 {\n    catchException: (e: {toString: () => void}) => boolean;\n    clearStack: (fn: () => void) => void;\n    fail: (error: {message: any}) => void;\n    onComplete: any;\n    onException: any;\n    queueableFns: any;\n    timeout: interface_711;\n    userContext: any;\n}\n\n","containerDescription":"object"}],"newName":"Jasmine (2.5)","oldName":"Jasmine (2.2)","oldDeclaration":"declare function beforeEach(): any;\ndeclare function xit(): {pend: () => void};\ndeclare function afterEach(): any;\ndeclare function fdescribe(description: any, specDefinitions: {call: (arg0: void) => void}): jasmine.Suite | interface_680;\ndeclare function beforeAll(): any;\ndeclare function afterAll(): any;\ndeclare function xdescribe(description: any, specDefinitions: any): {disable: () => void};\ndeclare function pending(): any;\ndeclare function getJasmineRequireObj(): interface_681;\ndeclare var jsApiReporter: jasmine.JsApiReporter;\ndeclare function it(): {disabled: boolean} | jasmine.Spec;\ndeclare module jasmine {\n    export class Any {\n        constructor (expectedObject: any);\n        asymmetricMatch: (other: any) => boolean;\n        expectedObject: any;\n        jasmineToString: () => string;\n    }\n    export class Anything {\n        constructor ();\n        asymmetricMatch: (other: any) => boolean;\n        jasmineToString: () => string;\n    }\n    export class ArrayContaining {\n        constructor (sample: any);\n        asymmetricMatch: (other: interface_636) => boolean;\n        jasmineToString: () => string;\n        sample: any;\n    }\n    export class CallTracker {\n        constructor ();\n        all: () => Array<interface_683>;\n        allArgs: () => Array<any>;\n        any: () => boolean;\n        argsFor: (index: number) => Array<any>;\n        count: () => number;\n        first: () => interface_683;\n        mostRecent: () => interface_683;\n        reset: () => void;\n        track: (context: any) => void;\n    }\n    export class Clock {\n        constructor (global: Window | interface_495, delayedFunctionScheduler: jasmine.DelayedFunctionScheduler, mockDate: jasmine.MockDate);\n        clearInterval: (id: Window) => any;\n        clearTimeout: (id: Window) => any;\n        install: () => jasmine.Clock;\n        mockDate: (initialDate: {getTime: () => void}) => void;\n        setInterval: (fn: any, delay: any, params: any) => any;\n        setTimeout: (fn: any, delay: any, params: any) => any;\n        tick: (millis: number) => void;\n        uninstall: () => void;\n    }\n    export var DEFAULT_TIMEOUT_INTERVAL: number;\n    export class DelayedFunctionScheduler {\n        constructor ();\n        removeFunctionWithId: (timeoutKey: any) => void;\n        reset: () => void;\n        scheduleFunction: (funcToCall: string | (() => any), millis: number, params: Array<any>, recurring: boolean, timeoutKey: number, runAtMillis: string) => number;\n        tick: (millis: number) => void;\n    }\n    export class Env {\n        constructor (options: {global: any});\n        addCustomEqualityTester: (tester: any) => void;\n        addMatchers: (matchersToAdd: any) => void;\n        addReporter: (reporterToAdd: any) => void;\n        afterAll: (afterAllFunction: any, timeout: any) => void;\n        afterEach: (afterEachFunction: any, timeout: any) => void;\n        beforeAll: (beforeAllFunction: any, timeout: any) => void;\n        beforeEach: (beforeEachFunction: any, timeout: any) => void;\n        catchExceptions: (value: any) => boolean;\n        catchingExceptions: () => boolean;\n        clock: jasmine.Clock;\n        describe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite;\n        execute: (runnablesToRun: string[]) => void;\n        expect: (actual: any) => any;\n        fail: (error: {message: any}) => void;\n        fdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite | interface_680;\n        fit: () => {id: any};\n        it: (description: string, fn: () => void, timeout: any) => {disabled: boolean} | jasmine.Spec;\n        pending: (message: string) => void;\n        specFilter: (spec: jasmine.Spec) => boolean;\n        spyOn: () => interface_516;\n        topSuite: () => jasmine.Suite;\n        xdescribe: (description: any, specDefinitions: any) => {disable: () => void};\n        xit: () => {pend: () => void};\n    }\n    export class ExceptionFormatter {\n        constructor ();\n        message: (error: interface_685) => string;\n        stack: (error: {stack: any}) => any;\n    }\n    export class Expectation {\n        constructor (options: interface_688);\n        static Factory: (options: interface_690) => jasmine.Expectation | {not: jasmine.Expectation};\n        static addCoreMatchers: (matchers: interface_692) => void;\n        actual: any;\n        addExpectationResult: () => void;\n        customEqualityTesters: Array<any>;\n        isNot: any;\n        toBe: () => void;\n        toBeCloseTo: () => void;\n        toBeDefined: () => void;\n        toBeFalsy: () => void;\n        toBeGreaterThan: () => void;\n        toBeLessThan: () => void;\n        toBeNaN: () => void;\n        toBeNull: () => void;\n        toBeTruthy: () => void;\n        toBeUndefined: () => void;\n        toContain: () => void;\n        toEqual: () => void;\n        toHaveBeenCalled: () => void;\n        toHaveBeenCalledWith: () => void;\n        toMatch: () => void;\n        toThrow: () => void;\n        toThrowError: () => void;\n        util: {buildFailureMessage: () => void};\n        wrapCompare: (name: any, matcherFactory: (arg0: void, arg1: void) => void) => () => void;\n    }\n    export class HtmlReporter {\n        constructor (options: interface_693);\n        initialize: () => void;\n        jasmineDone: () => void;\n        jasmineStarted: (options: {totalSpecsDefined: number}) => void;\n        specDone: (result: interface_695) => void;\n        specStarted: (result: any) => void;\n        suiteDone: (result: {status: string}) => void;\n        suiteStarted: (result: any) => void;\n    }\n    export class HtmlSpecFilter {\n        constructor (options: {filterString: () => void});\n        matches: (specName: string) => boolean;\n    }\n    export class JsApiReporter {\n        constructor (options: {timer: any});\n        executionTime: () => number;\n        finished: boolean;\n        jasmineDone: () => void;\n        jasmineStarted: (arg0: {totalSpecsDefined: number}) => void;\n        specDone: (result: any) => void;\n        specResults: (index: number, length: string | number) => Array<any>;\n        specs: () => Array<any>;\n        started: boolean;\n        status: () => string;\n        suiteDone: (result: {id: string | number}) => void;\n        suiteResults: (index: number, length: string | number) => Array<any>;\n        suiteStarted: (result: {id: string | number}) => void;\n        suites: () => any;\n    }\n    export var MAX_PRETTY_PRINT_ARRAY_LENGTH: number;\n    export var MAX_PRETTY_PRINT_DEPTH: number;\n    export class MockDate {\n        constructor (global: Window);\n        install: (mockDate: {getTime: () => void}) => void;\n        tick: (millis: number) => void;\n        uninstall: () => void;\n    }\n    export class ObjectContaining {\n        constructor (sample: any);\n        asymmetricMatch: (other: any) => boolean;\n        jasmineToString: () => string;\n        sample: any;\n    }\n    export class QueryString {\n        constructor (options: {getWindowLocation: () => void});\n        fullStringWithNewParam: (key: string, value: any) => string;\n        getParam: (key: string) => any;\n        navigateWithNewParam: (key: string, value: boolean) => void;\n    }\n    export class QueueRunner {\n        constructor (attrs: interface_698);\n        catchException: () => boolean;\n        clearStack: (fn: () => void) => void;\n        execute: () => void;\n        fail: () => void;\n        onComplete: () => void;\n        onException: () => void;\n        queueableFns: Array<any>;\n        run: (queueableFns: interface_653, recursiveIndex: number) => void;\n        timer: interface_700;\n        userContext: any;\n    }\n    export class ReportDispatcher {\n        constructor (methods: string[]);\n        addReporter: (reporter: any) => void;\n        jasmineDone: () => void;\n        jasmineStarted: () => void;\n        specDone: () => void;\n        specStarted: () => void;\n        suiteDone: () => void;\n        suiteStarted: () => void;\n    }\n    export class ResultsNode {\n        constructor (result: any, type: string, parent: any);\n        addChild: (result: any, type: string) => void;\n        children: Array<any>;\n        last: () => any;\n        parent: any;\n        result: any;\n        type: string;\n    }\n    export class Spec {\n        constructor (attrs: interface_712);\n        static isPendingSpecException: (e: {toString: () => void}) => boolean;\n        static pendingSpecExceptionMessage: string;\n        addExpectationResult: (passed: boolean, data: interface_714) => void;\n        beforeAndAfterFns: () => {afters: Array<any>, befores: Array<any>};\n        catchingExceptions: () => boolean;\n        description: string;\n        disable: () => void;\n        execute: (onComplete: () => void) => void;\n        expect: (actual: any) => any;\n        expectationFactory: any;\n        expectationResultFactory: () => void;\n        getFullName: () => any;\n        getSpecName: () => string;\n        id: any;\n        isExecutable: () => boolean;\n        onException: (e: {toString: () => void}) => void;\n        onStart: () => void;\n        pend: (message: any) => void;\n        queueRunnerFactory: () => void;\n        queueableFn: {fn: any};\n        result: interface_717;\n        resultCallback: () => void;\n        status: () => string;\n        userContext: () => any;\n    }\n    export class SpyRegistry {\n        constructor (options: {currentSpies: () => any});\n        clearSpies: () => void;\n        spyOn: (obj: interface_638, methodName: string | number) => interface_516;\n    }\n    export class SpyStrategy {\n        constructor (options: interface_719);\n        callFake: (originalFn: (arg0: void, arg1: void, arg2: void, arg3: void, arg4: void) => any) => any;\n        callThrough: () => any;\n        exec: () => any;\n        identity: () => string;\n        returnValue: (value: any) => any;\n        returnValues: () => any;\n        stub: (fn: any) => any;\n        throwError: (something: string | Error) => any;\n    }\n    export class StringMatching {\n        constructor (expected: string);\n        asymmetricMatch: (other: any) => any;\n        jasmineToString: () => string;\n        regexp: RegExp;\n    }\n    export class Suite {\n        constructor (attrs: interface_721);\n        addChild: (child: {id: void, isFocused: boolean} | jasmine.Spec | jasmine.Suite) => void;\n        addExpectationResult: () => void;\n        afterAll: (fn: {fn: any, timeout: () => number}) => void;\n        afterAllFns: Array<any>;\n        afterEach: (fn: {fn: any, timeout: () => number}) => void;\n        afterFns: Array<any>;\n        beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n        beforeAllFns: Array<any>;\n        beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n        beforeFns: Array<any>;\n        children: Array<any>;\n        clearStack: (fn: () => void) => void;\n        clonedSharedUserContext: () => any;\n        description: string;\n        disable: () => void;\n        disabled: boolean;\n        env: jasmine.Env;\n        execute: (onComplete: () => void) => void;\n        expect: (actual: any) => any;\n        expectationFactory: any;\n        expectationResultFactory: any;\n        getFullName: () => string;\n        id: string;\n        isExecutable: () => boolean;\n        onException: () => void;\n        onStart: () => void;\n        parentSuite: any;\n        queueRunner: (options: interface_677) => void;\n        result: interface_678;\n        resultCallback: () => void;\n        runnablesExplictlySetGetter: () => void;\n        sharedContext: any;\n        sharedUserContext: () => any;\n        status: () => string;\n    }\n    export class Timer {\n        constructor (options: {now: any});\n        elapsed: () => number;\n        start: () => void;\n    }\n    export function addCustomEqualityTester(tester: any): void;\n    export function addMatchers(matchers: any): any;\n    export function any(clazz: any): jasmine.Any;\n    export function anything(): jasmine.Anything;\n    export function arrayContaining(sample: any): jasmine.ArrayContaining;\n    export function buildExpectationResult(options: interface_723): interface_708;\n    export function clock(): jasmine.Clock;\n    export function createSpy(name: string | number, originalFn: any): interface_631;\n    export function createSpyObj(baseName: string | interface_661, methodNames: string | interface_661): interface_664;\n    export var currentEnv_: jasmine.Env;\n    export function fnNameFor(func: {name: any, test: void, toString: () => void}): any;\n    export function getEnv(options: {global: any}): jasmine.Env;\n    export function getGlobal(): Window;\n    export function isA_(typeName: string, value: string | interface_725): boolean;\n    export function isArray_(value: string | interface_725): boolean;\n    export function isDomNode(obj: interface_726): boolean;\n    export function isNumber_(value: any): boolean;\n    export function isSpy(putativeSpy: interface_729): boolean;\n    export function isString_(value: any): boolean;\n    export module matchers {\n        export function toBe(): interface_730;\n        export function toBeCloseTo(): interface_732;\n        export function toBeDefined(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeFalsy(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeGreaterThan(): interface_734;\n        export function toBeLessThan(): interface_736;\n        export function toBeNaN(): interface_738;\n        export function toBeNull(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeTruthy(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeUndefined(): {compare: (actual: any) => {pass: boolean}};\n        export function toContain(util: interface_740, customEqualityTesters: Array<any>): interface_742;\n        export function toEqual(util: interface_744, customEqualityTesters: Array<any>): interface_746;\n        export function toHaveBeenCalled(): interface_748;\n        export function toHaveBeenCalledWith(util: interface_750, customEqualityTesters: any): interface_752;\n        export function toMatch(): interface_753;\n        export function toThrow(util: {equals: (arg0: void, arg1: void) => void}): interface_756;\n        export function toThrowError(util: any): interface_758;\n    }\n    export module matchersUtil {\n        export function buildFailureMessage(): string;\n        export function contains(haystack: interface_405, needle: string | interface_760, customTesters: Array<function_763>): boolean;\n        export function equals(a: string | interface_760, b: string | interface_760, customTesters: Array<function_763>): boolean;\n    }\n    export function objectContaining(sample: any): jasmine.ObjectContaining;\n    export function pp(value: number | Window | interface_630): any;\n    export function stringMatching(expected: string): jasmine.StringMatching;\n    export function unimplementedMethod_(): void;\n    export module util {\n        export function argsToArray(args: interface_648): Array<any>;\n        export function arrayContains(array: any[], search: interface_765): boolean;\n        export function clone(obj: {slice: () => void}): any;\n        export function htmlEscape(str: {replace: (arg0: void, arg1: void) => void}): {replace: (arg0: void, arg1: void) => void};\n        export function inherit(childClass: {prototype: any}, parentClass: {prototype: any}): void;\n        export function isUndefined(obj: string | interface_767): boolean;\n    }\n    export var version: string;\n}\ndeclare function fit(): {id: any};\ndeclare function expect(actual: any): any;\ndeclare function fail(): any;\ndeclare function spyOn(obj: any, methodName: any): interface_516;\ndeclare var jasmineRequire: interface_821;\ndeclare function describe(description: any, specDefinitions: {call: (arg0: void) => void}): jasmine.Suite;\ninterface interface_676 {\n    clearTimeout: (handle: number) => void;\n    setTimeout: (handler: any, timeout: any, args: any) => number;\n}\n\n// Seen as: attrs, options\ninterface interface_677 {\n    catchException: (e: {toString: () => void}) => boolean;\n    clearStack: (fn: () => void) => void;\n    fail: (error: {message: any}) => void;\n    onComplete: () => void;\n    onException: () => void;\n    queueableFns: Array<any>;\n    timeout: any;\n    timer: interface_676;\n    userContext: any;\n}\n\ninterface interface_678 {\n    description: string;\n    failedExpectations: Array<any>;\n    fullName: string;\n    id: string;\n    status: string;\n}\n\n// Seen as: suite\ninterface interface_680 {\n    afterAllFns: Array<any>;\n    afterFns: Array<any>;\n    beforeAllFns: Array<any>;\n    beforeFns: Array<any>;\n    children: Array<any>;\n    clearStack: (fn: () => void) => void;\n    description: string;\n    disabled: boolean;\n    env: jasmine.Env;\n    expectationFactory: any;\n    expectationResultFactory: any;\n    id: string;\n    isFocused: boolean;\n    onStart: () => void;\n    parentSuite: any;\n    queueRunner: (options: interface_677) => void;\n    result: interface_678;\n    resultCallback: () => void;\n    runnablesExplictlySetGetter: () => void;\n    sharedContext: any;\n}\n\ninterface interface_681 {\n    Any: () => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_770) => (sample: any) => void;\n    CallTracker: () => () => void;\n    Clock: () => (global: interface_525, delayedFunctionScheduler: interface_773, mockDate: interface_775) => interface_781;\n    DelayedFunctionScheduler: () => () => interface_783;\n    Env: (j$: interface_788) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_603;\n    HtmlReporter: (j$: interface_789) => (options: interface_791) => interface_795;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_593}) => interface_797;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_799;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_801) => void;\n    ReportDispatcher: () => (methods: any) => interface_592;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: any) => interface_598;\n    SpyRegistry: (j$: interface_803) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_804) => (expected: string) => void;\n    Suite: () => (attrs: interface_806) => void;\n    Timer: () => (options: {now: any}) => void;\n    base: (j$: interface_808, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_810) => interface_812;\n    core: (jRequire: interface_814) => interface_816;\n    html: (j$: interface_817) => void;\n    \"interface\": function_820;\n    matchersUtil: (j$: interface_824) => interface_830;\n    pp: (j$: interface_832) => (value: any) => any;\n    requireMatchers: (jRequire: interface_568, j$: any) => interface_571;\n    toBe: () => () => interface_834;\n    toBeCloseTo: () => () => interface_835;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_836;\n    toBeLessThan: () => () => interface_837;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_838;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_839, customEqualityTesters: Array<any>) => interface_841;\n    toEqual: () => (util: interface_842, customEqualityTesters: Array<any>) => interface_843;\n    toHaveBeenCalled: (j$: interface_844) => () => interface_846;\n    toHaveBeenCalledWith: (j$: interface_847) => (util: interface_849, customEqualityTesters: any) => interface_850;\n    toMatch: (j$: interface_851) => () => interface_852;\n    toThrow: (j$: {pp: (arg0: void) => void}) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_853;\n    toThrowError: (j$: interface_854) => (util: any) => interface_855;\n    util: () => interface_857;\n    version: () => string;\n}\n\n// Seen as: haystack\ninterface interface_636 {\n    [index: number]: string | interface_858;\n    indexOf: (arg0: void) => void;\n    length: number;\n}\n\n// Seen as: call\ninterface interface_683 {\n    args: Array<any>;\n}\n\n// Seen as: arguments, global, id\ninterface interface_495 {\n    [index: number]: any;\n}\n\n// Seen as: putativeSpy, spy\ninterface interface_516 {\n    () : any;\n    and: jasmine.SpyStrategy;\n    calls: jasmine.CallTracker;\n}\n\n// Seen as: error\ninterface interface_685 {\n    fileName: any;\n    line: any;\n    lineNumber: any;\n    message: string | number;\n    name: string | number;\n    sourceURL: any;\n    toString: () => void;\n}\n\ninterface interface_687 {\n    buildFailureMessage: typeof jasmine.matchersUtil.buildFailureMessage;\n    contains: typeof jasmine.matchersUtil.contains;\n    equals: typeof jasmine.matchersUtil.equals;\n}\n\n// Seen as: options\ninterface interface_688 {\n    actual: any;\n    addExpectationResult: (passed: void, result: void) => any;\n    customEqualityTesters: any;\n    customMatchers: any;\n    isNot: boolean;\n    util: interface_687;\n}\n\n// Seen as: options\ninterface interface_690 {\n    actual: any;\n    addExpectationResult: (passed: void, result: void) => any;\n    customEqualityTesters: any;\n    customMatchers: any;\n    isNot: boolean;\n    util: interface_687;\n}\n\ninterface interface_692 {\n    toBe: typeof jasmine.matchers.toBe;\n    toBeCloseTo: typeof jasmine.matchers.toBeCloseTo;\n    toBeDefined: typeof jasmine.matchers.toBeDefined;\n    toBeFalsy: typeof jasmine.matchers.toBeFalsy;\n    toBeGreaterThan: typeof jasmine.matchers.toBeGreaterThan;\n    toBeLessThan: typeof jasmine.matchers.toBeLessThan;\n    toBeNaN: typeof jasmine.matchers.toBeNaN;\n    toBeNull: typeof jasmine.matchers.toBeNull;\n    toBeTruthy: typeof jasmine.matchers.toBeTruthy;\n    toBeUndefined: typeof jasmine.matchers.toBeUndefined;\n    toContain: typeof jasmine.matchers.toContain;\n    toEqual: typeof jasmine.matchers.toEqual;\n    toHaveBeenCalled: typeof jasmine.matchers.toHaveBeenCalled;\n    toHaveBeenCalledWith: typeof jasmine.matchers.toHaveBeenCalledWith;\n    toMatch: typeof jasmine.matchers.toMatch;\n    toThrow: typeof jasmine.matchers.toThrow;\n    toThrowError: typeof jasmine.matchers.toThrowError;\n}\n\n// Seen as: options\ninterface interface_693 {\n    addToExistingQueryString: any;\n    createElement: (arg0: void) => void;\n    createTextNode: (arg0: void) => void;\n    env: any;\n    getContainer: () => void;\n    onRaiseExceptionsClick: any;\n    timer: any;\n}\n\ninterface interface_669 {\n    [index: number]: {message: any, stack: any};\n    length: number;\n}\n\n// Seen as: result\ninterface interface_695 {\n    failedExpectations: interface_669;\n    fullName: string | number;\n    id: string | number;\n    passedExpectations: {length: string | number};\n    status: string;\n}\n\ninterface interface_697 {\n    clearTimeout: (handle: number) => void;\n    setTimeout: (handler: any, timeout: any, args: any) => number;\n}\n\n// Seen as: attrs, options\ninterface interface_698 {\n    catchException: (e: {toString: () => void}) => boolean;\n    clearStack: (fn: () => void) => void;\n    fail: (error: {message: any}) => void;\n    onComplete: () => void;\n    onException: () => void;\n    queueableFns: Array<any>;\n    timeout: any;\n    timer: interface_697;\n    userContext: any;\n}\n\n// Seen as: arg0, queueableFns\ninterface interface_653 {\n    [index: number]: {fn: interface_859, timeout: () => void};\n    length: number;\n}\n\ninterface interface_700 {\n    clearTimeout: (handle: number) => void;\n    setTimeout: (handler: any, timeout: any, args: any) => number;\n}\n\n// Seen as: spec\ninterface interface_703 {\n    addExpectationResult: (arg0: void, arg1: void) => void;\n    id: string | number;\n}\n\n// Seen as: attrs, options\ninterface interface_705 {\n    actual: any;\n    error: any;\n    expected: any;\n    matcherName: any;\n    message: any;\n    messageFormatter: (error: interface_685) => string;\n    passed: any;\n    stackFormatter: (error: {stack: any}) => any;\n}\n\n// Seen as: result\ninterface interface_708 {\n    actual: any;\n    expected: any;\n    matcherName: any;\n    message: string;\n    passed: any;\n    stack: string;\n}\n\n// Seen as: attrs, options\ninterface interface_710 {\n    catchException: (e: {toString: () => void}) => boolean;\n    clearStack: (fn: () => void) => void;\n    fail: (error: {message: any}) => void;\n    onComplete: () => void;\n    onException: () => void;\n    queueableFns: Array<any>;\n    timeout: any;\n    timer: interface_676;\n    userContext: any;\n}\n\n// Seen as: attrs\ninterface interface_712 {\n    beforeAndAfterFns: () => {afters: Array<any>, befores: any};\n    catchingExceptions: any;\n    description: string;\n    expectationFactory: (actual: any, spec: interface_703) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationResultFactory: (attrs: interface_705) => interface_708;\n    getSpecName: (spec: void) => string | number;\n    id: string | number;\n    onStart: (spec: void) => void;\n    queueRunnerFactory: (options: interface_710) => void;\n    queueableFn: {fn: () => void, timeout: () => number};\n    resultCallback: (result: void) => void;\n    userContext: () => any;\n}\n\ninterface interface_714 {\n    actual: string;\n    error: any;\n    expected: string;\n    matcherName: string;\n    passed: boolean;\n}\n\ninterface interface_717 {\n    description: string;\n    failedExpectations: Array<any>;\n    fullName: any;\n    id: any;\n    passedExpectations: Array<any>;\n    pendingReason: string;\n}\n\n// Seen as: obj\ninterface interface_638 {\n}\n\n// Seen as: spy\ninterface interface_519 {\n    () : any;\n    and: jasmine.SpyStrategy;\n    calls: jasmine.CallTracker;\n}\n\n// Seen as: options\ninterface interface_719 {\n    fn: any;\n    getSpy: () => interface_519;\n    name: string | number;\n}\n\n// Seen as: attrs\ninterface interface_721 {\n    clearStack: any;\n    description: string;\n    env: jasmine.Env;\n    expectationFactory: (actual: any, spec: interface_703) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationResultFactory: (attrs: interface_705) => interface_708;\n    id: string;\n    onStart: (suite: void) => void;\n    parentSuite: jasmine.Suite;\n    queueRunner: (options: interface_710) => void;\n    resultCallback: (attrs: void) => void;\n    runnablesExplictlySetGetter: () => boolean;\n}\n\n// Seen as: attrs, options\ninterface interface_723 {\n    actual: any;\n    error: any;\n    expected: any;\n    matcherName: any;\n    message: any;\n    messageFormatter: (error: interface_685) => string;\n    passed: any;\n    stackFormatter: (error: {stack: any}) => any;\n}\n\n// Seen as: spy\ninterface interface_631 {\n    () : any;\n    and: jasmine.SpyStrategy;\n    calls: jasmine.CallTracker;\n}\n\n// Seen as: baseName, methodNames\ninterface interface_661 {\n    [index: number]: string | number;\n}\n\n// Seen as: obj\ninterface interface_664 {\n}\n\n// Seen as: actual, expected, value\ninterface interface_725 {\n    and: {identity: void};\n    calls: {allArgs: void, any: void};\n    jasmineToString: void;\n    nodeType: any;\n    test: void;\n    toString: void;\n}\n\n// Seen as: a, b, obj\ninterface interface_726 {\n    constructor: void;\n    global: any;\n    ignoreCase: any;\n    innerText: any;\n    isEqualNode: void;\n    length: any;\n    message: any;\n    multiline: any;\n    nodeType: number;\n    outerHTML: any;\n    source: any;\n    textContent: any;\n}\n\n// Seen as: actual, expected, putativeSpy, value\ninterface interface_729 {\n    and: {identity: void};\n    calls: {allArgs: void, any: void};\n    jasmineToString: void;\n    nodeType: any;\n    test: void;\n    toString: void;\n}\n\ninterface interface_730 {\n    compare: (expected: any, expected1: any) => {pass: boolean};\n}\n\ninterface interface_732 {\n    compare: (actual: number, expected: number, precision: number) => {pass: boolean};\n}\n\ninterface interface_734 {\n    compare: (actual: number, expected: number) => {pass: boolean};\n}\n\ninterface interface_736 {\n    compare: (actual: number, expected: number) => {pass: boolean};\n}\n\n// Seen as: array, obj, putativeSpy, value\ninterface interface_469 {\n    and: {identity: () => void};\n    calls: any;\n    jasmineToString: () => void;\n    nodeType: any;\n}\n\ninterface interface_738 {\n    compare: (actual: number | Window | interface_469) => {message: string | (() => string), pass: boolean};\n}\n\n// Seen as: util\ninterface interface_740 {\n    contains: (arg0: void, arg1: void, arg2: void) => void;\n}\n\ninterface interface_742 {\n    compare: (actual: any, expected: any) => {pass: any};\n}\n\n// Seen as: util\ninterface interface_744 {\n    equals: (arg0: void, arg1: void, arg2: void) => void;\n}\n\ninterface interface_746 {\n    compare: (actual: any, expected: any) => {pass: boolean};\n}\n\n// Seen as: actual, array, obj, putativeSpy, value\ninterface interface_447 {\n    and: {identity: () => void};\n    calls: {any: () => void};\n    jasmineToString: () => void;\n    nodeType: any;\n}\n\ninterface interface_748 {\n    compare: (actual: Window | number | interface_447) => {message: string, pass: any};\n}\n\n// Seen as: util\ninterface interface_750 {\n    contains: (arg0: void, arg1: void, arg2: void) => void;\n}\n\ninterface interface_752 {\n    compare: () => {message: () => string, pass: boolean};\n}\n\ninterface interface_753 {\n    compare: (actual: string, expected: string) => {pass: boolean};\n}\n\n// Seen as: array, obj, putativeSpy, value\ninterface interface_464 {\n    and: {identity: () => void};\n    calls: any;\n    jasmineToString: () => void;\n    nodeType: any;\n}\n\ninterface interface_756 {\n    compare: (actual: () => void, expected: number | Window | interface_464) => {message: string | (() => string), pass: boolean};\n}\n\ninterface interface_758 {\n    compare: (actual: () => void) => {message: string | (() => string), pass: boolean};\n}\n\n// Seen as: haystack\ninterface interface_405 {\n    [index: number]: string | interface_858;\n    indexOf: (arg0: void) => void;\n    length: number;\n}\n\n// Seen as: a, b, obj\ninterface interface_760 {\n    asymmetricMatch: (arg0: void) => void;\n    constructor: NumberConstructor;\n    global: any;\n    ignoreCase: any;\n    innerText: any;\n    isEqualNode: (arg0: void) => void;\n    length: any;\n    message: any;\n    multiline: any;\n    nodeType: number;\n    outerHTML: any;\n    source: any;\n    textContent: any;\n}\n\ninterface function_763 {\n    (arg0: void, arg1: void) : void;\n}\n\n// Seen as: actual, array, expected, obj, putativeSpy, value\ninterface interface_630 {\n    and: {identity: () => void};\n    calls: {allArgs: void, any: void};\n    jasmineToString: () => void;\n    nodeType: any;\n    test: void;\n}\n\n// Seen as: args\ninterface interface_648 {\n    [index: number]: any;\n    length: number;\n}\n\n// Seen as: actual, expected, value\ninterface interface_765 {\n    and: {identity: void};\n    calls: {allArgs: void, any: void};\n    jasmineToString: void;\n    nodeType: any;\n    test: void;\n    toString: void;\n}\n\n// Seen as: actual, expected, methodNames, value\ninterface interface_767 {\n    and: {identity: void};\n    calls: {allArgs: void, any: void};\n    jasmineToString: void;\n    length: number;\n    nodeType: any;\n    test: void;\n    toString: void;\n}\n\n// Seen as: j$\ninterface interface_770 {\n    matchersUtil: {contains: (arg0: void, arg1: void) => void};\n}\n\n// Seen as: arguments, global, id\ninterface interface_525 {\n    [index: number]: any;\n    clearInterval: (id: any, arg1: void, arg2: void, arg3: void) => any;\n    clearTimeout: (id: any, arg1: void, arg2: void, arg3: void) => any;\n    length: number;\n    setInterval: (fn: any, interval: any, arg2: void, arg3: void, arg4: void) => any;\n    setTimeout: (arg0: any, delay: any, arg2: void, arg3: void, arg4: void) => any;\n}\n\n// Seen as: delayedFunctionScheduler\ninterface interface_773 {\n    removeFunctionWithId: (arg0: void) => void;\n    reset: () => void;\n    scheduleFunction: (arg0: void, arg1: void, arg2: void, arg3: void) => void;\n    tick: (arg0: void) => void;\n}\n\n// Seen as: mockDate\ninterface interface_775 {\n    install: (arg0: void) => void;\n    tick: (arg0: void) => void;\n    uninstall: () => void;\n}\n\n// Seen as: arguments, global, id\ninterface interface_531 {\n    [index: number]: any;\n    clearInterval: (id: any, arg1: void, arg2: void, arg3: void) => any;\n    clearTimeout: (id: any, arg1: void, arg2: void, arg3: void) => any;\n    length: number;\n    setInterval: (fn: any, interval: any, arg2: void, arg3: void, arg4: void) => any;\n    setTimeout: (arg0: any, delay: any, arg2: void, arg3: void, arg4: void) => any;\n}\n\n// Seen as: arguments, global, id\ninterface interface_530 {\n    [index: number]: any;\n    clearInterval: (id: any, arg1: void, arg2: void, arg3: void) => any;\n    clearTimeout: (id: any, arg1: void, arg2: void, arg3: void) => any;\n    length: number;\n    setInterval: (fn: any, interval: any, arg2: void, arg3: void, arg4: void) => any;\n    setTimeout: (arg0: any, delay: any, arg2: void, arg3: void, arg4: void) => any;\n}\n\ninterface function_778 {\n    () : interface_781;\n}\n\n// Seen as: self\ninterface interface_781 {\n    clearInterval: (id: interface_531) => any;\n    clearTimeout: (id: interface_530) => any;\n    install: function_778;\n    mockDate: (initialDate: any) => void;\n    setInterval: (fn: any, delay: any, params: any) => any;\n    setTimeout: (fn: any, delay: any, params: any) => any;\n    tick: (millis: any) => void;\n    uninstall: () => void;\n}\n\n// Seen as: self\ninterface interface_783 {\n    removeFunctionWithId: (timeoutKey: any) => void;\n    reset: () => void;\n    scheduleFunction: (funcToCall: string | (() => any), millis: number, params: any, recurring: any, timeoutKey: number, runAtMillis: string) => number;\n    tick: (millis: number) => void;\n}\n\ninterface interface_785 {\n    Factory: (arg0: void) => void;\n    addCoreMatchers: (arg0: void) => void;\n}\n\ninterface interface_577 {\n    (arg0: void) : void;\n    isPendingSpecException: (arg0: void) => void;\n    pendingSpecExceptionMessage: string | number;\n}\n\n// Seen as: j$\ninterface interface_788 {\n    Clock: (arg0: void, arg1: void, arg2: void) => void;\n    DEFAULT_TIMEOUT_INTERVAL: any;\n    DelayedFunctionScheduler: () => void;\n    ExceptionFormatter: () => void;\n    Expectation: interface_785;\n    MockDate: (arg0: void) => void;\n    QueueRunner: (arg0: void) => void;\n    ReportDispatcher: (arg0: void) => void;\n    Spec: interface_577;\n    SpyRegistry: (arg0: void) => void;\n    Suite: (arg0: void) => void;\n    buildExpectationResult: (arg0: void) => void;\n    getGlobal: () => void;\n    matchers: any;\n    matchersUtil: any;\n    util: {clone: (arg0: void) => void};\n}\n\n// Seen as: Expectation\ninterface interface_603 {\n    (options: interface_861) : void;\n    Factory: (options: interface_862) => {not: any};\n    addCoreMatchers: (matchers: any) => void;\n}\n\n// Seen as: j$\ninterface interface_789 {\n    HtmlReporter: (options: void) => any;\n    HtmlSpecFilter: (options: void) => void;\n    QueryString: (options: void) => any;\n    ResultsNode: (result: void, type: void, parent: void) => void;\n    version: any;\n}\n\n// Seen as: options\ninterface interface_791 {\n    addToExistingQueryString: any;\n    createElement: (arg0: void) => void;\n    createTextNode: (arg0: void) => void;\n    env: any;\n    getContainer: () => void;\n    onRaiseExceptionsClick: any;\n    timer: any;\n}\n\ninterface interface_533 {\n    [index: number]: {message: any, stack: any};\n    length: number;\n}\n\n// Seen as: arg0, result\ninterface interface_793 {\n    failedExpectations: interface_533;\n    fullName: string | number;\n    id: string | number;\n    passedExpectations: {length: string | number};\n    status: string;\n}\n\ninterface interface_795 {\n    initialize: () => void;\n    jasmineDone: () => void;\n    jasmineStarted: (options: {totalSpecsDefined: any}) => void;\n    specDone: (result: interface_793) => void;\n    specStarted: (result: any) => void;\n    suiteDone: (result: {status: string}) => void;\n    suiteStarted: (result: any) => void;\n}\n\n// Seen as: FakeDate, GlobalDate\ninterface interface_593 {\n    (arg0: void, arg1: void, arg2: void, arg3: void, arg4: void, arg5: void, arg6: void) : any;\n    UTC: any;\n    now: () => number;\n    parse: any;\n    toSource: any;\n}\n\n// Seen as: self\ninterface interface_797 {\n    install: (mockDate: {getTime: () => void}) => void;\n    tick: (millis: number) => void;\n    uninstall: () => void;\n}\n\ninterface interface_799 {\n    fullStringWithNewParam: (key: string, value: any) => string;\n    getParam: (key: string) => any;\n    navigateWithNewParam: (key: any, value: any) => void;\n}\n\n// Seen as: attrs\ninterface interface_801 {\n    catchException: any;\n    clearStack: any;\n    fail: any;\n    onComplete: any;\n    onException: any;\n    queueableFns: any;\n    timeout: any;\n    userContext: any;\n}\n\ninterface interface_592 {\n    addReporter: (reporter: any) => void;\n}\n\n// Seen as: Spec\ninterface interface_598 {\n    (attrs: interface_863) : void;\n    isPendingSpecException: (e: {toString: () => void}) => boolean;\n    pendingSpecExceptionMessage: string;\n}\n\n// Seen as: j$\ninterface interface_803 {\n    createSpy: (arg0: void, arg1: void) => void;\n    isSpy: (arg0: void) => void;\n    util: {isUndefined: (arg0: void) => void};\n}\n\n// Seen as: j$\ninterface interface_804 {\n    isA_: (arg0: void, arg1: void) => void;\n    isString_: (arg0: void) => void;\n}\n\n// Seen as: attrs\ninterface interface_806 {\n    clearStack: any;\n    description: any;\n    env: any;\n    expectationFactory: any;\n    expectationResultFactory: any;\n    id: any;\n    onStart: any;\n    parentSuite: any;\n    queueRunner: any;\n    resultCallback: any;\n    runnablesExplictlySetGetter: any;\n}\n\n// Seen as: spy\ninterface interface_616 {\n    () : any;\n    and: {exec: {apply: (arg0: void, arg1: void) => void}};\n    calls: {track: (arg0: void) => void};\n}\n\n// Seen as: baseName, methodNames\ninterface interface_621 {\n    [index: number]: string | number;\n}\n\n// Seen as: baseName, methodNames\ninterface interface_622 {\n    [index: number]: string | number;\n}\n\n// Seen as: obj\ninterface interface_625 {\n}\n\n// Seen as: j$\ninterface interface_808 {\n    Any: (arg0: void) => void;\n    Anything: () => void;\n    ArrayContaining: (arg0: void) => void;\n    CallTracker: () => void;\n    DEFAULT_TIMEOUT_INTERVAL: number;\n    Env: (arg0: void) => void;\n    MAX_PRETTY_PRINT_ARRAY_LENGTH: number;\n    MAX_PRETTY_PRINT_DEPTH: number;\n    ObjectContaining: (arg0: void) => void;\n    SpyStrategy: (arg0: void) => void;\n    StringMatching: (arg0: void) => void;\n    any: (clazz: any) => any;\n    anything: () => any;\n    arrayContaining: (sample: any) => any;\n    createSpy: (name: any, originalFn: any) => interface_616;\n    createSpyObj: (methodNames: string | interface_621, methodNames1: string | interface_622) => interface_625;\n    currentEnv_: any;\n    fnNameFor: (func: {name: any, toString: () => void}) => any;\n    getEnv: (options: any) => any;\n    getGlobal: () => any;\n    isA_: (typeName: string | number, value: any) => boolean;\n    isArray_: (value: any) => boolean;\n    isDomNode: (obj: {nodeType: number}) => boolean;\n    isNumber_: (value: any) => boolean;\n    isSpy: (putativeSpy: {and: any, calls: any}) => boolean;\n    isString_: (value: any) => boolean;\n    objectContaining: (sample: any) => any;\n    stringMatching: (expected: any) => any;\n    unimplementedMethod_: () => void;\n    util: {isUndefined: (arg0: void) => void};\n}\n\n// Seen as: options\ninterface interface_810 {\n    actual: any;\n    error: any;\n    expected: any;\n    matcherName: any;\n    message: any;\n    messageFormatter: any;\n    passed: any;\n    stackFormatter: any;\n}\n\n// Seen as: result\ninterface interface_812 {\n    actual: any;\n    expected: any;\n    matcherName: any;\n    message: string;\n    passed: any;\n    stack: string;\n}\n\n// Seen as: jRequire\ninterface interface_814 {\n    Any: () => void;\n    Anything: (arg0: void) => void;\n    ArrayContaining: (arg0: void) => void;\n    CallTracker: () => void;\n    Clock: () => void;\n    DelayedFunctionScheduler: () => void;\n    Env: (arg0: void) => void;\n    ExceptionFormatter: () => void;\n    Expectation: () => void;\n    JsApiReporter: () => void;\n    MockDate: () => void;\n    ObjectContaining: (arg0: void) => void;\n    QueueRunner: (arg0: void) => void;\n    ReportDispatcher: () => void;\n    Spec: (arg0: void) => void;\n    SpyRegistry: (arg0: void) => void;\n    SpyStrategy: () => void;\n    StringMatching: (arg0: void) => void;\n    Suite: () => void;\n    Timer: () => void;\n    base: (arg0: void, arg1: void) => void;\n    buildExpectationResult: () => void;\n    matchersUtil: (arg0: void) => void;\n    pp: (arg0: void) => void;\n    requireMatchers: (arg0: void, arg1: void) => void;\n    util: () => void;\n    version: () => void;\n}\n\n// Seen as: j$\ninterface interface_816 {\n    Any: any;\n    Anything: any;\n    ArrayContaining: any;\n    CallTracker: any;\n    Clock: any;\n    DelayedFunctionScheduler: any;\n    Env: any;\n    ExceptionFormatter: any;\n    Expectation: any;\n    JsApiReporter: any;\n    MockDate: any;\n    ObjectContaining: any;\n    QueueRunner: any;\n    ReportDispatcher: any;\n    Spec: any;\n    SpyRegistry: any;\n    SpyStrategy: any;\n    StringMatching: any;\n    Suite: any;\n    Timer: any;\n    buildExpectationResult: any;\n    matchers: any;\n    matchersUtil: any;\n    pp: any;\n    util: any;\n    version: any;\n}\n\n// Seen as: j$\ninterface interface_817 {\n    HtmlReporter: (options: interface_791) => interface_795;\n    HtmlSpecFilter: (options: {filterString: () => void}) => void;\n    QueryString: (options: {getWindowLocation: () => void}) => interface_799;\n    ResultsNode: (result: any, type: any, parent: any) => void;\n    version: any;\n}\n\ninterface interface_821 {\n    Any: () => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_770) => (sample: any) => void;\n    CallTracker: () => () => void;\n    Clock: () => (global: interface_525, delayedFunctionScheduler: interface_773, mockDate: interface_775) => interface_781;\n    DelayedFunctionScheduler: () => () => interface_783;\n    Env: (j$: interface_788) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_603;\n    HtmlReporter: (j$: interface_789) => (options: interface_791) => interface_795;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_593}) => interface_797;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_799;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_801) => void;\n    ReportDispatcher: () => (methods: any) => interface_592;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: any) => interface_598;\n    SpyRegistry: (j$: interface_803) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_804) => (expected: string) => void;\n    Suite: () => (attrs: interface_806) => void;\n    Timer: () => (options: {now: any}) => void;\n    base: (j$: interface_808, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_810) => interface_812;\n    core: (jRequire: interface_814) => interface_816;\n    html: (j$: interface_817) => void;\n    \"interface\": function_820;\n    matchersUtil: (j$: interface_824) => interface_830;\n    pp: (j$: interface_832) => (value: any) => any;\n    requireMatchers: (jRequire: interface_568, j$: any) => interface_571;\n    toBe: () => () => interface_834;\n    toBeCloseTo: () => () => interface_835;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_836;\n    toBeLessThan: () => () => interface_837;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_838;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_839, customEqualityTesters: Array<any>) => interface_841;\n    toEqual: () => (util: interface_842, customEqualityTesters: Array<any>) => interface_843;\n    toHaveBeenCalled: (j$: interface_844) => () => interface_846;\n    toHaveBeenCalledWith: (j$: interface_847) => (util: interface_849, customEqualityTesters: any) => interface_850;\n    toMatch: (j$: interface_851) => () => interface_852;\n    toThrow: (j$: {pp: (arg0: void) => void}) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_853;\n    toThrowError: (j$: interface_854) => (util: any) => interface_855;\n    util: () => interface_857;\n    version: () => string;\n}\n\ninterface function_820 {\n    (jasmine: interface_865, env: interface_866) : interface_867;\n}\n\n// Seen as: j$\ninterface interface_824 {\n    isA_: (arg0: void, arg1: void) => void;\n    isDomNode: (arg0: void) => void;\n    pp: (arg0: void) => void;\n    util: {isUndefined: (arg0: void) => void};\n}\n\n// Seen as: haystack\ninterface interface_605 {\n    [index: number]: string | interface_868;\n    indexOf: (arg0: void) => void;\n    length: number;\n}\n\n// Seen as: a, arg0, arg1, b, obj\ninterface interface_825 {\n    asymmetricMatch: (arg0: void) => void;\n    constructor: NumberConstructor;\n    global: any;\n    ignoreCase: any;\n    innerText: any;\n    isEqualNode: (arg0: void) => void;\n    length: any;\n    message: any;\n    multiline: any;\n    outerHTML: any;\n    source: any;\n    textContent: any;\n}\n\ninterface function_826 {\n    (arg0: void, arg1: void) : void;\n}\n\n// Seen as: a, arg0, arg1, b, obj\ninterface interface_828 {\n    asymmetricMatch: (arg0: void) => void;\n    constructor: NumberConstructor;\n    global: any;\n    ignoreCase: any;\n    innerText: any;\n    isEqualNode: (arg0: void) => void;\n    length: any;\n    message: any;\n    multiline: any;\n    outerHTML: any;\n    source: any;\n    textContent: any;\n}\n\n// Seen as: a, arg0, arg1, b, obj\ninterface interface_829 {\n    asymmetricMatch: (arg0: void) => void;\n    constructor: NumberConstructor;\n    global: any;\n    ignoreCase: any;\n    innerText: any;\n    isEqualNode: (arg0: void) => void;\n    length: any;\n    message: any;\n    multiline: any;\n    outerHTML: any;\n    source: any;\n    textContent: any;\n}\n\ninterface interface_830 {\n    buildFailureMessage: () => string;\n    contains: (haystack: interface_605, needle: string | interface_825, customTesters: Array<function_826>) => boolean;\n    equals: (a: string | interface_828, b: string | interface_829, customTesters: Array<function_826>) => boolean;\n}\n\ninterface interface_831 {\n    arrayContains: (arg0: void, arg1: void) => void;\n    inherit: (arg0: void, arg1: void) => void;\n    isUndefined: (arg0: void) => void;\n}\n\n// Seen as: j$\ninterface interface_832 {\n    MAX_PRETTY_PRINT_ARRAY_LENGTH: any;\n    MAX_PRETTY_PRINT_DEPTH: number;\n    fnNameFor: (arg0: void) => void;\n    getGlobal: () => void;\n    isA_: (arg0: void, arg1: void) => void;\n    isArray_: (arg0: void) => void;\n    isSpy: (arg0: void) => void;\n    unimplementedMethod_: any;\n    util: interface_831;\n}\n\n// Seen as: jRequire\ninterface interface_568 {\n}\n\n// Seen as: matchers\ninterface interface_571 {\n}\n\ninterface interface_834 {\n    compare: (expected: any, expected1: any) => {pass: boolean};\n}\n\ninterface interface_835 {\n    compare: (actual: number, expected: number, precision: number) => {pass: boolean};\n}\n\ninterface interface_836 {\n    compare: (actual: number, expected: number) => {pass: boolean};\n}\n\ninterface interface_837 {\n    compare: (actual: number, expected: number) => {pass: boolean};\n}\n\ninterface interface_838 {\n    compare: (actual: any) => {message: (() => string) | string, pass: boolean};\n}\n\n// Seen as: util\ninterface interface_839 {\n    contains: (arg0: void, arg1: void, arg2: void) => void;\n}\n\ninterface interface_841 {\n    compare: (actual: any, expected: any) => {pass: any};\n}\n\n// Seen as: util\ninterface interface_842 {\n    equals: (arg0: void, arg1: void, arg2: void) => void;\n}\n\ninterface interface_843 {\n    compare: (actual: any, expected: any) => {pass: boolean};\n}\n\n// Seen as: j$\ninterface interface_844 {\n    isSpy: (arg0: void) => void;\n    pp: (arg0: void) => void;\n}\n\n// Seen as: actual\ninterface interface_845 {\n    and: {identity: () => void};\n    calls: {any: () => void};\n}\n\ninterface interface_846 {\n    compare: (actual: interface_845) => {message: string, pass: any};\n}\n\n// Seen as: j$\ninterface interface_847 {\n    isSpy: (arg0: void) => void;\n    pp: (arg0: void) => void;\n}\n\n// Seen as: util\ninterface interface_849 {\n    contains: (arg0: void, arg1: void, arg2: void) => void;\n}\n\ninterface interface_850 {\n    compare: () => {message: () => string, pass: boolean};\n}\n\n// Seen as: j$\ninterface interface_851 {\n    isA_: (arg0: void, arg1: void) => void;\n    isString_: (arg0: void) => void;\n}\n\ninterface interface_852 {\n    compare: (actual: string, expected: string) => {pass: boolean};\n}\n\ninterface interface_853 {\n    compare: (actual: () => void, expected: any) => {message: string | (() => string), pass: boolean};\n}\n\n// Seen as: j$\ninterface interface_854 {\n    fnNameFor: (arg0: void) => void;\n    pp: (arg0: void) => void;\n}\n\ninterface interface_855 {\n    compare: (actual: () => void) => {message: string | (() => string), pass: boolean};\n}\n\n// Seen as: args\ninterface interface_547 {\n    [index: number]: any;\n    length: number;\n}\n\n// Seen as: array\ninterface interface_542 {\n    [index: number]: any;\n    length: number;\n}\n\n// Seen as: util\ninterface interface_857 {\n    argsToArray: (args: interface_547) => Array<any>;\n    arrayContains: (array: interface_542, search: any) => boolean;\n    clone: (obj: {slice: () => void}) => any;\n    htmlEscape: (str: {replace: (arg0: void, arg1: void) => void}) => {replace: (arg0: void, arg1: void) => void};\n    inherit: (childClass: {prototype: any}, parentClass: {prototype: any}) => void;\n    isUndefined: (obj: any) => boolean;\n}\n\n// Seen as: a, b, obj\ninterface interface_858 {\n    asymmetricMatch: (arg0: void) => void;\n    constructor: NumberConstructor;\n    global: any;\n    ignoreCase: any;\n    innerText: any;\n    isEqualNode: (arg0: void) => void;\n    length: any;\n    message: any;\n    multiline: any;\n    nodeType: number;\n    outerHTML: any;\n    source: any;\n    textContent: any;\n}\n\ninterface interface_859 {\n    call: (arg0: void, arg1: void) => void;\n    length: number;\n}\n\n// Seen as: arg0, options\ninterface interface_861 {\n    actual: any;\n    addExpectationResult: any;\n    customEqualityTesters: any;\n    customMatchers: any;\n    isNot: any;\n    util: any;\n}\n\n// Seen as: arg0, options\ninterface interface_862 {\n    actual: any;\n    addExpectationResult: any;\n    customEqualityTesters: any;\n    customMatchers: any;\n    isNot: boolean;\n    util: any;\n}\n\n// Seen as: attrs\ninterface interface_863 {\n    beforeAndAfterFns: any;\n    catchingExceptions: any;\n    description: any;\n    expectationFactory: any;\n    expectationResultFactory: any;\n    getSpecName: any;\n    id: any;\n    onStart: any;\n    queueRunnerFactory: any;\n    queueableFn: {fn: any};\n    resultCallback: any;\n    userContext: any;\n}\n\n// Seen as: jasmine\ninterface interface_865 {\n    JsApiReporter: (arg0: void) => void;\n    Timer: () => void;\n    addCustomEqualityTester: (tester: any) => void;\n    addMatchers: (matchers: any) => any;\n    clock: () => any;\n}\n\n// Seen as: env\ninterface interface_866 {\n    addCustomEqualityTester: (arg0: void) => void;\n    addMatchers: (arg0: void) => void;\n    afterAll: {apply: (arg0: void, arg1: void) => void};\n    afterEach: {apply: (arg0: void, arg1: void) => void};\n    beforeAll: {apply: (arg0: void, arg1: void) => void};\n    beforeEach: {apply: (arg0: void, arg1: void) => void};\n    clock: any;\n    describe: (arg0: void, arg1: void) => void;\n    expect: (arg0: void) => void;\n    fail: {apply: (arg0: void, arg1: void) => void};\n    fdescribe: (arg0: void, arg1: void) => void;\n    fit: {apply: (arg0: void, arg1: void) => void};\n    it: {apply: (arg0: void, arg1: void) => void};\n    pending: {apply: (arg0: void, arg1: void) => void};\n    spyOn: (arg0: void, arg1: void) => void;\n    xdescribe: (arg0: void, arg1: void) => void;\n    xit: {apply: (arg0: void, arg1: void) => void};\n}\n\n// Seen as: jasmineInterface\ninterface interface_867 {\n    afterAll: () => any;\n    afterEach: () => any;\n    beforeAll: () => any;\n    beforeEach: () => any;\n    describe: (description: any, specDefinitions: any) => any;\n    expect: (actual: any) => any;\n    fail: () => any;\n    fdescribe: (description: any, specDefinitions: any) => any;\n    fit: () => any;\n    it: () => any;\n    jasmine: interface_865;\n    jsApiReporter: any;\n    pending: () => any;\n    spyOn: (obj: any, methodName: any) => any;\n    xdescribe: (description: any, specDefinitions: any) => any;\n    xit: () => any;\n}\n\n// Seen as: a, arg0, arg1, b, obj\ninterface interface_868 {\n    asymmetricMatch: (arg0: void) => void;\n    constructor: NumberConstructor;\n    global: any;\n    ignoreCase: any;\n    innerText: any;\n    isEqualNode: (arg0: void) => void;\n    length: any;\n    message: any;\n    multiline: any;\n    outerHTML: any;\n    source: any;\n    textContent: any;\n}\n\n","newDeclaration":"declare function beforeEach(): any;\ndeclare function xit(): {pend: (arg0: void) => void};\ndeclare function afterEach(): any;\ndeclare function fdescribe(description: any, specDefinitions: {call: (arg0: void) => void}): jasmine.Suite | {id: any, isFocused: boolean};\ndeclare function beforeAll(): any;\ndeclare function afterAll(): any;\ndeclare function xdescribe(description: any, specDefinitions: {call: (arg0: void) => void}): jasmine.Suite;\ndeclare function pending(): any;\ndeclare function getJasmineRequireObj(): interface_676;\ndeclare var jsApiReporter: jasmine.JsApiReporter;\ndeclare function it(): {disabled: boolean} | jasmine.Spec;\ndeclare module jasmine {\n    export class Any {\n        constructor (expectedObject: any);\n        asymmetricMatch: (other: any) => boolean;\n        expectedObject: any;\n        jasmineToString: () => string;\n    }\n    export class Anything {\n        constructor ();\n        asymmetricMatch: (other: any) => boolean;\n        jasmineToString: () => string;\n    }\n    export class ArrayContaining {\n        constructor (sample: any);\n        asymmetricMatch: (other: interface_619) => boolean;\n        jasmineToString: () => string;\n        sample: any;\n    }\n    export class CallTracker {\n        constructor ();\n        all: () => Array<interface_679>;\n        allArgs: () => Array<any>;\n        any: () => boolean;\n        argsFor: (index: number) => Array<any>;\n        count: () => number;\n        first: () => interface_679;\n        mostRecent: () => interface_679;\n        reset: () => void;\n        saveArgumentsByValue: () => void;\n        track: (context: {args: any[]}) => void;\n    }\n    export class Clock {\n        constructor (global: Window | interface_470, delayedFunctionSchedulerFactory: () => jasmine.DelayedFunctionScheduler, mockDate: jasmine.MockDate);\n        clearInterval: (id: Window) => any;\n        clearTimeout: (id: Window) => any;\n        install: () => jasmine.Clock;\n        mockDate: (initialDate: {getTime: () => void}) => void;\n        setInterval: (fn: any, delay: any, params: any) => any;\n        setTimeout: (fn: any, delay: any, params: any) => any;\n        tick: (millis: any) => void;\n        uninstall: () => void;\n        withMock: (closure: () => void) => void;\n    }\n    export var DEFAULT_TIMEOUT_INTERVAL: number;\n    export class DelayedFunctionScheduler {\n        constructor ();\n        removeFunctionWithId: (timeoutKey: any) => void;\n        scheduleFunction: (funcToCall: string | (() => any), millis: number, params: any, recurring: any, timeoutKey: number, newCurrentTime: string) => number;\n        tick: (millis: number, tickDate: (arg0: void) => void) => void;\n    }\n    export class Env {\n        constructor (options: {global: any});\n        addCustomEqualityTester: (tester: any) => void;\n        addMatchers: (matchersToAdd: any) => void;\n        addReporter: (reporterToAdd: any) => void;\n        afterAll: (afterAllFunction: any, timeout: any) => void;\n        afterEach: (afterEachFunction: any, timeout: any) => void;\n        allowRespy: (allow: any) => void;\n        beforeAll: (beforeAllFunction: any, timeout: any) => void;\n        beforeEach: (beforeEachFunction: any, timeout: any) => void;\n        catchExceptions: (value: any) => boolean;\n        catchingExceptions: () => boolean;\n        clock: jasmine.Clock;\n        describe: (description: any, specDefinitions: {call: (arg0: void) => void, length: number}) => jasmine.Suite;\n        execute: (runnablesToRun: string[]) => void;\n        expect: (actual: any) => any;\n        fail: (error: {message: any}) => void;\n        fdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite | {id: any, isFocused: boolean};\n        fit: (description: any, fn: any, timeout: any) => {disabled: boolean} | jasmine.Spec;\n        it: (description: string, fn: () => void, timeout: any) => {disabled: boolean} | jasmine.Spec;\n        pending: (message: string) => void;\n        provideFallbackReporter: (reporterToAdd: any) => void;\n        randomTests: () => boolean;\n        randomizeTests: (value: any) => void;\n        seed: (value: any) => any;\n        specFilter: (spec: jasmine.Spec) => boolean;\n        spyOn: () => interface_490;\n        throwOnExpectationFailure: (value: any) => void;\n        throwingExpectationFailures: () => boolean;\n        topSuite: () => jasmine.Suite;\n        xdescribe: (description: any, specDefinitions: {call: (arg0: void) => void}) => jasmine.Suite;\n        xit: () => {pend: (arg0: void) => void};\n    }\n    export class ExceptionFormatter {\n        constructor ();\n        message: (error: interface_682) => string;\n        stack: (error: {stack: any}) => any;\n    }\n    export class Expectation {\n        constructor (options: interface_686);\n        static Factory: (options: interface_689) => jasmine.Expectation | {not: jasmine.Expectation};\n        static addCoreMatchers: (matchers: interface_691) => void;\n        actual: any;\n        addExpectationResult: () => void;\n        customEqualityTesters: Array<any>;\n        isNot: any;\n        toBe: () => void;\n        toBeCloseTo: () => void;\n        toBeDefined: () => void;\n        toBeFalsy: () => void;\n        toBeGreaterThan: () => void;\n        toBeGreaterThanOrEqual: () => void;\n        toBeLessThan: () => void;\n        toBeLessThanOrEqual: () => void;\n        toBeNaN: () => void;\n        toBeNull: () => void;\n        toBeTruthy: () => void;\n        toBeUndefined: () => void;\n        toContain: () => void;\n        toEqual: () => void;\n        toHaveBeenCalled: () => void;\n        toHaveBeenCalledTimes: () => void;\n        toHaveBeenCalledWith: () => void;\n        toMatch: () => void;\n        toThrow: () => void;\n        toThrowError: () => void;\n        util: {buildFailureMessage: () => void};\n        wrapCompare: (name: any, matcherFactory: (arg0: void, arg1: void) => void) => () => void;\n    }\n    export class HtmlReporter {\n        constructor (options: interface_694);\n        initialize: () => void;\n        jasmineDone: (doneResult: interface_696) => void;\n        jasmineStarted: (options: {totalSpecsDefined: number}) => void;\n        specDone: (result: interface_699) => void;\n        specStarted: (result: any) => void;\n        suiteDone: (result: {status: string}) => void;\n        suiteStarted: (result: any) => void;\n    }\n    export class HtmlSpecFilter {\n        constructor (options: {filterString: () => void});\n        matches: (specName: string) => boolean;\n    }\n    export class JsApiReporter {\n        constructor (options: {timer: any});\n        executionTime: () => number;\n        finished: boolean;\n        jasmineDone: (runDetails: interface_696) => void;\n        jasmineStarted: (arg0: {totalSpecsDefined: number}) => void;\n        runDetails: interface_701;\n        specDone: (result: any) => void;\n        specResults: (index: number, length: string | number) => Array<any>;\n        specs: () => Array<any>;\n        started: boolean;\n        status: () => string;\n        suiteDone: (result: {id: string | number}) => void;\n        suiteResults: (index: number, length: string | number) => Array<any>;\n        suiteStarted: (result: {id: string | number}) => void;\n        suites: () => any;\n    }\n    export var MAX_PRETTY_PRINT_ARRAY_LENGTH: number;\n    export var MAX_PRETTY_PRINT_DEPTH: number;\n    export class MockDate {\n        constructor (global: Window);\n        install: (mockDate: {getTime: () => void}) => void;\n        tick: (millis: number) => void;\n        uninstall: () => void;\n    }\n    export class ObjectContaining {\n        constructor (sample: any);\n        asymmetricMatch: (other: any) => boolean;\n        jasmineToString: () => string;\n        sample: any;\n    }\n    export class Order {\n        constructor (options: {random: boolean, seed: any});\n        random: boolean;\n        seed: string;\n        sort: (items: any) => any;\n    }\n    export class QueryString {\n        constructor (options: {getWindowLocation: () => void});\n        fullStringWithNewParam: (key: string, value: any) => string;\n        getParam: (key: string) => any;\n        navigateWithNewParam: (key: string, value: boolean) => void;\n    }\n    export class QueueRunner {\n        constructor (attrs: interface_704);\n        catchException: () => boolean;\n        clearStack: (fn: () => void) => void;\n        execute: () => void;\n        fail: () => void;\n        onComplete: () => void;\n        onException: () => void;\n        queueableFns: Array<any>;\n        run: (queueableFns: interface_633, recursiveIndex: number) => void;\n        timeout: interface_706;\n        userContext: any;\n    }\n    export class ReportDispatcher {\n        constructor (methods: string[]);\n        addReporter: (reporter: any) => void;\n        jasmineDone: () => void;\n        jasmineStarted: () => void;\n        provideFallbackReporter: (reporter: any) => void;\n        specDone: () => void;\n        specStarted: () => void;\n        suiteDone: () => void;\n        suiteStarted: () => void;\n    }\n    export class ResultsNode {\n        constructor (result: any, type: string, parent: any);\n        addChild: (result: any, type: string) => void;\n        children: Array<any>;\n        last: () => any;\n        parent: any;\n        result: any;\n        type: string;\n    }\n    export class Spec {\n        constructor (attrs: interface_715);\n        static isPendingSpecException: (e: {toString: () => void}) => boolean;\n        static pendingSpecExceptionMessage: string;\n        addExpectationResult: (passed: boolean, data: interface_716, isError: boolean) => void;\n        beforeAndAfterFns: () => {afters: Array<any>, befores: Array<any>};\n        catchingExceptions: () => boolean;\n        description: string;\n        disable: () => void;\n        execute: (onComplete: () => void, enabled: boolean) => void;\n        expect: (actual: any) => any;\n        expectationFactory: any;\n        expectationResultFactory: () => void;\n        getFullName: () => any;\n        getResult: () => {status: string};\n        getSpecName: () => string;\n        id: any;\n        isExecutable: () => boolean;\n        onException: (e: {toString: () => void}) => void;\n        onStart: () => void;\n        pend: (message: any) => void;\n        queueRunnerFactory: () => void;\n        queueableFn: {fn: any};\n        result: interface_718;\n        resultCallback: () => void;\n        status: (enabled: boolean) => string;\n        throwOnExpectationFailure: boolean;\n        userContext: () => any;\n    }\n    export class SpyRegistry {\n        constructor (options: {currentSpies: () => any});\n        allowRespy: (allow: any) => void;\n        clearSpies: () => void;\n        spyOn: (obj: interface_628, methodName: string) => interface_490;\n    }\n    export class SpyStrategy {\n        constructor (options: interface_720);\n        callFake: (originalFn: string | number | ((arg0: void, arg1: void, arg2: void, arg3: void, arg4: void) => any)) => any;\n        callThrough: () => any;\n        exec: () => any;\n        identity: () => string;\n        returnValue: (value: any) => any;\n        returnValues: () => any;\n        stub: (fn: any) => any;\n        throwError: (something: Error | string) => any;\n    }\n    export class StringMatching {\n        constructor (expected: string);\n        asymmetricMatch: (other: any) => any;\n        jasmineToString: () => string;\n        regexp: RegExp;\n    }\n    export class Suite {\n        constructor (attrs: interface_731);\n        addChild: (child: jasmine.Suite | jasmine.Spec | {id: void, isFocused: boolean}) => void;\n        addExpectationResult: () => void;\n        afterAll: (fn: {fn: any, timeout: () => number}) => void;\n        afterAllFns: Array<any>;\n        afterEach: (fn: {fn: any, timeout: () => number}) => void;\n        afterFns: Array<any>;\n        beforeAll: (fn: {fn: any, timeout: () => number}) => void;\n        beforeAllFns: Array<any>;\n        beforeEach: (fn: {fn: any, timeout: () => number}) => void;\n        beforeFns: Array<any>;\n        canBeReentered: () => boolean;\n        children: Array<any>;\n        clonedSharedUserContext: () => any;\n        description: string;\n        disable: () => void;\n        disabled: boolean;\n        env: jasmine.Env;\n        expect: (actual: any) => jasmine.Expectation | {not: jasmine.Expectation};\n        expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n        expectationResultFactory: (attrs: interface_722) => interface_724;\n        getFullName: () => string;\n        getResult: () => interface_733;\n        id: string;\n        isExecutable: () => boolean;\n        onException: () => void;\n        parentSuite: any;\n        pend: (message: any) => void;\n        result: interface_735;\n        sharedContext: any;\n        sharedUserContext: () => any;\n        status: () => string;\n        throwOnExpectationFailure: boolean;\n    }\n    export class Timer {\n        constructor (options: {now: any});\n        elapsed: () => number;\n        start: () => void;\n    }\n    export class TreeProcessor {\n        constructor (attrs: interface_743);\n        execute: (done: any) => void;\n        processTree: () => interface_611;\n    }\n    export function addCustomEqualityTester(tester: any): void;\n    export function addMatchers(matchers: any): any;\n    export function any(clazz: any): jasmine.Any;\n    export function anything(): jasmine.Anything;\n    export function arrayContaining(sample: any): jasmine.ArrayContaining;\n    export function buildExpectationResult(options: interface_745): interface_709;\n    export function clock(): jasmine.Clock;\n    export function createSpy(name: string | number, originalFn: any): interface_608;\n    export function createSpyObj(baseName: string | interface_640, methodNames: string | interface_640): interface_644;\n    export var currentEnv_: jasmine.Env;\n    export module errors {\n        export var ExpectationFailed: ExpectationFailedConstructor;\n    }\n    export function fnNameFor(func: {name: any, test: void, toString: () => void}): string;\n    export function formatErrorMsg(domain: string | number, usage: string | number): (msg: string | number) => string;\n    export function getEnv(options: {global: any}): jasmine.Env;\n    export function getGlobal(): Window;\n    export function isA_(typeName: string, value: interface_747 | string): boolean;\n    export function isArray_(value: interface_747 | string): boolean;\n    export function isDomNode(obj: interface_749): boolean;\n    export function isNumber_(value: any): boolean;\n    export function isSpy(putativeSpy: interface_751): boolean;\n    export function isString_(value: any): boolean;\n    export module matchers {\n        export function toBe(): interface_754;\n        export function toBeCloseTo(): interface_755;\n        export function toBeDefined(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeFalsy(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeGreaterThan(): interface_757;\n        export function toBeGreaterThanOrEqual(): interface_759;\n        export function toBeLessThan(): interface_761;\n        export function toBeLessThanOrEqual(): interface_762;\n        export function toBeNaN(): interface_764;\n        export function toBeNull(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeTruthy(): {compare: (actual: any) => {pass: boolean}};\n        export function toBeUndefined(): {compare: (actual: any) => {pass: boolean}};\n        export function toContain(util: interface_766, customEqualityTesters: Array<any>): interface_768;\n        export function toEqual(util: interface_769, customEqualityTesters: Array<any>): interface_771;\n        export function toHaveBeenCalled(): interface_772;\n        export function toHaveBeenCalledTimes(): interface_774;\n        export function toHaveBeenCalledWith(util: interface_776, customEqualityTesters: any): interface_777;\n        export function toMatch(): interface_779;\n        export function toThrow(util: {equals: (arg0: void, arg1: void) => void}): interface_780;\n        export function toThrowError(): interface_782;\n    }\n    export module matchersUtil {\n        export function buildFailureMessage(): string;\n        export function contains(haystack: interface_398, needle: string | interface_413, customTesters: Array<function_784>): boolean;\n        export function equals(a: string | interface_413, b: string | interface_413, customTesters: Array<function_784>): boolean;\n    }\n    export function objectContaining(sample: any): jasmine.ObjectContaining;\n    export function pp(value: number | Window | interface_607): any;\n    export function stringMatching(expected: string): jasmine.StringMatching;\n    export function unimplementedMethod_(): void;\n    export module util {\n        export function argsToArray(args: any[]): Array<any>;\n        export function arrayContains(array: any[], search: interface_747): boolean;\n        export function clone(obj: {slice: () => void}): any;\n        export function htmlEscape(str: {replace: (arg0: void, arg1: void) => void}): {replace: (arg0: void, arg1: void) => void};\n        export function inherit(childClass: {prototype: any}, parentClass: {prototype: any}): void;\n        export function isUndefined(obj: string | interface_786): boolean;\n    }\n    export var version: string;\n}\ndeclare function fit(): {disabled: boolean} | jasmine.Spec;\ndeclare function expect(actual: any): any;\ndeclare function fail(): any;\ndeclare function spyOn(obj: any, methodName: any): interface_490;\ndeclare var jasmineRequire: interface_873;\ndeclare function describe(description: any, specDefinitions: {call: (arg0: void) => void, length: number}): jasmine.Suite;\ninterface ExpectationFailedConstructor {\n    new () : ExpectationFailed\n}\n\n// Seen as: \ninterface ExpectationFailed extends Error {\n    stack: any;\n}\n\ninterface interface_676 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\n// Seen as: haystack\ninterface interface_619 {\n    [index: number]: string | interface_401;\n    indexOf: (arg0: void) => void;\n    length: number;\n}\n\n// Seen as: call\ninterface interface_679 {\n    args: Array<any>;\n}\n\n// Seen as: arguments, global, id\ninterface interface_470 {\n    [index: number]: any;\n}\n\n// Seen as: putativeSpy, spy\ninterface interface_490 {\n    () : any;\n    and: jasmine.SpyStrategy;\n    calls: jasmine.CallTracker;\n}\n\n// Seen as: error\ninterface interface_682 {\n    fileName: any;\n    line: any;\n    lineNumber: any;\n    message: string | number;\n    name: string | number;\n    sourceURL: any;\n    toString: () => void;\n}\n\ninterface interface_684 {\n    buildFailureMessage: typeof jasmine.matchersUtil.buildFailureMessage;\n    contains: typeof jasmine.matchersUtil.contains;\n    equals: typeof jasmine.matchersUtil.equals;\n}\n\n// Seen as: options\ninterface interface_686 {\n    actual: any;\n    addExpectationResult: (passed: void, result: void) => any;\n    customEqualityTesters: any;\n    customMatchers: any;\n    isNot: boolean;\n    util: interface_684;\n}\n\n// Seen as: options\ninterface interface_689 {\n    actual: any;\n    addExpectationResult: (passed: void, result: void) => any;\n    customEqualityTesters: any;\n    customMatchers: any;\n    isNot: boolean;\n    util: interface_684;\n}\n\ninterface interface_691 {\n    toBe: typeof jasmine.matchers.toBe;\n    toBeCloseTo: typeof jasmine.matchers.toBeCloseTo;\n    toBeDefined: typeof jasmine.matchers.toBeDefined;\n    toBeFalsy: typeof jasmine.matchers.toBeFalsy;\n    toBeGreaterThan: typeof jasmine.matchers.toBeGreaterThan;\n    toBeGreaterThanOrEqual: typeof jasmine.matchers.toBeGreaterThanOrEqual;\n    toBeLessThan: typeof jasmine.matchers.toBeLessThan;\n    toBeLessThanOrEqual: typeof jasmine.matchers.toBeLessThanOrEqual;\n    toBeNaN: typeof jasmine.matchers.toBeNaN;\n    toBeNull: typeof jasmine.matchers.toBeNull;\n    toBeTruthy: typeof jasmine.matchers.toBeTruthy;\n    toBeUndefined: typeof jasmine.matchers.toBeUndefined;\n    toContain: typeof jasmine.matchers.toContain;\n    toEqual: typeof jasmine.matchers.toEqual;\n    toHaveBeenCalled: typeof jasmine.matchers.toHaveBeenCalled;\n    toHaveBeenCalledTimes: typeof jasmine.matchers.toHaveBeenCalledTimes;\n    toHaveBeenCalledWith: typeof jasmine.matchers.toHaveBeenCalledWith;\n    toMatch: typeof jasmine.matchers.toMatch;\n    toThrow: typeof jasmine.matchers.toThrow;\n    toThrowError: typeof jasmine.matchers.toThrowError;\n}\n\n// Seen as: options\ninterface interface_694 {\n    addToExistingQueryString: any;\n    createElement: (arg0: void) => void;\n    createTextNode: (arg0: void) => void;\n    env: any;\n    getContainer: () => void;\n    onRaiseExceptionsClick: any;\n    onRandomClick: any;\n    onThrowExpectationsClick: any;\n    timer: any;\n}\n\ninterface interface_696 {\n    failedExpectations: Array<any>;\n    order: jasmine.Order;\n}\n\ninterface interface_651 {\n    [index: number]: {message: any, stack: any};\n    length: number;\n}\n\n// Seen as: result\ninterface interface_699 {\n    failedExpectations: interface_651;\n    fullName: string | number;\n    id: string | number;\n    passedExpectations: {length: string | number};\n    status: string;\n}\n\ninterface interface_701 {\n    failedExpectations: Array<any>;\n    order: jasmine.Order;\n}\n\ninterface interface_702 {\n    clearTimeout: (handle: number) => void;\n    setTimeout: (handler: any, timeout: any, args: any) => number;\n}\n\n// Seen as: attrs, options\ninterface interface_704 {\n    catchException: (e: {toString: () => void}) => boolean;\n    clearStack: (fn: () => void) => void;\n    fail: (error: {message: any}) => void;\n    onComplete: any;\n    onException: any;\n    queueableFns: any;\n    timeout: interface_702;\n    userContext: any;\n}\n\n// Seen as: arg0, queueableFns\ninterface interface_633 {\n    [index: number]: {fn: interface_906, timeout: () => void};\n    length: number;\n}\n\ninterface interface_706 {\n    clearTimeout: (handle: number) => void;\n    setTimeout: (handler: any, timeout: any, args: any) => number;\n}\n\n// Seen as: attrs, options\ninterface interface_707 {\n    actual: string;\n    error: any;\n    expected: string;\n    matcherName: string;\n    message: any;\n    messageFormatter: (error: interface_682) => string;\n    passed: boolean;\n    stackFormatter: (error: {stack: any}) => any;\n}\n\n// Seen as: result\ninterface interface_709 {\n    actual: string;\n    expected: string;\n    matcherName: string;\n    message: string;\n    passed: boolean;\n    stack: string;\n}\n\ninterface interface_711 {\n    clearTimeout: (handle: number) => void;\n    setTimeout: (handler: any, timeout: any, args: any) => number;\n}\n\n// Seen as: attrs, options\ninterface interface_713 {\n    catchException: (e: {toString: () => void}) => boolean;\n    clearStack: (fn: () => void) => void;\n    fail: (error: {message: any}) => void;\n    onComplete: any;\n    onException: any;\n    queueableFns: any;\n    timeout: interface_711;\n    userContext: any;\n}\n\n// Seen as: attrs\ninterface interface_715 {\n    beforeAndAfterFns: () => {afters: Array<any>, befores: Array<any>};\n    catchingExceptions: any;\n    description: string;\n    expectationFactory: (actual: any, spec: jasmine.Suite) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationResultFactory: (attrs: interface_707) => interface_709;\n    getSpecName: (spec: void) => string;\n    id: string | number;\n    onStart: (spec: void) => void;\n    queueRunnerFactory: (options: interface_713) => void;\n    queueableFn: {fn: () => void, timeout: () => number};\n    resultCallback: (result: void) => void;\n    throwOnExpectationFailure: boolean;\n    userContext: () => any;\n}\n\ninterface interface_716 {\n    actual: string;\n    error: any;\n    expected: string;\n    matcherName: string;\n    passed: boolean;\n}\n\ninterface interface_718 {\n    description: string;\n    failedExpectations: Array<any>;\n    fullName: any;\n    id: any;\n    passedExpectations: Array<any>;\n    pendingReason: string;\n}\n\n// Seen as: obj\ninterface interface_628 {\n}\n\n// Seen as: spy\ninterface interface_493 {\n    () : any;\n    and: jasmine.SpyStrategy;\n    calls: jasmine.CallTracker;\n}\n\n// Seen as: options\ninterface interface_720 {\n    fn: any;\n    getSpy: () => interface_493;\n    name: string | number;\n}\n\n// Seen as: attrs, options\ninterface interface_722 {\n    actual: string;\n    error: any;\n    expected: string;\n    matcherName: string;\n    message: any;\n    messageFormatter: (error: interface_682) => string;\n    passed: boolean;\n    stackFormatter: (error: {stack: any}) => any;\n}\n\n// Seen as: result\ninterface interface_724 {\n    actual: string;\n    expected: string;\n    matcherName: string;\n    message: string;\n    passed: boolean;\n    stack: string;\n}\n\ninterface interface_727 {\n    description: string;\n    failedExpectations: Array<any>;\n    fullName: string;\n    id: string;\n}\n\n// Seen as: currentDeclarationSuite, parentSuite\ninterface interface_728 {\n    addChild: void;\n    afterAll: void;\n    afterAllFns: Array<any>;\n    afterEach: void;\n    afterFns: Array<any>;\n    beforeAll: void;\n    beforeAllFns: Array<any>;\n    beforeEach: void;\n    beforeFns: Array<any>;\n    children: Array<any>;\n    description: string;\n    disabled: boolean;\n    env: jasmine.Env;\n    expectationFactory: (actual: any, spec: jasmine.Suite) => {not: jasmine.Expectation} | jasmine.Expectation;\n    expectationResultFactory: (attrs: interface_722) => interface_724;\n    id: string;\n    markedPending: void;\n    parentSuite: any;\n    result: interface_727;\n    sharedContext: any;\n    throwOnExpectationFailure: boolean;\n}\n\n// Seen as: attrs\ninterface interface_731 {\n    description: string;\n    env: jasmine.Env;\n    expectationFactory: (actual: any, spec: jasmine.Suite) => jasmine.Expectation | {not: jasmine.Expectation};\n    expectationResultFactory: (attrs: interface_707) => interface_709;\n    id: string;\n    parentSuite: jasmine.Suite | interface_728;\n    throwOnExpectationFailure: boolean;\n}\n\ninterface interface_733 {\n    description: string;\n    failedExpectations: Array<any>;\n    fullName: string;\n    id: string;\n    status: string;\n}\n\ninterface interface_735 {\n    description: string;\n    failedExpectations: Array<any>;\n    fullName: string;\n    id: string;\n}\n\n// Seen as: attrs, options\ninterface interface_737 {\n    catchException: (e: {toString: () => void}) => boolean;\n    clearStack: (fn: () => void) => void;\n    fail: (error: {message: any}) => void;\n    onComplete: any;\n    onException: any;\n    queueableFns: any;\n    timeout: interface_711;\n    userContext: any;\n}\n\n// Seen as: arg0, node\ninterface interface_739 {\n    afterAllFns: any;\n    beforeAllFns: {concat: (arg0: void) => void};\n    children: any;\n    execute: (arg0: void, arg1: void) => void;\n    getResult: () => void;\n    id: string | number;\n    onException: {apply: (arg0: void, arg1: void) => void};\n    sharedUserContext: () => void;\n}\n\n// Seen as: arg0, node\ninterface interface_741 {\n    canBeReentered: () => void;\n    children: any;\n    id: string | number;\n    index: number;\n    isExecutable: () => void;\n    owner: interface_739;\n}\n\n// Seen as: attrs\ninterface interface_743 {\n    nodeComplete: (suite: void, result: void) => void;\n    nodeStart: (suite: void) => void;\n    orderChildren: (node: void) => any;\n    queueRunnerFactory: (options: interface_737) => void;\n    runnableIds: string[];\n    tree: interface_741 | jasmine.Suite;\n}\n\n// Seen as: stats\ninterface interface_611 {\n    valid: boolean;\n}\n\n// Seen as: attrs, options\ninterface interface_745 {\n    actual: string;\n    error: any;\n    expected: string;\n    matcherName: string;\n    message: any;\n    messageFormatter: (error: interface_682) => string;\n    passed: boolean;\n    stackFormatter: (error: {stack: any}) => any;\n}\n\n// Seen as: spy\ninterface interface_608 {\n    () : any;\n    and: jasmine.SpyStrategy;\n    calls: jasmine.CallTracker;\n}\n\n// Seen as: baseName, methodNames\ninterface interface_640 {\n    [index: number]: string | number;\n}\n\n// Seen as: obj\ninterface interface_644 {\n}\n\n// Seen as: value\ninterface interface_747 {\n    and: {identity: void};\n    jasmineToString: void;\n    nodeType: any;\n    toString: any;\n}\n\n// Seen as: a, b, obj\ninterface interface_749 {\n    constructor: void;\n    global: any;\n    ignoreCase: any;\n    innerText: any;\n    isEqualNode: void;\n    length: any;\n    message: any;\n    multiline: any;\n    nodeType: number;\n    outerHTML: any;\n    source: any;\n    textContent: any;\n}\n\n// Seen as: actual, putativeSpy, value\ninterface interface_751 {\n    and: {identity: void};\n    calls: {allArgs: void, any: void, count: void};\n    jasmineToString: void;\n    nodeType: any;\n    toString: any;\n}\n\ninterface interface_754 {\n    compare: (expected: any, expected1: any) => {pass: boolean};\n}\n\ninterface interface_755 {\n    compare: (actual: number, expected: number, precision: number) => {pass: boolean};\n}\n\ninterface interface_757 {\n    compare: (actual: number, expected: number) => {pass: boolean};\n}\n\ninterface interface_759 {\n    compare: (actual: number, expected: number) => {pass: boolean};\n}\n\ninterface interface_761 {\n    compare: (actual: number, expected: number) => {pass: boolean};\n}\n\ninterface interface_762 {\n    compare: (actual: number, expected: number) => {pass: boolean};\n}\n\n// Seen as: array, obj, putativeSpy, value\ninterface interface_465 {\n    and: {identity: () => void};\n    calls: any;\n    jasmineToString: () => void;\n    nodeType: any;\n}\n\ninterface interface_764 {\n    compare: (actual: number | Window | interface_465) => {message: string | (() => string), pass: boolean};\n}\n\n// Seen as: util\ninterface interface_766 {\n    contains: (arg0: void, arg1: void, arg2: void) => void;\n}\n\ninterface interface_768 {\n    compare: (actual: any, expected: any) => {pass: any};\n}\n\n// Seen as: util\ninterface interface_769 {\n    equals: (arg0: void, arg1: void, arg2: void) => void;\n}\n\ninterface interface_771 {\n    compare: (actual: any, expected: any) => {pass: boolean};\n}\n\n// Seen as: actual, array, obj, putativeSpy, value\ninterface interface_440 {\n    and: {identity: () => void};\n    calls: {any: () => void};\n    jasmineToString: () => void;\n    nodeType: any;\n}\n\ninterface interface_772 {\n    compare: (actual: number | Window | interface_440) => {message: string, pass: any};\n}\n\n// Seen as: actual, array, obj, putativeSpy, value\ninterface interface_459 {\n    and: {identity: () => void};\n    calls: {count: () => void};\n    jasmineToString: () => void;\n    nodeType: any;\n}\n\ninterface interface_774 {\n    compare: (actual: number | Window | interface_459, expected: number) => {message: string, pass: boolean};\n}\n\n// Seen as: util\ninterface interface_776 {\n    contains: (arg0: void, arg1: void, arg2: void) => void;\n}\n\ninterface interface_777 {\n    compare: () => {message: () => string, pass: boolean};\n}\n\ninterface interface_779 {\n    compare: (actual: string, expected: string) => {pass: boolean};\n}\n\n// Seen as: array, obj, putativeSpy, value\ninterface interface_455 {\n    and: {identity: () => void};\n    calls: any;\n    jasmineToString: () => void;\n    nodeType: any;\n}\n\ninterface interface_780 {\n    compare: (actual: () => void, expected: number | Window | interface_455) => {message: string | (() => string), pass: boolean};\n}\n\ninterface interface_782 {\n    compare: (actual: () => void) => {message: string | (() => string), pass: boolean};\n}\n\n// Seen as: haystack\ninterface interface_398 {\n    [index: number]: string | interface_401;\n    indexOf: (arg0: void) => void;\n    length: number;\n}\n\n// Seen as: a, b, obj\ninterface interface_413 {\n    asymmetricMatch: (arg0: void) => void;\n    constructor: NumberConstructor;\n    global: any;\n    ignoreCase: any;\n    innerText: any;\n    isEqualNode: (arg0: void) => void;\n    length: string;\n    message: any;\n    multiline: any;\n    nodeType: number;\n    outerHTML: any;\n    source: any;\n    textContent: any;\n}\n\ninterface function_784 {\n    (arg0: void, arg1: void) : void;\n}\n\n// Seen as: actual, array, expected, obj, putativeSpy, value\ninterface interface_607 {\n    and: {identity: () => void};\n    calls: {allArgs: void, any: void, count: void};\n    jasmineToString: () => void;\n    nodeType: any;\n    test: void;\n}\n\n// Seen as: methodNames, value\ninterface interface_786 {\n    and: {identity: void};\n    jasmineToString: void;\n    length: number;\n    nodeType: any;\n    toString: any;\n}\n\n// Seen as: j$\ninterface interface_787 {\n    matchersUtil: {contains: (arg0: void, arg1: void) => void};\n}\n\ninterface interface_790 {\n    argsToArray: (arg0: void) => void;\n    clone: (arg0: void) => void;\n}\n\n// Seen as: arguments, global, id\ninterface interface_518 {\n    [index: number]: any;\n    clearInterval: (arg0: any, arg1: void, arg2: void, arg3: void) => any;\n    clearTimeout: (id: any, arg1: void, arg2: void, arg3: void) => any;\n    length: number;\n    setInterval: (fn: any, interval: any, arg2: void, arg3: void, arg4: void) => any;\n    setTimeout: (fn: any, delay: any, arg2: void, arg3: void, arg4: void) => any;\n}\n\n// Seen as: mockDate\ninterface interface_792 {\n    install: (arg0: void) => void;\n    tick: (arg0: void) => void;\n    uninstall: () => void;\n}\n\n// Seen as: arguments, global, id\ninterface interface_521 {\n    [index: number]: any;\n    clearInterval: (arg0: any, arg1: void, arg2: void, arg3: void) => any;\n    clearTimeout: (id: any, arg1: void, arg2: void, arg3: void) => any;\n    length: number;\n    setInterval: (fn: any, interval: any, arg2: void, arg3: void, arg4: void) => any;\n    setTimeout: (fn: any, delay: any, arg2: void, arg3: void, arg4: void) => any;\n}\n\n// Seen as: arguments, global, id\ninterface interface_520 {\n    [index: number]: any;\n    clearInterval: (arg0: any, arg1: void, arg2: void, arg3: void) => any;\n    clearTimeout: (id: any, arg1: void, arg2: void, arg3: void) => any;\n    length: number;\n    setInterval: (fn: any, interval: any, arg2: void, arg3: void, arg4: void) => any;\n    setTimeout: (fn: any, delay: any, arg2: void, arg3: void, arg4: void) => any;\n}\n\ninterface function_794 {\n    () : interface_796;\n}\n\n// Seen as: self\ninterface interface_796 {\n    clearInterval: (id: interface_521) => any;\n    clearTimeout: (id: interface_520) => any;\n    install: function_794;\n    mockDate: (initialDate: any) => void;\n    setInterval: (fn: any, delay: any, params: any) => any;\n    setTimeout: (fn: any, delay: any, params: any) => any;\n    tick: (millis: any) => void;\n    uninstall: () => void;\n    withMock: (closure: () => void) => void;\n}\n\n// Seen as: self\ninterface interface_798 {\n    removeFunctionWithId: (timeoutKey: any) => void;\n    scheduleFunction: (funcToCall: string | (() => any), millis: number, params: any, recurring: any, timeoutKey: number, newCurrentTime: string) => number;\n    tick: (millis: number, tickDate: (arg0: void) => void) => void;\n}\n\ninterface interface_800 {\n    Factory: (arg0: void) => void;\n    addCoreMatchers: (arg0: void) => void;\n}\n\ninterface interface_540 {\n    (arg0: void) : void;\n    isPendingSpecException: (arg0: void) => void;\n    pendingSpecExceptionMessage: string | number;\n}\n\n// Seen as: j$\ninterface interface_802 {\n    Clock: (arg0: void, arg1: void, arg2: void) => void;\n    DEFAULT_TIMEOUT_INTERVAL: any;\n    DelayedFunctionScheduler: () => void;\n    ExceptionFormatter: () => void;\n    Expectation: interface_800;\n    MockDate: (arg0: void) => void;\n    Order: (arg0: void) => void;\n    QueueRunner: (arg0: void) => void;\n    ReportDispatcher: (arg0: void) => void;\n    Spec: interface_540;\n    SpyRegistry: (arg0: void) => void;\n    Suite: (arg0: void) => void;\n    TreeProcessor: (arg0: void) => void;\n    buildExpectationResult: (arg0: void) => void;\n    getGlobal: () => void;\n    matchers: any;\n    matchersUtil: any;\n    util: {clone: (arg0: void) => void};\n}\n\n// Seen as: Expectation\ninterface interface_558 {\n    (options: interface_907) : void;\n    Factory: (options: interface_908) => {not: any};\n    addCoreMatchers: (matchers: any) => void;\n}\n\n// Seen as: j$\ninterface interface_805 {\n    HtmlReporter: (options: void) => any;\n    HtmlSpecFilter: (options: void) => void;\n    QueryString: (options: void) => any;\n    ResultsNode: (result: void, type: void, parent: void) => void;\n    version: any;\n}\n\n// Seen as: options\ninterface interface_807 {\n    addToExistingQueryString: any;\n    createElement: (arg0: void) => void;\n    createTextNode: (arg0: void) => void;\n    env: any;\n    getContainer: () => void;\n    onRaiseExceptionsClick: any;\n    onRandomClick: any;\n    onThrowExpectationsClick: any;\n    timer: any;\n}\n\ninterface interface_523 {\n    [index: number]: {message: any, stack: any};\n    length: number;\n}\n\n// Seen as: arg0, result\ninterface interface_809 {\n    failedExpectations: interface_523;\n    fullName: string | number;\n    id: string | number;\n    passedExpectations: {length: string | number};\n    status: string;\n}\n\ninterface interface_811 {\n    initialize: () => void;\n    jasmineDone: (doneResult: {failedExpectations: any, order: any}) => void;\n    jasmineStarted: (options: {totalSpecsDefined: any}) => void;\n    specDone: (result: interface_809) => void;\n    specStarted: (result: any) => void;\n    suiteDone: (result: {status: string}) => void;\n    suiteStarted: (result: any) => void;\n}\n\n// Seen as: FakeDate, GlobalDate\ninterface interface_548 {\n    (arg0: void, arg1: void, arg2: void, arg3: void, arg4: void, arg5: void, arg6: void) : any;\n    UTC: any;\n    now: () => number;\n    parse: any;\n    toSource: any;\n}\n\n// Seen as: self\ninterface interface_813 {\n    install: (mockDate: {getTime: () => void}) => void;\n    tick: (millis: number) => void;\n    uninstall: () => void;\n}\n\ninterface interface_815 {\n    fullStringWithNewParam: (key: string, value: any) => string;\n    getParam: (key: string) => any;\n    navigateWithNewParam: (key: any, value: any) => void;\n}\n\n// Seen as: attrs\ninterface interface_818 {\n    catchException: any;\n    clearStack: any;\n    fail: any;\n    onComplete: any;\n    onException: any;\n    queueableFns: any;\n    timeout: any;\n    userContext: any;\n}\n\ninterface interface_545 {\n    addReporter: (reporter: any) => void;\n    provideFallbackReporter: (fallbackReporter: any) => void;\n}\n\n// Seen as: Spec\ninterface interface_553 {\n    (attrs: interface_909) : void;\n    isPendingSpecException: (e: {toString: () => void}) => boolean;\n    pendingSpecExceptionMessage: string;\n}\n\n// Seen as: j$\ninterface interface_819 {\n    createSpy: (arg0: void, arg1: void) => void;\n    formatErrorMsg: (arg0: void, arg1: void) => void;\n    isSpy: (arg0: void) => void;\n    util: {isUndefined: (arg0: void) => void};\n}\n\n// Seen as: j$\ninterface interface_822 {\n    isA_: (arg0: void, arg1: void) => void;\n    isString_: (arg0: void) => void;\n}\n\n// Seen as: attrs\ninterface interface_823 {\n    description: any;\n    env: any;\n    expectationFactory: any;\n    expectationResultFactory: any;\n    id: any;\n    parentSuite: any;\n    throwOnExpectationFailure: any;\n}\n\n// Seen as: runnableIds\ninterface interface_502 {\n    [index: number]: any;\n    length: number;\n}\n\n// Seen as: arg0, node\ninterface interface_827 {\n    afterAllFns: any;\n    beforeAllFns: {concat: (arg0: void) => void};\n    children: any;\n    execute: (arg0: void, arg1: void) => void;\n    getResult: () => void;\n    id: string | number;\n    onException: {apply: (arg0: void, arg1: void) => void};\n    sharedUserContext: () => void;\n}\n\n// Seen as: arg0, node, tree\ninterface interface_833 {\n    afterAllFns: any;\n    beforeAllFns: {concat: (arg0: void) => void};\n    canBeReentered: () => void;\n    children: any;\n    id: string | number;\n    index: number;\n    isExecutable: () => void;\n    onException: {apply: (arg0: void, arg1: void) => void};\n    owner: interface_827;\n    sharedUserContext: () => void;\n}\n\n// Seen as: attrs\ninterface interface_840 {\n    nodeComplete: any;\n    nodeStart: any;\n    orderChildren: any;\n    queueRunnerFactory: (arg0: void) => void;\n    runnableIds: interface_502;\n    tree: interface_833;\n}\n\n// Seen as: spy\ninterface interface_582 {\n    () : any;\n    and: {exec: {apply: (arg0: void, arg1: void) => void}};\n    calls: {track: (arg0: void) => void};\n}\n\n// Seen as: baseName, methodNames\ninterface interface_584 {\n    [index: number]: string | number;\n}\n\n// Seen as: baseName, methodNames\ninterface interface_585 {\n    [index: number]: string | number;\n}\n\n// Seen as: obj\ninterface interface_588 {\n}\n\n// Seen as: j$\ninterface interface_848 {\n    Any: (arg0: void) => void;\n    Anything: () => void;\n    ArrayContaining: (arg0: void) => void;\n    CallTracker: () => void;\n    DEFAULT_TIMEOUT_INTERVAL: number;\n    Env: (arg0: void) => void;\n    MAX_PRETTY_PRINT_ARRAY_LENGTH: number;\n    MAX_PRETTY_PRINT_DEPTH: number;\n    ObjectContaining: (arg0: void) => void;\n    SpyStrategy: (arg0: void) => void;\n    StringMatching: (arg0: void) => void;\n    any: (clazz: any) => any;\n    anything: () => any;\n    arrayContaining: (sample: any) => any;\n    createSpy: (name: any, originalFn: any) => interface_582;\n    createSpyObj: (methodNames: string | interface_584, methodNames1: string | interface_585) => interface_588;\n    currentEnv_: any;\n    fnNameFor: (func: {name: any, toString: () => void}) => string;\n    getEnv: (options: any) => any;\n    getGlobal: () => any;\n    isA_: (typeName: string | number, value: any) => boolean;\n    isArray_: (value: any) => boolean;\n    isDomNode: (obj: {nodeType: number}) => boolean;\n    isNumber_: (value: any) => boolean;\n    isSpy: (putativeSpy: {and: any, calls: any}) => boolean;\n    isString_: (value: any) => boolean;\n    objectContaining: (sample: any) => any;\n    stringMatching: (expected: any) => any;\n    unimplementedMethod_: () => void;\n    util: {isUndefined: (arg0: void) => void};\n}\n\n// Seen as: options\ninterface interface_856 {\n    actual: any;\n    error: any;\n    expected: any;\n    matcherName: any;\n    message: any;\n    messageFormatter: any;\n    passed: any;\n    stackFormatter: any;\n}\n\n// Seen as: result\ninterface interface_860 {\n    actual: any;\n    expected: any;\n    matcherName: any;\n    message: string;\n    passed: any;\n    stack: string;\n}\n\n// Seen as: jRequire\ninterface interface_864 {\n    Any: (arg0: void) => void;\n    Anything: (arg0: void) => void;\n    ArrayContaining: (arg0: void) => void;\n    CallTracker: (arg0: void) => void;\n    Clock: () => void;\n    DelayedFunctionScheduler: () => void;\n    Env: (arg0: void) => void;\n    ExceptionFormatter: () => void;\n    Expectation: () => void;\n    JsApiReporter: () => void;\n    MockDate: () => void;\n    ObjectContaining: (arg0: void) => void;\n    Order: () => void;\n    QueueRunner: (arg0: void) => void;\n    ReportDispatcher: () => void;\n    Spec: (arg0: void) => void;\n    SpyRegistry: (arg0: void) => void;\n    SpyStrategy: () => void;\n    StringMatching: (arg0: void) => void;\n    Suite: (arg0: void) => void;\n    Timer: () => void;\n    TreeProcessor: () => void;\n    base: (arg0: void, arg1: void) => void;\n    buildExpectationResult: () => void;\n    errors: () => void;\n    formatErrorMsg: () => void;\n    matchersUtil: (arg0: void) => void;\n    pp: (arg0: void) => void;\n    requireMatchers: (arg0: void, arg1: void) => void;\n    util: () => void;\n    version: () => void;\n}\n\n// Seen as: j$\ninterface interface_869 {\n    Any: any;\n    Anything: any;\n    ArrayContaining: any;\n    CallTracker: any;\n    Clock: any;\n    DelayedFunctionScheduler: any;\n    Env: any;\n    ExceptionFormatter: any;\n    Expectation: any;\n    JsApiReporter: any;\n    MockDate: any;\n    ObjectContaining: any;\n    Order: any;\n    QueueRunner: any;\n    ReportDispatcher: any;\n    Spec: any;\n    SpyRegistry: any;\n    SpyStrategy: any;\n    StringMatching: any;\n    Suite: any;\n    Timer: any;\n    TreeProcessor: any;\n    buildExpectationResult: any;\n    errors: any;\n    formatErrorMsg: any;\n    matchers: any;\n    matchersUtil: any;\n    pp: any;\n    util: any;\n    version: any;\n}\n\ninterface interface_870 {\n    ExpectationFailed: ObjectConstructor | ErrorConstructor;\n}\n\n// Seen as: j$\ninterface interface_871 {\n    HtmlReporter: (options: interface_807) => interface_811;\n    HtmlSpecFilter: (options: {filterString: () => void}) => void;\n    QueryString: (options: {getWindowLocation: () => void}) => interface_815;\n    ResultsNode: (result: any, type: any, parent: any) => void;\n    version: any;\n}\n\ninterface interface_873 {\n    Any: (j$: {fnNameFor: (arg0: void) => void}) => (expectedObject: any) => void;\n    Anything: (j$: {util: {isUndefined: (arg0: void) => void}}) => () => void;\n    ArrayContaining: (j$: interface_787) => (sample: any) => void;\n    CallTracker: (j$: {util: interface_790}) => () => void;\n    Clock: () => (global: interface_518, delayedFunctionSchedulerFactory: () => void, mockDate: interface_792) => interface_796;\n    DelayedFunctionScheduler: () => () => interface_798;\n    Env: (j$: interface_802) => (options: {global: any}) => void;\n    ExceptionFormatter: () => () => void;\n    Expectation: () => interface_558;\n    HtmlReporter: (j$: interface_805) => (options: interface_807) => interface_811;\n    HtmlSpecFilter: () => (options: {filterString: () => void}) => void;\n    JsApiReporter: () => (options: {timer: any}) => void;\n    MockDate: () => (global: {Date: interface_548}) => interface_813;\n    ObjectContaining: (j$: {pp: (arg0: void) => void}) => (sample: any) => void;\n    Order: () => (options: {random: boolean, seed: any}) => void;\n    QueryString: () => (options: {getWindowLocation: () => void}) => interface_815;\n    QueueRunner: (j$: {getGlobal: () => void}) => (attrs: interface_818) => void;\n    ReportDispatcher: () => (methods: any) => interface_545;\n    ResultsNode: () => (result: any, type: any, parent: any) => void;\n    Spec: (j$: {errors: {ExpectationFailed: () => void}}) => interface_553;\n    SpyRegistry: (j$: interface_819) => (options: {currentSpies: any}) => void;\n    SpyStrategy: () => (options: {fn: any, getSpy: any, name: any}) => void;\n    StringMatching: (j$: interface_822) => (expected: string) => void;\n    Suite: (j$: {errors: {ExpectationFailed: () => void}}) => (attrs: interface_823) => void;\n    Timer: () => (options: {now: any}) => void;\n    TreeProcessor: () => (attrs: interface_840) => void;\n    base: (j$: interface_848, jasmineGlobal: any) => void;\n    buildExpectationResult: () => (options: interface_856) => interface_860;\n    core: (jRequire: interface_864) => interface_869;\n    errors: () => interface_870;\n    formatErrorMsg: () => (domain: string | number, usage: string | number) => (msg: string | number) => string;\n    html: (j$: interface_871) => void;\n    \"interface\": function_872;\n    matchersUtil: (j$: interface_874) => interface_876;\n    pp: (j$: interface_878) => (value: any) => any;\n    requireMatchers: (jRequire: interface_535, j$: any) => interface_538;\n    toBe: () => () => interface_879;\n    toBeCloseTo: () => () => interface_880;\n    toBeDefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeFalsy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeGreaterThan: () => () => interface_881;\n    toBeGreaterThanOrEqual: () => () => interface_882;\n    toBeLessThan: () => () => interface_883;\n    toBeLessThanOrEqual: () => () => interface_884;\n    toBeNaN: (j$: {pp: (arg0: void) => void}) => () => interface_885;\n    toBeNull: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeTruthy: () => () => {compare: (actual: any) => {pass: boolean}};\n    toBeUndefined: () => () => {compare: (actual: any) => {pass: boolean}};\n    toContain: () => (util: interface_886, customEqualityTesters: Array<any>) => interface_887;\n    toEqual: () => (util: interface_888, customEqualityTesters: Array<any>) => interface_889;\n    toHaveBeenCalled: (j$: interface_890) => () => interface_892;\n    toHaveBeenCalledTimes: (j$: interface_893) => () => interface_895;\n    toHaveBeenCalledWith: (j$: interface_896) => (util: interface_897, customEqualityTesters: any) => interface_898;\n    toMatch: (j$: interface_899) => () => interface_900;\n    toThrow: (j$: interface_901) => (util: {equals: (arg0: void, arg1: void) => void}) => interface_902;\n    toThrowError: (j$: interface_903) => () => interface_904;\n    util: () => interface_905;\n    version: () => string;\n}\n\ninterface function_872 {\n    (jasmine: interface_910, env: interface_911) : interface_912;\n}\n\n// Seen as: j$\ninterface interface_874 {\n    isA_: (arg0: void, arg1: void) => void;\n    isDomNode: (arg0: void) => void;\n    pp: (arg0: void) => void;\n    util: {isUndefined: (arg0: void) => void};\n}\n\n// Seen as: haystack\ninterface interface_560 {\n    [index: number]: string | interface_562;\n    indexOf: (arg0: void) => void;\n    length: number;\n}\n\n// Seen as: a, arg0, arg1, b, obj\ninterface interface_565 {\n    asymmetricMatch: (arg0: void) => void;\n    constructor: NumberConstructor;\n    global: any;\n    ignoreCase: any;\n    innerText: any;\n    isEqualNode: (arg0: void) => void;\n    length: string;\n    message: any;\n    multiline: any;\n    outerHTML: any;\n    source: any;\n    textContent: any;\n}\n\ninterface function_875 {\n    (arg0: void, arg1: void) : void;\n}\n\n// Seen as: a, arg0, arg1, b, obj\ninterface interface_573 {\n    asymmetricMatch: (arg0: void) => void;\n    constructor: NumberConstructor;\n    global: any;\n    ignoreCase: any;\n    innerText: any;\n    isEqualNode: (arg0: void) => void;\n    length: string;\n    message: any;\n    multiline: any;\n    outerHTML: any;\n    source: any;\n    textContent: any;\n}\n\n// Seen as: a, arg0, arg1, b, obj\ninterface interface_575 {\n    asymmetricMatch: (arg0: void) => void;\n    constructor: NumberConstructor;\n    global: any;\n    ignoreCase: any;\n    innerText: any;\n    isEqualNode: (arg0: void) => void;\n    length: string;\n    message: any;\n    multiline: any;\n    outerHTML: any;\n    source: any;\n    textContent: any;\n}\n\ninterface interface_876 {\n    buildFailureMessage: () => string;\n    contains: (haystack: interface_560, needle: string | interface_565, customTesters: Array<function_875>) => boolean;\n    equals: (a: string | interface_573, b: string | interface_575, customTesters: Array<function_875>) => boolean;\n}\n\ninterface interface_877 {\n    arrayContains: (arg0: void, arg1: void) => void;\n    inherit: (arg0: void, arg1: void) => void;\n    isUndefined: (arg0: void) => void;\n}\n\n// Seen as: j$\ninterface interface_878 {\n    MAX_PRETTY_PRINT_ARRAY_LENGTH: any;\n    MAX_PRETTY_PRINT_DEPTH: number;\n    fnNameFor: (arg0: void) => void;\n    getGlobal: () => void;\n    isA_: (arg0: void, arg1: void) => void;\n    isArray_: (arg0: void) => void;\n    isSpy: (arg0: void) => void;\n    unimplementedMethod_: any;\n    util: interface_877;\n}\n\n// Seen as: jRequire\ninterface interface_535 {\n}\n\n// Seen as: matchers\ninterface interface_538 {\n}\n\ninterface interface_879 {\n    compare: (expected: any, expected1: any) => {pass: boolean};\n}\n\ninterface interface_880 {\n    compare: (actual: number, expected: number, precision: number) => {pass: boolean};\n}\n\ninterface interface_881 {\n    compare: (actual: number, expected: number) => {pass: boolean};\n}\n\ninterface interface_882 {\n    compare: (actual: number, expected: number) => {pass: boolean};\n}\n\ninterface interface_883 {\n    compare: (actual: number, expected: number) => {pass: boolean};\n}\n\ninterface interface_884 {\n    compare: (actual: number, expected: number) => {pass: boolean};\n}\n\ninterface interface_885 {\n    compare: (actual: any) => {message: string | (() => string), pass: boolean};\n}\n\n// Seen as: util\ninterface interface_886 {\n    contains: (arg0: void, arg1: void, arg2: void) => void;\n}\n\ninterface interface_887 {\n    compare: (actual: any, expected: any) => {pass: any};\n}\n\n// Seen as: util\ninterface interface_888 {\n    equals: (arg0: void, arg1: void, arg2: void) => void;\n}\n\ninterface interface_889 {\n    compare: (actual: any, expected: any) => {pass: boolean};\n}\n\n// Seen as: j$\ninterface interface_890 {\n    formatErrorMsg: (arg0: void, arg1: void) => void;\n    isSpy: (arg0: void) => void;\n    pp: (arg0: void) => void;\n}\n\n// Seen as: actual\ninterface interface_891 {\n    and: {identity: () => void};\n    calls: {any: () => void};\n}\n\ninterface interface_892 {\n    compare: (actual: interface_891) => {message: string, pass: any};\n}\n\n// Seen as: j$\ninterface interface_893 {\n    formatErrorMsg: (arg0: void, arg1: void) => void;\n    isNumber_: (arg0: void) => void;\n    isSpy: (arg0: void) => void;\n    pp: (arg0: void) => void;\n}\n\n// Seen as: actual\ninterface interface_894 {\n    and: {identity: () => void};\n    calls: {count: () => void};\n}\n\ninterface interface_895 {\n    compare: (actual: interface_894, expected: number) => {message: string, pass: boolean};\n}\n\n// Seen as: j$\ninterface interface_896 {\n    formatErrorMsg: (arg0: void, arg1: void) => void;\n    isSpy: (arg0: void) => void;\n    pp: (arg0: void) => void;\n}\n\n// Seen as: util\ninterface interface_897 {\n    contains: (arg0: void, arg1: void, arg2: void) => void;\n}\n\ninterface interface_898 {\n    compare: () => {message: () => string, pass: boolean};\n}\n\n// Seen as: j$\ninterface interface_899 {\n    formatErrorMsg: (arg0: void, arg1: void) => void;\n    isA_: (arg0: void, arg1: void) => void;\n    isString_: (arg0: void) => void;\n}\n\ninterface interface_900 {\n    compare: (actual: string, expected: string) => {pass: boolean};\n}\n\n// Seen as: j$\ninterface interface_901 {\n    formatErrorMsg: (arg0: void, arg1: void) => void;\n    pp: (arg0: void) => void;\n}\n\ninterface interface_902 {\n    compare: (actual: () => void, expected: any) => {message: string | (() => string), pass: boolean};\n}\n\n// Seen as: j$\ninterface interface_903 {\n    fnNameFor: (arg0: void) => void;\n    formatErrorMsg: (arg0: void, arg1: void) => void;\n    pp: (arg0: void) => void;\n}\n\ninterface interface_904 {\n    compare: (actual: () => void) => {message: string | (() => string), pass: boolean};\n}\n\n// Seen as: args\ninterface interface_529 {\n    [index: number]: any;\n    length: number;\n}\n\n// Seen as: array\ninterface interface_527 {\n    [index: number]: any;\n    length: number;\n}\n\n// Seen as: util\ninterface interface_905 {\n    argsToArray: (args: interface_529) => Array<any>;\n    arrayContains: (array: interface_527, search: any) => boolean;\n    clone: (obj: {slice: () => void}) => any;\n    htmlEscape: (str: {replace: (arg0: void, arg1: void) => void}) => {replace: (arg0: void, arg1: void) => void};\n    inherit: (childClass: {prototype: any}, parentClass: {prototype: any}) => void;\n    isUndefined: (obj: any) => boolean;\n}\n\n// Seen as: a, b, obj\ninterface interface_401 {\n    asymmetricMatch: (arg0: void) => void;\n    constructor: NumberConstructor;\n    global: any;\n    ignoreCase: any;\n    innerText: any;\n    isEqualNode: (arg0: void) => void;\n    length: string;\n    message: any;\n    multiline: any;\n    nodeType: number;\n    outerHTML: any;\n    source: any;\n    textContent: any;\n}\n\ninterface interface_906 {\n    call: (arg0: void, arg1: void) => void;\n    length: number;\n}\n\n// Seen as: arg0, options\ninterface interface_907 {\n    actual: any;\n    addExpectationResult: any;\n    customEqualityTesters: any;\n    customMatchers: any;\n    isNot: any;\n    util: any;\n}\n\n// Seen as: arg0, options\ninterface interface_908 {\n    actual: any;\n    addExpectationResult: any;\n    customEqualityTesters: any;\n    customMatchers: any;\n    isNot: boolean;\n    util: any;\n}\n\n// Seen as: attrs\ninterface interface_909 {\n    beforeAndAfterFns: any;\n    catchingExceptions: any;\n    description: any;\n    expectationFactory: any;\n    expectationResultFactory: any;\n    getSpecName: any;\n    id: any;\n    onStart: any;\n    queueRunnerFactory: any;\n    queueableFn: {fn: any};\n    resultCallback: any;\n    throwOnExpectationFailure: any;\n    userContext: any;\n}\n\n// Seen as: jasmine\ninterface interface_910 {\n    JsApiReporter: (arg0: void) => void;\n    Timer: () => void;\n    addCustomEqualityTester: (tester: any) => void;\n    addMatchers: (matchers: any) => any;\n    clock: () => any;\n}\n\n// Seen as: env\ninterface interface_911 {\n    addCustomEqualityTester: (arg0: void) => void;\n    addMatchers: (arg0: void) => void;\n    afterAll: {apply: (arg0: void, arg1: void) => void};\n    afterEach: {apply: (arg0: void, arg1: void) => void};\n    beforeAll: {apply: (arg0: void, arg1: void) => void};\n    beforeEach: {apply: (arg0: void, arg1: void) => void};\n    clock: any;\n    describe: (arg0: void, arg1: void) => void;\n    expect: (arg0: void) => void;\n    fail: {apply: (arg0: void, arg1: void) => void};\n    fdescribe: (arg0: void, arg1: void) => void;\n    fit: {apply: (arg0: void, arg1: void) => void};\n    it: {apply: (arg0: void, arg1: void) => void};\n    pending: {apply: (arg0: void, arg1: void) => void};\n    spyOn: (arg0: void, arg1: void) => void;\n    xdescribe: (arg0: void, arg1: void) => void;\n    xit: {apply: (arg0: void, arg1: void) => void};\n}\n\n// Seen as: jasmineInterface\ninterface interface_912 {\n    afterAll: () => any;\n    afterEach: () => any;\n    beforeAll: () => any;\n    beforeEach: () => any;\n    describe: (description: any, specDefinitions: any) => any;\n    expect: (actual: any) => any;\n    fail: () => any;\n    fdescribe: (description: any, specDefinitions: any) => any;\n    fit: () => any;\n    it: () => any;\n    jasmine: interface_910;\n    jsApiReporter: any;\n    pending: () => any;\n    spyOn: (obj: any, methodName: any) => any;\n    xdescribe: (description: any, specDefinitions: any) => any;\n    xit: () => any;\n}\n\n// Seen as: a, arg0, arg1, b, obj\ninterface interface_562 {\n    asymmetricMatch: (arg0: void) => void;\n    constructor: NumberConstructor;\n    global: any;\n    ignoreCase: any;\n    innerText: any;\n    isEqualNode: (arg0: void) => void;\n    length: string;\n    message: any;\n    multiline: any;\n    outerHTML: any;\n    source: any;\n    textContent: any;\n}\n\n","newDecAvailable":false}